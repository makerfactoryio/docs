{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Makerfactory Documentation \u00b6 Development \u00b6 ESP32 Development Kit M5Stack Educational \u00b6 RoboBug Hexapod Raspberry Learning Package Kits \u00b6 Tec-Egg","title":"Overview"},{"location":"#welcome-to-the-makerfactory-documentation","text":"","title":"Welcome to the Makerfactory Documentation"},{"location":"#development","text":"ESP32 Development Kit M5Stack","title":"Development"},{"location":"#educational","text":"RoboBug Hexapod Raspberry Learning Package","title":"Educational"},{"location":"#kits","text":"Tec-Egg","title":"Kits"},{"location":"license/","text":"The provided source code has the following license: Copyright \u00a9 2018 Conrad Electronic SE. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"development-boards/esp32/","text":"Documentation for the Embedded Board Builder for ESP32 \u00b6 This documentation describes the ESP32 Evalulation board as part of the Embedded Board Builder (EBB) family from Makerfactory. This board is an development board for the ESP32 module from Expressif Systems . With this development board you can develop projects for the ESP32-WROOM-32 (for more information check the datasheet on the page of Expressif Systems ) or ESP32-WROVER (for more information check the datasheet on the page of Expressif Systems ). Info The screenshots are created with the english version of Windows 10. If screenshots completely differ from the Mac OS version it's mentioned in the text. Board \u00b6 The following picture shows the ESP32 Evaluation Board in Version V1.3. Peripheral components \u00b6 The EBB for ESP32 comes with a bunch of peripheral components which could be used for own projects. The usage of these components is described in this document. The following table lists the components: Hint The ESP32 module has a limited number of usable IO ports. It is not possible to use all components on the board at the same time. Therefore you have to decide which component on the evaluation board you want to use in your project. In order to use a component you have to switch on the appropriate dip switches. Additionally you have to switch off conflicting components. The components which are using the same IO are described in the component pages. Audio Amplifier Camera GPIO Grove Gyro I2C Pull-up Menu Microphone mikroBUS Motor OLED-LCD Potentiometer RFID RGB LED SD CARD Temperature TFT Unit-Bus Schematics of the evaluation board \u00b6 Download the schematics of the evaluation board if you need deep information about the structure of the board. The schematics could be found here . License for the source code \u00b6 The provided source code has the following license: Copyright \u00a9 2018 Conrad Electronic SE. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Quick start"},{"location":"development-boards/esp32/#documentation-for-the-embedded-board-builder-for-esp32","text":"This documentation describes the ESP32 Evalulation board as part of the Embedded Board Builder (EBB) family from Makerfactory. This board is an development board for the ESP32 module from Expressif Systems . With this development board you can develop projects for the ESP32-WROOM-32 (for more information check the datasheet on the page of Expressif Systems ) or ESP32-WROVER (for more information check the datasheet on the page of Expressif Systems ). Info The screenshots are created with the english version of Windows 10. If screenshots completely differ from the Mac OS version it's mentioned in the text.","title":"Documentation for the Embedded Board Builder for ESP32"},{"location":"development-boards/esp32/#board","text":"The following picture shows the ESP32 Evaluation Board in Version V1.3.","title":"Board"},{"location":"development-boards/esp32/#peripheral-components","text":"The EBB for ESP32 comes with a bunch of peripheral components which could be used for own projects. The usage of these components is described in this document. The following table lists the components: Hint The ESP32 module has a limited number of usable IO ports. It is not possible to use all components on the board at the same time. Therefore you have to decide which component on the evaluation board you want to use in your project. In order to use a component you have to switch on the appropriate dip switches. Additionally you have to switch off conflicting components. The components which are using the same IO are described in the component pages. Audio Amplifier Camera GPIO Grove Gyro I2C Pull-up Menu Microphone mikroBUS Motor OLED-LCD Potentiometer RFID RGB LED SD CARD Temperature TFT Unit-Bus","title":"Peripheral components"},{"location":"development-boards/esp32/#schematics-of-the-evaluation-board","text":"Download the schematics of the evaluation board if you need deep information about the structure of the board. The schematics could be found here .","title":"Schematics of the evaluation board"},{"location":"development-boards/esp32/#license-for-the-source-code","text":"The provided source code has the following license: Copyright \u00a9 2018 Conrad Electronic SE. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License for the source code"},{"location":"development-boards/esp32/audio/","text":"Overview \u00b6 The component AUDIO AMPLIFIER of the ESP board includes the MAX98357A, a digital 3W Class D Audio Amplifier. This amplifier provides an digital pulse-code modulation (PCM) input supporting I2S data and delivers a 3.2W output power into 4\u03a9 (4 Ohms) at 5V. It accepts specified sample rates between 8kHz and 96kHz for all supported data formats. Example An example project for the Arduino IDE can be found in the chapter for the microphone. ESP Board Audio Amplifier SW306 Activating the component \u00b6 The component has the dip switch SW306 for activating the component. Function SWITCH IO port Conflicts with Remarks SD_MODE SW306-1 16 mikroBus , SW404-3, RX; Camera , SW403-2, WRST; Unit-Bus , SW201-1, CN212 - PIN 3; Grove UART , SW202-2, UART TX BCKL SW306-2 26 MENU , SW401-3, LEFT; Camera , SW402-6, D4 LRCLK SW306-3 25 MENU , SW401-2, DOWN; Camera , SW400-1, D5 DIN SW306-4 22 mikroBus , SW404-5, SCL; Camera , SW400-6, SIOC/SCL Using the component \u00b6 Connect your 4\u03a9 speaker at connector J300 at P and N. Sample project \u00b6 An example project for the Arduino IDE can be found in the chapter for the microphone.","title":"Audio Amplifier"},{"location":"development-boards/esp32/audio/#overview","text":"The component AUDIO AMPLIFIER of the ESP board includes the MAX98357A, a digital 3W Class D Audio Amplifier. This amplifier provides an digital pulse-code modulation (PCM) input supporting I2S data and delivers a 3.2W output power into 4\u03a9 (4 Ohms) at 5V. It accepts specified sample rates between 8kHz and 96kHz for all supported data formats. Example An example project for the Arduino IDE can be found in the chapter for the microphone. ESP Board Audio Amplifier SW306","title":"Overview"},{"location":"development-boards/esp32/audio/#activating-the-component","text":"The component has the dip switch SW306 for activating the component. Function SWITCH IO port Conflicts with Remarks SD_MODE SW306-1 16 mikroBus , SW404-3, RX; Camera , SW403-2, WRST; Unit-Bus , SW201-1, CN212 - PIN 3; Grove UART , SW202-2, UART TX BCKL SW306-2 26 MENU , SW401-3, LEFT; Camera , SW402-6, D4 LRCLK SW306-3 25 MENU , SW401-2, DOWN; Camera , SW400-1, D5 DIN SW306-4 22 mikroBus , SW404-5, SCL; Camera , SW400-6, SIOC/SCL","title":"Activating the component"},{"location":"development-boards/esp32/audio/#using-the-component","text":"Connect your 4\u03a9 speaker at connector J300 at P and N.","title":"Using the component"},{"location":"development-boards/esp32/audio/#sample-project","text":"An example project for the Arduino IDE can be found in the chapter for the microphone.","title":"Sample project"},{"location":"development-boards/esp32/camera/","text":"Overview \u00b6 The component camera allows the connection of a camera chip of type OV7670. OV7670 is a camera module with FiFo supporting 640x480 VGA. The PIN description is listed at the backside of the board. Example There is one example project for the Arduino IDE which can be downloaded: Camera_Webserver.ino ( download here ) ESP Board camera connector SW400,SW402,SW403 Activating the component \u00b6 The component has three dip switches for controlling the component: SW400 , SW402 and SW403 . Function SWITCH IO port Conflicts with Remarks RRST SW403-1 17 Microphone , SW301-2, SCK; mikroBus , SW404-4, TX; Unit-Bus , SW201-2, CN212 - PIN 4; Grove UART , SW202-1, UART - RX; Grove Digital4 , SW209-2, IO17 WRST SW403-2 16 Audio , SW306-1, SD_MODE; mikroBus , SW404-3, RX; Unit-Bus , SW201-1, CN212 - PIN 3; Grove UART , SW202-2, UART - TX OE SW403-3 GND - WR/WEN SW403-4 0 - RCK/RCKL SW402-1 4 Gyro , SW310-4, SCL/SCLK; OLED , SW309-1, SCL; SD Card , SW406-3, DAT1; Unit-Bus , SW200-1, CN212 - PIN 6; Grove I2C , SW203-2, I2C - SCL D0 SW402-2 13 mikroBus , SW405-5, RST; SD Card , SW406-1, CD/DAT3; Grove Digital2 , SW207-2, IO13 D1 SW402-3 12 RFID , SW303-2, IRQ; Gyro , SW310-2, AD0/SD0; mirkoBus , SW404-1, PWM; SD Card , SW406-2, DAT2; Grove Digital1 , SW206-1, IO12 D2 SW402-3 14 Gyro , SW310-1, INT; mikroBus , SW404-2, INT; SD Card , SW406-5, CLK; Grove Digital2 , SW207-1, IO14 D3 SW402-5 27 Menu , SW401-4, CENTER; SD Card , SW407-2, CDET D4 SW402-6 26 Audio , SW306-2, BCKL; Menu , SW401-3, LEFT D5 SW400-1 25 Audio , SW306-3, LRCLK; Menu , SW401-2, DOWN D6 SW400-2 35 Temperature , SW315, DQ; Grove Analog2 , SW205-2, ADC7 D7 SW400-3 34 Menu , SW401-6, UP; Grove Analog2 , SW205-1, ADC6 VSYNC SW400-4 32 Menu , SW401-5, RIGHT; SD Card , SW407-1, LED SIOD/SDA SW400-5 21 mikroBus , SW404-6, SDA; Grove Digital3 , SW208-1, IO21 SIOC/SCL SW400-6 22 RFID , SW303-1, RST; Audio , SW306-4, IO22; mikroBus , SW404-5, SCL Using the component \u00b6 Sample project \u00b6 There is one example project for the Arduino IDE which can be downloaded: Camera_Webserver.ino ( download here )","title":"Camera"},{"location":"development-boards/esp32/camera/#overview","text":"The component camera allows the connection of a camera chip of type OV7670. OV7670 is a camera module with FiFo supporting 640x480 VGA. The PIN description is listed at the backside of the board. Example There is one example project for the Arduino IDE which can be downloaded: Camera_Webserver.ino ( download here ) ESP Board camera connector SW400,SW402,SW403","title":"Overview"},{"location":"development-boards/esp32/camera/#activating-the-component","text":"The component has three dip switches for controlling the component: SW400 , SW402 and SW403 . Function SWITCH IO port Conflicts with Remarks RRST SW403-1 17 Microphone , SW301-2, SCK; mikroBus , SW404-4, TX; Unit-Bus , SW201-2, CN212 - PIN 4; Grove UART , SW202-1, UART - RX; Grove Digital4 , SW209-2, IO17 WRST SW403-2 16 Audio , SW306-1, SD_MODE; mikroBus , SW404-3, RX; Unit-Bus , SW201-1, CN212 - PIN 3; Grove UART , SW202-2, UART - TX OE SW403-3 GND - WR/WEN SW403-4 0 - RCK/RCKL SW402-1 4 Gyro , SW310-4, SCL/SCLK; OLED , SW309-1, SCL; SD Card , SW406-3, DAT1; Unit-Bus , SW200-1, CN212 - PIN 6; Grove I2C , SW203-2, I2C - SCL D0 SW402-2 13 mikroBus , SW405-5, RST; SD Card , SW406-1, CD/DAT3; Grove Digital2 , SW207-2, IO13 D1 SW402-3 12 RFID , SW303-2, IRQ; Gyro , SW310-2, AD0/SD0; mirkoBus , SW404-1, PWM; SD Card , SW406-2, DAT2; Grove Digital1 , SW206-1, IO12 D2 SW402-3 14 Gyro , SW310-1, INT; mikroBus , SW404-2, INT; SD Card , SW406-5, CLK; Grove Digital2 , SW207-1, IO14 D3 SW402-5 27 Menu , SW401-4, CENTER; SD Card , SW407-2, CDET D4 SW402-6 26 Audio , SW306-2, BCKL; Menu , SW401-3, LEFT D5 SW400-1 25 Audio , SW306-3, LRCLK; Menu , SW401-2, DOWN D6 SW400-2 35 Temperature , SW315, DQ; Grove Analog2 , SW205-2, ADC7 D7 SW400-3 34 Menu , SW401-6, UP; Grove Analog2 , SW205-1, ADC6 VSYNC SW400-4 32 Menu , SW401-5, RIGHT; SD Card , SW407-1, LED SIOD/SDA SW400-5 21 mikroBus , SW404-6, SDA; Grove Digital3 , SW208-1, IO21 SIOC/SCL SW400-6 22 RFID , SW303-1, RST; Audio , SW306-4, IO22; mikroBus , SW404-5, SCL","title":"Activating the component"},{"location":"development-boards/esp32/camera/#using-the-component","text":"","title":"Using the component"},{"location":"development-boards/esp32/camera/#sample-project","text":"There is one example project for the Arduino IDE which can be downloaded: Camera_Webserver.ino ( download here )","title":"Sample project"},{"location":"development-boards/esp32/errata_sheet/","text":"Errata sheet \u00b6 All known errors are listed below. ESP32 Version 1.3 \u00b6 Modul Description Micro bus The label at the connector says IO3 but it is connected to IO16. The label at the connector says IO1 but it is connected to IO17. IO3/RX \u2192 RX/IO16 IO1/TX \u2192 TX/IO17 GROVE VP and VN are reversed SW204 POTENTIOMETER VP and VN are reversed SW300, SW302 IO VP and VN are reversed CN210 TFT The labeling TFT is missing The labeling of the switch SW314 is not completely correct. Left side and back side: IO34/T_DO \u2192 IO19/T_DO IO19/MISO \u2192 NC/MISO UNIT Bus The labeling of the switches are missing because there is not enough space. Left switch: SW201 Right side: SW200 ESP32 Version 1.4 \u00b6 Info This version is not available yet.","title":"Errata sheet"},{"location":"development-boards/esp32/errata_sheet/#errata-sheet","text":"All known errors are listed below.","title":"Errata sheet"},{"location":"development-boards/esp32/errata_sheet/#esp32-version-13","text":"Modul Description Micro bus The label at the connector says IO3 but it is connected to IO16. The label at the connector says IO1 but it is connected to IO17. IO3/RX \u2192 RX/IO16 IO1/TX \u2192 TX/IO17 GROVE VP and VN are reversed SW204 POTENTIOMETER VP and VN are reversed SW300, SW302 IO VP and VN are reversed CN210 TFT The labeling TFT is missing The labeling of the switch SW314 is not completely correct. Left side and back side: IO34/T_DO \u2192 IO19/T_DO IO19/MISO \u2192 NC/MISO UNIT Bus The labeling of the switches are missing because there is not enough space. Left switch: SW201 Right side: SW200","title":"ESP32 Version 1.3"},{"location":"development-boards/esp32/errata_sheet/#esp32-version-14","text":"Info This version is not available yet.","title":"ESP32 Version 1.4"},{"location":"development-boards/esp32/esp32_module/","text":"Overview \u00b6 The component ESP32 MODULE contains the ESP32 microchip which will be programmed. The component has two placeholders that are used for the ESP32-WROOM-32 or ESP32-WROVER . Caution You could only use one ESP32 module at one time. It's not possible to place both modules on the same time on the EBB board. Example You find examples for each component in the component pages. ESP Board ESP-WROOM-32 SW210 Activating the component \u00b6 Active all four switches of SW210 . Using the component \u00b6 It's necessary that all switches of SW210 are on and the switch at component POWER SUPPLY is on. This is necessary in order to establish the communication between the onboard USB programmer (component USB PROGRAMMING ) and the esp32 module. Sample project \u00b6 Examples of each component can be found on the component pages. Datasheet \u00b6 Module Datasheet from Expressif Systems ESP32-WROOM-32 esp32-wroom-32_datasheet_en.pdf ESP32-WROVER esp32-wrover_datasheet_en.pdf","title":"ESP32 module"},{"location":"development-boards/esp32/esp32_module/#overview","text":"The component ESP32 MODULE contains the ESP32 microchip which will be programmed. The component has two placeholders that are used for the ESP32-WROOM-32 or ESP32-WROVER . Caution You could only use one ESP32 module at one time. It's not possible to place both modules on the same time on the EBB board. Example You find examples for each component in the component pages. ESP Board ESP-WROOM-32 SW210","title":"Overview"},{"location":"development-boards/esp32/esp32_module/#activating-the-component","text":"Active all four switches of SW210 .","title":"Activating the component"},{"location":"development-boards/esp32/esp32_module/#using-the-component","text":"It's necessary that all switches of SW210 are on and the switch at component POWER SUPPLY is on. This is necessary in order to establish the communication between the onboard USB programmer (component USB PROGRAMMING ) and the esp32 module.","title":"Using the component"},{"location":"development-boards/esp32/esp32_module/#sample-project","text":"Examples of each component can be found on the component pages.","title":"Sample project"},{"location":"development-boards/esp32/esp32_module/#datasheet","text":"Module Datasheet from Expressif Systems ESP32-WROOM-32 esp32-wroom-32_datasheet_en.pdf ESP32-WROVER esp32-wrover_datasheet_en.pdf","title":"Datasheet"},{"location":"development-boards/esp32/gpio/","text":"Overview \u00b6 The component IO offers direct access to the GPIO ports of the ESP32 module. ESP Board IO Terminal CN208,CN209,CN210,CN211 Using the component \u00b6 There is no special source code needed for this component.","title":"GPIO"},{"location":"development-boards/esp32/gpio/#overview","text":"The component IO offers direct access to the GPIO ports of the ESP32 module. ESP Board IO Terminal CN208,CN209,CN210,CN211","title":"Overview"},{"location":"development-boards/esp32/gpio/#using-the-component","text":"There is no special source code needed for this component.","title":"Using the component"},{"location":"development-boards/esp32/grove/","text":"Overview \u00b6 The component GROVE provides eight connectors for the Grove System from Seeed Studio. These connectors are four digital connectors (named from DIGITAL1 to DIGITAL4 ), two analog connectors (named from ANALOG1 to ANALOG2 ), I2C and UART. Example An example project for the Arduino IDE can be downloaded: SEEED_Grove-GSR_Sensor.ino ( download here ) ESP Board grove connector CN200 up to CN207 Activating the component \u00b6 Each of the eight connectors has a own switch which have to be activated in order to use the component. ANALOG1 \u00b6 The switch for Analog1 is SW204 . Function SWITCH IO port Conflicts with Remarks VN 1 39 Potentiometer , SW302, VN VP 2 36 Potentiometer , SW300, VP ANALOG2 \u00b6 The switch for Analog2 is SW205 . Function SWITCH IO port Conflicts with Remarks ADC6 1 34 MENU , SW401-6, UP; Camera , SW400-3, D7 ADC7 2 35 Temperature , SW315, DQ; Camera , SW400-2, D6 DIGITAL1 \u00b6 The switch for Digital1 is SW206 . Function SWITCH IO port Conflicts with Remarks IO12 1 12 RFID , SW303-2, IRQ; Gyro , SW310-2, AD0/SD0; mikroBus , SW404-1, PWM; Camera , SW402-3, D1; SD Card , SW406-2, DAT2 IO5 2 5 Microphone , SW301-1, SD; RFID , SW303-6, SDA; TFT , SW311-2, RESET DIGITAL2 \u00b6 The switch for Digital2 is SW207 . Function SWITCH IO port Conflicts with Remarks IO14 1 14 Gyro , SW310-1, INT; mikroBus , SW404-2, INT; Camera , SW402-4, D2; SD Card , SW406-5, CLK IO13 2 13 mikroBus , SW405-5, RST; Camera , SW402-2, D0; SD Card , SW406-1, CD/DAT3 DIGITAL3 \u00b6 The switch for Digital3 is SW208 . Function SWITCH IO port Conflicts with Remarks IO21 1 21 Menu , SW404-6, SDA; Camera , SW400-5, SIOD /SCL IO15 2 15 TFT , SW311-3, D/C; SD Card , SW406-6, CMD DIGITAL4 \u00b6 The switch for Digital4 is SW209 . Function SWITCH IO port Conflicts with Remarks IO18 1 18 Microphone , SW301-3, WS; RFID , SW303-5, SCL; TFT , SW311-5, SCK; TFT , SW314-2, T_CLK; mikroBus , SW405-3, SCK IO17 2 17 Microphone , SW301-2, SCK; mikroBus , SW404-4, TX; Camera , SW403-1, RRST; Unit-Bus , SW202-1, CN212 - PIN 4; Grove UART , SW202-1, UART - RX I2C \u00b6 The switch for I2C is SW203 . Function SWITCH IO port Conflicts with Remarks I2C - SDA 1 19 RFID , SW303-3, MISO; Gyro , SW310-3, SDA/SDI; OLED , SW309-2, SDA; TFT , SW314-1, MISO; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN 5 I2C - SCL 2 4 Gyro , SW310-4, SCL/SCLK; OLED , SW309-1, SCL; Camera , SW402-1, RCK/RCKL; SD Card , SW406-3, DAT1; Unit-Bus , SW200-1, CN212 - Pin 6 UART \u00b6 The switch for UART is SW202 . Function SWITCH IO port Conflicts with Remarks UART - RX 1 17 Microphone , SW301-2, SCK; mikroBus , SW404-4, TX; Camera , SW403-1, RRST; Unit-Bus , SW202-1, CN212 - PIN 4; Grove DIGITAL2 , SW209-2, IO17 UART - TX 2 16 Audio , SW306-1, SD_MODE; mirkoBus , SW404-3, RX; Camera , SW403-2, WRST; Unit-Bus , SW201-1, CN212 - PIN 3 Using the component \u00b6 Sample project \u00b6 An example project for the Arduino IDE can be downloaded: SEEED_Grove-GSR_Sensor.ino ( download here )","title":"Grove"},{"location":"development-boards/esp32/grove/#overview","text":"The component GROVE provides eight connectors for the Grove System from Seeed Studio. These connectors are four digital connectors (named from DIGITAL1 to DIGITAL4 ), two analog connectors (named from ANALOG1 to ANALOG2 ), I2C and UART. Example An example project for the Arduino IDE can be downloaded: SEEED_Grove-GSR_Sensor.ino ( download here ) ESP Board grove connector CN200 up to CN207","title":"Overview"},{"location":"development-boards/esp32/grove/#activating-the-component","text":"Each of the eight connectors has a own switch which have to be activated in order to use the component.","title":"Activating the component"},{"location":"development-boards/esp32/grove/#analog1","text":"The switch for Analog1 is SW204 . Function SWITCH IO port Conflicts with Remarks VN 1 39 Potentiometer , SW302, VN VP 2 36 Potentiometer , SW300, VP","title":"ANALOG1"},{"location":"development-boards/esp32/grove/#analog2","text":"The switch for Analog2 is SW205 . Function SWITCH IO port Conflicts with Remarks ADC6 1 34 MENU , SW401-6, UP; Camera , SW400-3, D7 ADC7 2 35 Temperature , SW315, DQ; Camera , SW400-2, D6","title":"ANALOG2"},{"location":"development-boards/esp32/grove/#digital1","text":"The switch for Digital1 is SW206 . Function SWITCH IO port Conflicts with Remarks IO12 1 12 RFID , SW303-2, IRQ; Gyro , SW310-2, AD0/SD0; mikroBus , SW404-1, PWM; Camera , SW402-3, D1; SD Card , SW406-2, DAT2 IO5 2 5 Microphone , SW301-1, SD; RFID , SW303-6, SDA; TFT , SW311-2, RESET","title":"DIGITAL1"},{"location":"development-boards/esp32/grove/#digital2","text":"The switch for Digital2 is SW207 . Function SWITCH IO port Conflicts with Remarks IO14 1 14 Gyro , SW310-1, INT; mikroBus , SW404-2, INT; Camera , SW402-4, D2; SD Card , SW406-5, CLK IO13 2 13 mikroBus , SW405-5, RST; Camera , SW402-2, D0; SD Card , SW406-1, CD/DAT3","title":"DIGITAL2"},{"location":"development-boards/esp32/grove/#digital3","text":"The switch for Digital3 is SW208 . Function SWITCH IO port Conflicts with Remarks IO21 1 21 Menu , SW404-6, SDA; Camera , SW400-5, SIOD /SCL IO15 2 15 TFT , SW311-3, D/C; SD Card , SW406-6, CMD","title":"DIGITAL3"},{"location":"development-boards/esp32/grove/#digital4","text":"The switch for Digital4 is SW209 . Function SWITCH IO port Conflicts with Remarks IO18 1 18 Microphone , SW301-3, WS; RFID , SW303-5, SCL; TFT , SW311-5, SCK; TFT , SW314-2, T_CLK; mikroBus , SW405-3, SCK IO17 2 17 Microphone , SW301-2, SCK; mikroBus , SW404-4, TX; Camera , SW403-1, RRST; Unit-Bus , SW202-1, CN212 - PIN 4; Grove UART , SW202-1, UART - RX","title":"DIGITAL4"},{"location":"development-boards/esp32/grove/#i2c","text":"The switch for I2C is SW203 . Function SWITCH IO port Conflicts with Remarks I2C - SDA 1 19 RFID , SW303-3, MISO; Gyro , SW310-3, SDA/SDI; OLED , SW309-2, SDA; TFT , SW314-1, MISO; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN 5 I2C - SCL 2 4 Gyro , SW310-4, SCL/SCLK; OLED , SW309-1, SCL; Camera , SW402-1, RCK/RCKL; SD Card , SW406-3, DAT1; Unit-Bus , SW200-1, CN212 - Pin 6","title":"I2C"},{"location":"development-boards/esp32/grove/#uart","text":"The switch for UART is SW202 . Function SWITCH IO port Conflicts with Remarks UART - RX 1 17 Microphone , SW301-2, SCK; mikroBus , SW404-4, TX; Camera , SW403-1, RRST; Unit-Bus , SW202-1, CN212 - PIN 4; Grove DIGITAL2 , SW209-2, IO17 UART - TX 2 16 Audio , SW306-1, SD_MODE; mirkoBus , SW404-3, RX; Camera , SW403-2, WRST; Unit-Bus , SW201-1, CN212 - PIN 3","title":"UART"},{"location":"development-boards/esp32/grove/#using-the-component","text":"","title":"Using the component"},{"location":"development-boards/esp32/grove/#sample-project","text":"An example project for the Arduino IDE can be downloaded: SEEED_Grove-GSR_Sensor.ino ( download here )","title":"Sample project"},{"location":"development-boards/esp32/gyro/","text":"Overview \u00b6 The component Gyro Accelerometer Compass provides a 9-axis Motion Processing Unit in form of a MPU9250. The component is controlled via I2C protocol. Example There are two example projects for the Arduino IDE which can be downloaded: MPU9250.ino ( download here ) and MPU-LED.ino ( download here ) ESP Board Gyro SW310 Activating the component \u00b6 The component has a dip switch SW310 for activating the component. Function SWITCH IO port Conflicts with Remarks INT 1 14 mikroBus , SW404-2, INT; Camera , SW402-4, D2; SD Card , SW406-5, CLK; Grove Digital2 , SW207-1, IO14 AD0/SD0 2 12 RFID , SW303-2, IRQ; mikroBus , SW404-1, PWM; Camera , SW402-3, D1; SD Card , SW406-2, DAT2; Grove Digital1 , SW206-1, IO12 SDA/SDI 3 19 RFID , SW303-3, MISO; OLED , SW309-2, SDA; TFT , SW314-1, MISO; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN5; Grove I2C , SW203-1, I2C-SDA I2C Pull-up by SW307 SCL/SCLK 4 4 OLED , SW309-1, SCL; Camera , SW402-1, RCK/RCKL; SD Card , SW406-3, DAT1; Unit-Bus , SW200-1, CN212 - PIN 6; Grove I2C , SW203-2, I2C - SCL I2C Pull-up by SW308 Using the component \u00b6 Switch on I2C PULL-UP at SW307 and SW308. First you should define two constants for the two I2C signal lines: SDA (serial data) and SCL (serial clock): 1 2 #define SDA 19 #define SCL 4 Additionally constants for the addresses of the IMU component are recommended: 1 2 3 4 5 6 7 8 9 10 11 12 #define MPU9250_ADDRESS 0x68 #define MAG_ADDRESS 0x0C #define GYRO_FULL_SCALE_250_DPS 0x00 #define GYRO_FULL_SCALE_500_DPS 0x08 #define GYRO_FULL_SCALE_1000_DPS 0x10 #define GYRO_FULL_SCALE_2000_DPS 0x18 #define ACC_FULL_SCALE_2_G 0x00 #define ACC_FULL_SCALE_4_G 0x08 #define ACC_FULL_SCALE_8_G 0x10 #define ACC_FULL_SCALE_16_G 0x18 With two utility functions (defined in the sample project Gyro.ino ) data is read and write from the I2C bus. With these functions the component is configured in the setup method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void setup () { // Arduino initializations Wire . begin ( SDA , SCL ); Serial . begin ( 115200 ); // Set accelerometers low pass filter at 5Hz I2CwriteByte ( MPU9250_ADDRESS , 29 , 0x06 ); // Set gyroscope low pass filter at 5Hz I2CwriteByte ( MPU9250_ADDRESS , 26 , 0x06 ); // Configure gyroscope range I2CwriteByte ( MPU9250_ADDRESS , 27 , GYRO_FULL_SCALE_1000_DPS ); // Configure accelerometers range I2CwriteByte ( MPU9250_ADDRESS , 28 , ACC_FULL_SCALE_4_G ); // Set by pass mode for the magnetometers I2CwriteByte ( MPU9250_ADDRESS , 0x37 , 0x02 ); // Request continuous magnetometer measurements in 16 bits I2CwriteByte ( MAG_ADDRESS , 0x0A , 0x16 ); // Store initial time ti = millis (); Serial . println ( \"MPU9250\" ); } In the loop method you could access the three IMU components. Accelerometer 1 2 3 int16_t ax = - ( Buf [ 0 ] << 8 | Buf [ 1 ]); int16_t ay = - ( Buf [ 2 ] << 8 | Buf [ 3 ]); int16_t az = Buf [ 4 ] << 8 | Buf [ 5 ]; Gyroscope 1 2 3 int16_t gx = - ( Buf [ 8 ] << 8 | Buf [ 9 ]); int16_t gy = - ( Buf [ 10 ] << 8 | Buf [ 11 ]); int16_t gz = Buf [ 12 ] << 8 | Buf [ 13 ]; Magnetometer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 uint8_t ST1 ; do { I2Cread ( MAG_ADDRESS , 0x02 , 1 , & ST1 ); } while ( ! ( ST1 & 0x01 )); // Read magnetometer data uint8_t Mag [ 7 ]; I2Cread ( MAG_ADDRESS , 0x03 , 7 , Mag ); // Create 16 bits values from 8 bits data // Magnetometer int16_t mx = - ( Mag [ 3 ] << 8 | Mag [ 2 ]); int16_t my = - ( Mag [ 1 ] << 8 | Mag [ 0 ]); int16_t mz = - ( Mag [ 5 ] << 8 | Mag [ 4 ]); Sample project \u00b6 There are two example projects for the Arduino IDE which can be downloaded: MPU9250.ino ( download here ) and MPU-LED.ino ( download here ).","title":"Gyro (IMU)"},{"location":"development-boards/esp32/gyro/#overview","text":"The component Gyro Accelerometer Compass provides a 9-axis Motion Processing Unit in form of a MPU9250. The component is controlled via I2C protocol. Example There are two example projects for the Arduino IDE which can be downloaded: MPU9250.ino ( download here ) and MPU-LED.ino ( download here ) ESP Board Gyro SW310","title":"Overview"},{"location":"development-boards/esp32/gyro/#activating-the-component","text":"The component has a dip switch SW310 for activating the component. Function SWITCH IO port Conflicts with Remarks INT 1 14 mikroBus , SW404-2, INT; Camera , SW402-4, D2; SD Card , SW406-5, CLK; Grove Digital2 , SW207-1, IO14 AD0/SD0 2 12 RFID , SW303-2, IRQ; mikroBus , SW404-1, PWM; Camera , SW402-3, D1; SD Card , SW406-2, DAT2; Grove Digital1 , SW206-1, IO12 SDA/SDI 3 19 RFID , SW303-3, MISO; OLED , SW309-2, SDA; TFT , SW314-1, MISO; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN5; Grove I2C , SW203-1, I2C-SDA I2C Pull-up by SW307 SCL/SCLK 4 4 OLED , SW309-1, SCL; Camera , SW402-1, RCK/RCKL; SD Card , SW406-3, DAT1; Unit-Bus , SW200-1, CN212 - PIN 6; Grove I2C , SW203-2, I2C - SCL I2C Pull-up by SW308","title":"Activating the component"},{"location":"development-boards/esp32/gyro/#using-the-component","text":"Switch on I2C PULL-UP at SW307 and SW308. First you should define two constants for the two I2C signal lines: SDA (serial data) and SCL (serial clock): 1 2 #define SDA 19 #define SCL 4 Additionally constants for the addresses of the IMU component are recommended: 1 2 3 4 5 6 7 8 9 10 11 12 #define MPU9250_ADDRESS 0x68 #define MAG_ADDRESS 0x0C #define GYRO_FULL_SCALE_250_DPS 0x00 #define GYRO_FULL_SCALE_500_DPS 0x08 #define GYRO_FULL_SCALE_1000_DPS 0x10 #define GYRO_FULL_SCALE_2000_DPS 0x18 #define ACC_FULL_SCALE_2_G 0x00 #define ACC_FULL_SCALE_4_G 0x08 #define ACC_FULL_SCALE_8_G 0x10 #define ACC_FULL_SCALE_16_G 0x18 With two utility functions (defined in the sample project Gyro.ino ) data is read and write from the I2C bus. With these functions the component is configured in the setup method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void setup () { // Arduino initializations Wire . begin ( SDA , SCL ); Serial . begin ( 115200 ); // Set accelerometers low pass filter at 5Hz I2CwriteByte ( MPU9250_ADDRESS , 29 , 0x06 ); // Set gyroscope low pass filter at 5Hz I2CwriteByte ( MPU9250_ADDRESS , 26 , 0x06 ); // Configure gyroscope range I2CwriteByte ( MPU9250_ADDRESS , 27 , GYRO_FULL_SCALE_1000_DPS ); // Configure accelerometers range I2CwriteByte ( MPU9250_ADDRESS , 28 , ACC_FULL_SCALE_4_G ); // Set by pass mode for the magnetometers I2CwriteByte ( MPU9250_ADDRESS , 0x37 , 0x02 ); // Request continuous magnetometer measurements in 16 bits I2CwriteByte ( MAG_ADDRESS , 0x0A , 0x16 ); // Store initial time ti = millis (); Serial . println ( \"MPU9250\" ); } In the loop method you could access the three IMU components. Accelerometer 1 2 3 int16_t ax = - ( Buf [ 0 ] << 8 | Buf [ 1 ]); int16_t ay = - ( Buf [ 2 ] << 8 | Buf [ 3 ]); int16_t az = Buf [ 4 ] << 8 | Buf [ 5 ]; Gyroscope 1 2 3 int16_t gx = - ( Buf [ 8 ] << 8 | Buf [ 9 ]); int16_t gy = - ( Buf [ 10 ] << 8 | Buf [ 11 ]); int16_t gz = Buf [ 12 ] << 8 | Buf [ 13 ]; Magnetometer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 uint8_t ST1 ; do { I2Cread ( MAG_ADDRESS , 0x02 , 1 , & ST1 ); } while ( ! ( ST1 & 0x01 )); // Read magnetometer data uint8_t Mag [ 7 ]; I2Cread ( MAG_ADDRESS , 0x03 , 7 , Mag ); // Create 16 bits values from 8 bits data // Magnetometer int16_t mx = - ( Mag [ 3 ] << 8 | Mag [ 2 ]); int16_t my = - ( Mag [ 1 ] << 8 | Mag [ 0 ]); int16_t mz = - ( Mag [ 5 ] << 8 | Mag [ 4 ]);","title":"Using the component"},{"location":"development-boards/esp32/gyro/#sample-project","text":"There are two example projects for the Arduino IDE which can be downloaded: MPU9250.ino ( download here ) and MPU-LED.ino ( download here ).","title":"Sample project"},{"location":"development-boards/esp32/i2c_pull_up/","text":"Overview \u00b6 The component I2C Pull-up provides two 1k resistors for the usage as pull-up for the I2C bus. The resistors are independent. Example An example project for the Arduino IDE can be downloaded: I2C-Scanner.ino ( download here ). ESP Board I2C pull-up SW307 and SW308 Activating the component \u00b6 The left resistor can be connected to SDA with SW307 and the right resistor to SCL with SW308 . The resistor on SW307 is connected to io port 19 and the resistor on SW308 is connected to io port 4 SDA SCL SW307 SW308 IO19 IO4 Using the component \u00b6 There is no special source code needed for this component. If you need an pull-up in your project you have to activate the appropriate pull-up. Sample project \u00b6 An example project for the Arduino IDE can be downloaded: I2C-Scanner.ino ( download here )","title":"I2C Pull-up"},{"location":"development-boards/esp32/i2c_pull_up/#overview","text":"The component I2C Pull-up provides two 1k resistors for the usage as pull-up for the I2C bus. The resistors are independent. Example An example project for the Arduino IDE can be downloaded: I2C-Scanner.ino ( download here ). ESP Board I2C pull-up SW307 and SW308","title":"Overview"},{"location":"development-boards/esp32/i2c_pull_up/#activating-the-component","text":"The left resistor can be connected to SDA with SW307 and the right resistor to SCL with SW308 . The resistor on SW307 is connected to io port 19 and the resistor on SW308 is connected to io port 4 SDA SCL SW307 SW308 IO19 IO4","title":"Activating the component"},{"location":"development-boards/esp32/i2c_pull_up/#using-the-component","text":"There is no special source code needed for this component. If you need an pull-up in your project you have to activate the appropriate pull-up.","title":"Using the component"},{"location":"development-boards/esp32/i2c_pull_up/#sample-project","text":"An example project for the Arduino IDE can be downloaded: I2C-Scanner.ino ( download here )","title":"Sample project"},{"location":"development-boards/esp32/install/","text":"Installation of the IDE \u00b6 Your EBB evaluation board has an ESP32 from Espressif . There are various toolchains for programming an ESP32. Note We recommend the Arduino IDE . The source code in this documentation is tested for the Arduino IDE. Download the latest version of Arduino IDE from the download section of the Arduino webpage. If you already have installed a version of the Arduino IDE, it should be at least the version 1.8. We recommend to use a stable version and not the HOURLY BUILDS or BETA BUILDS . After a successful download, execute the downloaded installer and start the Arduino IDE. It will present an pre-generated sketch: Arduino IDE start of IDE sketch shown after installation In order to program the ESP32 it's necessary to install the appropriate addon. This is described in chapter Programming the board","title":"Installing the IDE"},{"location":"development-boards/esp32/install/#installation-of-the-ide","text":"Your EBB evaluation board has an ESP32 from Espressif . There are various toolchains for programming an ESP32. Note We recommend the Arduino IDE . The source code in this documentation is tested for the Arduino IDE. Download the latest version of Arduino IDE from the download section of the Arduino webpage. If you already have installed a version of the Arduino IDE, it should be at least the version 1.8. We recommend to use a stable version and not the HOURLY BUILDS or BETA BUILDS . After a successful download, execute the downloaded installer and start the Arduino IDE. It will present an pre-generated sketch: Arduino IDE start of IDE sketch shown after installation In order to program the ESP32 it's necessary to install the appropriate addon. This is described in chapter Programming the board","title":"Installation of the IDE"},{"location":"development-boards/esp32/lcd/","text":"Overview \u00b6 The component LCD supports monochrome OLED displays with a resolution of 128*64 pixel driven by a SSD1306 driver. The display is not soldered to the board, but there is a four pin connector for an OLED display. The right image shows the component with connected display. Example There are four example projects for the Arduino IDE which could be downloaded: OLED_1.ino ( download here ) for demonstration Temp-OLED.ino ( download here ) how to show a logo and the temperature Flappy Bird ( download here ) the game and Pong ( download here ) also a game. connector OLED Activating the component \u00b6 The component has a dip switch SW309 , which has to be activated in order to use the component. The component is connected to the following ports: Function SWITCH IO port Conflicts with Remarks SCL 1 4 Gyro , SW310-4, SCL/SCLK; Camera , SW402-1, RCK/RCKL; SD Card , SW200-1, CN212 - PIN 6; Grove I2C , SW203-2, I2C - SCL I2C Pull-up by SW308 SDA 2 19 RFID , SW310-3, MISO; Gyro , SW310-3, SDA/SDI; TFT , SW314-1, MSIO; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN 5; Grove I2C , SW203-1, I2C- SDA I2C Pull-up by SW307 Using the component \u00b6 Info Required libraries In order to use the component you need two libraries: Adafruit SSD1306 and Adafruit GFX library. The latest version of the Adafruit SSD1306 library could be downloaded from the GitHub repository . Additionally you could download a tested version. After the download it's necessary to add both libraries to your Arduino IDE. Open Sketch > Include Library > Add .ZIP Library ... and select the downloaded archive. Do it for both libraries. After a successful installation the menu Sketch > Include Library should contain an entry Adafruit GFX library and Adafruit SSD 1306 * in the category Recommended libraries . Import the necessary libraries \u00b6 Caution It's important that you use the \" -sign for including the Adafruit_SSD1306 library. With the quotation marks the enviroment searches first in the local directory for this library. Here it's important that you put a patched version of this library in your working directory of the sketch. You need Adafruit_SSD1306.h and Adafruit_SSD1306.cpp . 1 #include \"Adafruit_SSD1306.h\" You need both libraries (Adafruit_SSD1306, Adafruit GFX) for using this sample codes. In case of compilation error you should check whether you have added both libraries to your Arduino development environment. The Adafruit GFX library is used from Adafruit_SSD1306 . Setup the display \u00b6 The first step is to create an instance of the class Adafruit_SSD1306 in order to work with the display. 1 2 #define OLED_RESET 4 Adafruit_SSD1306 display ( OLED_RESET ); Open the display on the I2C addr 0x3D (for the 128x64). 1 2 3 4 void setup () { Serial . begin ( 9600 ); display . begin ( SSD1306_SWITCHCAPVCC , 0x3C ); } Note The line Serial.begin(9600) is only for debugging purposes. You could remove this line if you don't need outputs in the Serial console. Draw a Pixel \u00b6 1 2 display . clearDisplay (); display . drawPixel ( 10 , 10 , WHITE ); Draw many lines \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 void testdrawline () { for ( int16_t i = 0 ; i < display . width (); i += 4 ) { display . drawLine ( 0 , 0 , i , display . height () - 1 , WHITE ); display . display (); delay ( 1 ); } for ( int16_t i = 0 ; i < display . height (); i += 4 ) { display . drawLine ( 0 , 0 , display . width () - 1 , i , WHITE ); display . display (); delay ( 1 ); } delay ( 250 ); display . clearDisplay (); for ( int16_t i = 0 ; i < display . width (); i += 4 ) { display . drawLine ( 0 , display . height () - 1 , i , 0 , WHITE ); display . display (); delay ( 1 ); } for ( int16_t i = display . height () - 1 ; i >= 0 ; i -= 4 ) { display . drawLine ( 0 , display . height () - 1 , display . width () - 1 , i , WHITE ); display . display (); delay ( 1 ); } delay ( 250 ); display . clearDisplay (); for ( int16_t i = display . width () - 1 ; i >= 0 ; i -= 4 ) { display . drawLine ( display . width () - 1 , display . height () - 1 , i , 0 , WHITE ); display . display (); delay ( 1 ); } for ( int16_t i = display . height () - 1 ; i >= 0 ; i -= 4 ) { display . drawLine ( display . width () - 1 , display . height () - 1 , 0 , i , WHITE ); display . display (); delay ( 1 ); } delay ( 250 ); display . clearDisplay (); for ( int16_t i = 0 ; i < display . height (); i += 4 ) { display . drawLine ( display . width () - 1 , 0 , 0 , i , WHITE ); display . display (); delay ( 1 ); } for ( int16_t i = 0 ; i < display . width (); i += 4 ) { display . drawLine ( display . width () - 1 , 0 , i , display . height () - 1 , WHITE ); display . display (); delay ( 1 ); } delay ( 250 ); } Scroll text \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void testscrolltext ( void ) { display . setTextSize ( 2 ); display . setTextColor ( WHITE ); display . setCursor ( 10 , 0 ); display . clearDisplay (); display . println ( \"scroll\" ); display . display (); delay ( 1 ); display . startscrollright ( 0x00 , 0x0F ); delay ( 2000 ); display . stopscroll (); delay ( 1000 ); display . startscrollleft ( 0x00 , 0x0F ); delay ( 2000 ); display . stopscroll (); delay ( 1000 ); display . startscrolldiagright ( 0x00 , 0x07 ); delay ( 2000 ); display . startscrolldiagleft ( 0x00 , 0x07 ); delay ( 2000 ); display . stopscroll (); } Text display tests \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 display . setTextSize ( 1 ); display . setTextColor ( WHITE ); display . setCursor ( 0 , 0 ); display . println ( \"Hello, world!\" ); display . setTextColor ( BLACK , WHITE ); // 'inverted' text display . println ( 3.141592 ); display . setTextSize ( 2 ); display . setTextColor ( WHITE ); display . print ( \"0x\" ); display . println ( 0xDEADBEEF , HEX ); display . display (); delay ( 2000 ); display . clearDisplay (); Invert the display \u00b6 1 2 3 4 5 display . invertDisplay ( true ); delay ( 1000 ); display . invertDisplay ( false ); delay ( 1000 ); display . clearDisplay (); Sample project \u00b6 A sample project for the Arduino IDE is provided in OLED_1.ino ( download here ). The following image shows the OLED output of this sample project: OLED_1.ino example showing output Create your own picture \u00b6 Here a short summary how to show your logo at the display. Procedure with GIMP and Notepad++: Open image with GIMP Crop the image to the content Scale image to 128 pixels wide (and LINEAR) Export file as file type xbm (X-BitMap image) Edit \"xbm\" file with Notepad ++ Change variable in third line to: \"static unsigned char\" Save file as \"images.h\" A sample project for the Arduino IDE is provided in Temp-OLED.ino ( download here ). The following image shows the OLED output of this sample project: Temp-OLED.ino example showing logo of MakerFactory Flappy Bird \u00b6 An interesting project for the Arduino IDE is the game Flappy Bird ( download here ). Pong \u00b6 Another interesting project for the Arduino IDE is the game Pong ( download here ).","title":"OLED-LCD"},{"location":"development-boards/esp32/lcd/#overview","text":"The component LCD supports monochrome OLED displays with a resolution of 128*64 pixel driven by a SSD1306 driver. The display is not soldered to the board, but there is a four pin connector for an OLED display. The right image shows the component with connected display. Example There are four example projects for the Arduino IDE which could be downloaded: OLED_1.ino ( download here ) for demonstration Temp-OLED.ino ( download here ) how to show a logo and the temperature Flappy Bird ( download here ) the game and Pong ( download here ) also a game. connector OLED","title":"Overview"},{"location":"development-boards/esp32/lcd/#activating-the-component","text":"The component has a dip switch SW309 , which has to be activated in order to use the component. The component is connected to the following ports: Function SWITCH IO port Conflicts with Remarks SCL 1 4 Gyro , SW310-4, SCL/SCLK; Camera , SW402-1, RCK/RCKL; SD Card , SW200-1, CN212 - PIN 6; Grove I2C , SW203-2, I2C - SCL I2C Pull-up by SW308 SDA 2 19 RFID , SW310-3, MISO; Gyro , SW310-3, SDA/SDI; TFT , SW314-1, MSIO; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN 5; Grove I2C , SW203-1, I2C- SDA I2C Pull-up by SW307","title":"Activating the component"},{"location":"development-boards/esp32/lcd/#using-the-component","text":"Info Required libraries In order to use the component you need two libraries: Adafruit SSD1306 and Adafruit GFX library. The latest version of the Adafruit SSD1306 library could be downloaded from the GitHub repository . Additionally you could download a tested version. After the download it's necessary to add both libraries to your Arduino IDE. Open Sketch > Include Library > Add .ZIP Library ... and select the downloaded archive. Do it for both libraries. After a successful installation the menu Sketch > Include Library should contain an entry Adafruit GFX library and Adafruit SSD 1306 * in the category Recommended libraries .","title":"Using the component"},{"location":"development-boards/esp32/lcd/#import-the-necessary-libraries","text":"Caution It's important that you use the \" -sign for including the Adafruit_SSD1306 library. With the quotation marks the enviroment searches first in the local directory for this library. Here it's important that you put a patched version of this library in your working directory of the sketch. You need Adafruit_SSD1306.h and Adafruit_SSD1306.cpp . 1 #include \"Adafruit_SSD1306.h\" You need both libraries (Adafruit_SSD1306, Adafruit GFX) for using this sample codes. In case of compilation error you should check whether you have added both libraries to your Arduino development environment. The Adafruit GFX library is used from Adafruit_SSD1306 .","title":"Import the necessary libraries"},{"location":"development-boards/esp32/lcd/#setup-the-display","text":"The first step is to create an instance of the class Adafruit_SSD1306 in order to work with the display. 1 2 #define OLED_RESET 4 Adafruit_SSD1306 display ( OLED_RESET ); Open the display on the I2C addr 0x3D (for the 128x64). 1 2 3 4 void setup () { Serial . begin ( 9600 ); display . begin ( SSD1306_SWITCHCAPVCC , 0x3C ); } Note The line Serial.begin(9600) is only for debugging purposes. You could remove this line if you don't need outputs in the Serial console.","title":"Setup the display"},{"location":"development-boards/esp32/lcd/#draw-a-pixel","text":"1 2 display . clearDisplay (); display . drawPixel ( 10 , 10 , WHITE );","title":"Draw a Pixel"},{"location":"development-boards/esp32/lcd/#draw-many-lines","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 void testdrawline () { for ( int16_t i = 0 ; i < display . width (); i += 4 ) { display . drawLine ( 0 , 0 , i , display . height () - 1 , WHITE ); display . display (); delay ( 1 ); } for ( int16_t i = 0 ; i < display . height (); i += 4 ) { display . drawLine ( 0 , 0 , display . width () - 1 , i , WHITE ); display . display (); delay ( 1 ); } delay ( 250 ); display . clearDisplay (); for ( int16_t i = 0 ; i < display . width (); i += 4 ) { display . drawLine ( 0 , display . height () - 1 , i , 0 , WHITE ); display . display (); delay ( 1 ); } for ( int16_t i = display . height () - 1 ; i >= 0 ; i -= 4 ) { display . drawLine ( 0 , display . height () - 1 , display . width () - 1 , i , WHITE ); display . display (); delay ( 1 ); } delay ( 250 ); display . clearDisplay (); for ( int16_t i = display . width () - 1 ; i >= 0 ; i -= 4 ) { display . drawLine ( display . width () - 1 , display . height () - 1 , i , 0 , WHITE ); display . display (); delay ( 1 ); } for ( int16_t i = display . height () - 1 ; i >= 0 ; i -= 4 ) { display . drawLine ( display . width () - 1 , display . height () - 1 , 0 , i , WHITE ); display . display (); delay ( 1 ); } delay ( 250 ); display . clearDisplay (); for ( int16_t i = 0 ; i < display . height (); i += 4 ) { display . drawLine ( display . width () - 1 , 0 , 0 , i , WHITE ); display . display (); delay ( 1 ); } for ( int16_t i = 0 ; i < display . width (); i += 4 ) { display . drawLine ( display . width () - 1 , 0 , i , display . height () - 1 , WHITE ); display . display (); delay ( 1 ); } delay ( 250 ); }","title":"Draw many lines"},{"location":"development-boards/esp32/lcd/#scroll-text","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void testscrolltext ( void ) { display . setTextSize ( 2 ); display . setTextColor ( WHITE ); display . setCursor ( 10 , 0 ); display . clearDisplay (); display . println ( \"scroll\" ); display . display (); delay ( 1 ); display . startscrollright ( 0x00 , 0x0F ); delay ( 2000 ); display . stopscroll (); delay ( 1000 ); display . startscrollleft ( 0x00 , 0x0F ); delay ( 2000 ); display . stopscroll (); delay ( 1000 ); display . startscrolldiagright ( 0x00 , 0x07 ); delay ( 2000 ); display . startscrolldiagleft ( 0x00 , 0x07 ); delay ( 2000 ); display . stopscroll (); }","title":"Scroll text"},{"location":"development-boards/esp32/lcd/#text-display-tests","text":"1 2 3 4 5 6 7 8 9 10 11 12 display . setTextSize ( 1 ); display . setTextColor ( WHITE ); display . setCursor ( 0 , 0 ); display . println ( \"Hello, world!\" ); display . setTextColor ( BLACK , WHITE ); // 'inverted' text display . println ( 3.141592 ); display . setTextSize ( 2 ); display . setTextColor ( WHITE ); display . print ( \"0x\" ); display . println ( 0xDEADBEEF , HEX ); display . display (); delay ( 2000 ); display . clearDisplay ();","title":"Text display tests"},{"location":"development-boards/esp32/lcd/#invert-the-display","text":"1 2 3 4 5 display . invertDisplay ( true ); delay ( 1000 ); display . invertDisplay ( false ); delay ( 1000 ); display . clearDisplay ();","title":"Invert the display"},{"location":"development-boards/esp32/lcd/#sample-project","text":"A sample project for the Arduino IDE is provided in OLED_1.ino ( download here ). The following image shows the OLED output of this sample project: OLED_1.ino example showing output","title":"Sample project"},{"location":"development-boards/esp32/lcd/#create-your-own-picture","text":"Here a short summary how to show your logo at the display. Procedure with GIMP and Notepad++: Open image with GIMP Crop the image to the content Scale image to 128 pixels wide (and LINEAR) Export file as file type xbm (X-BitMap image) Edit \"xbm\" file with Notepad ++ Change variable in third line to: \"static unsigned char\" Save file as \"images.h\" A sample project for the Arduino IDE is provided in Temp-OLED.ino ( download here ). The following image shows the OLED output of this sample project: Temp-OLED.ino example showing logo of MakerFactory","title":"Create your own picture"},{"location":"development-boards/esp32/lcd/#flappy-bird","text":"An interesting project for the Arduino IDE is the game Flappy Bird ( download here ).","title":"Flappy Bird"},{"location":"development-boards/esp32/lcd/#pong","text":"Another interesting project for the Arduino IDE is the game Pong ( download here ).","title":"Pong"},{"location":"development-boards/esp32/menu/","text":"Overview \u00b6 The component MENU has five switches which could be used for control tasks. Example An example project for the Arduino IDE can be downloaded: Button.ino ( download here ) ESP Board menu SW401 Activating the component \u00b6 The component has a dip switch SW401 for activating the buttons. Each of the five buttons is connected to one IO port. Switch 1 is not connected and therefore the state of this switch is not relevant. The buttons are connected to the following ports Function SWITCH IO port Conflicts with Remarks Button UP 6 34 CAMERA , SW400-3, D7; GROVE, UART , SW205-1, ADC6 Button DOWN 2 25 CAMERA , SW400-1, D5; Audio , SW306-3, LRCLK Button LEFT 3 26 CAMERA , SW402-6, D4; Audio , SW306-2, BCKL Button RIGHT 5 32 CAMERA , SW400-4, VSYNC; SD CARD , SW407-1, LED Button CENTER 4 27 CAMERA , SW402-5, D3; SD CARD , SW407-2, CDET Using the component \u00b6 It's very important to switch on the right switches on SW401 . Additonally it's recommend to define constants for the IO ports of the appropriate ports. This could be done as follows: 1 2 3 4 5 #define BTN_UP 34 #define BTN_DOWN 25 #define BTN_LEFT 26 #define BTN_RIGHT 32 #define BTN_CENTER 27 Before you could use the buttons, you have to setup the io ports. 1 2 3 4 5 6 7 8 9 10 void setup () { pinMode ( BTN_UP , INPUT ); pinMode ( BTN_DOWN , INPUT ); pinMode ( BTN_LEFT , INPUT ); pinMode ( BTN_RIGHT , INPUT ); pinMode ( BTN_CENTER , INPUT ); } If you want to see debug messages on the serial monitor you have to add the following line in the setup method: 1 Serial . begin ( 115200 ); Now you could read the state from the Button. If you press the button you get a 0 , otherwise you get a 1 . 1 2 3 4 5 void loop () { Serial . print ( digitalRead ( BTN_UP )); delay ( 250 ); } Sample project \u00b6 An example project for the Arduino IDE can be downloaded: Button.ino ( download here ).","title":"Menu"},{"location":"development-boards/esp32/menu/#overview","text":"The component MENU has five switches which could be used for control tasks. Example An example project for the Arduino IDE can be downloaded: Button.ino ( download here ) ESP Board menu SW401","title":"Overview"},{"location":"development-boards/esp32/menu/#activating-the-component","text":"The component has a dip switch SW401 for activating the buttons. Each of the five buttons is connected to one IO port. Switch 1 is not connected and therefore the state of this switch is not relevant. The buttons are connected to the following ports Function SWITCH IO port Conflicts with Remarks Button UP 6 34 CAMERA , SW400-3, D7; GROVE, UART , SW205-1, ADC6 Button DOWN 2 25 CAMERA , SW400-1, D5; Audio , SW306-3, LRCLK Button LEFT 3 26 CAMERA , SW402-6, D4; Audio , SW306-2, BCKL Button RIGHT 5 32 CAMERA , SW400-4, VSYNC; SD CARD , SW407-1, LED Button CENTER 4 27 CAMERA , SW402-5, D3; SD CARD , SW407-2, CDET","title":"Activating the component"},{"location":"development-boards/esp32/menu/#using-the-component","text":"It's very important to switch on the right switches on SW401 . Additonally it's recommend to define constants for the IO ports of the appropriate ports. This could be done as follows: 1 2 3 4 5 #define BTN_UP 34 #define BTN_DOWN 25 #define BTN_LEFT 26 #define BTN_RIGHT 32 #define BTN_CENTER 27 Before you could use the buttons, you have to setup the io ports. 1 2 3 4 5 6 7 8 9 10 void setup () { pinMode ( BTN_UP , INPUT ); pinMode ( BTN_DOWN , INPUT ); pinMode ( BTN_LEFT , INPUT ); pinMode ( BTN_RIGHT , INPUT ); pinMode ( BTN_CENTER , INPUT ); } If you want to see debug messages on the serial monitor you have to add the following line in the setup method: 1 Serial . begin ( 115200 ); Now you could read the state from the Button. If you press the button you get a 0 , otherwise you get a 1 . 1 2 3 4 5 void loop () { Serial . print ( digitalRead ( BTN_UP )); delay ( 250 ); }","title":"Using the component"},{"location":"development-boards/esp32/menu/#sample-project","text":"An example project for the Arduino IDE can be downloaded: Button.ino ( download here ).","title":"Sample project"},{"location":"development-boards/esp32/microphone/","text":"Overview \u00b6 The component microphone includes the ICS-43432 chip, a digital I2S output microphone. It consists of a MEMS sensor, signal conditioning, an analog-to-digital converter, decimation and anti-aliasing filters, power management, and an industry standard 24-bit I\u00b2S interface. The ICS-43432 has a high SNR of 65 dBA and a wideband frequency response. Example There are three example projects for the Arduino IDE which can be downloaded: I2S_Microphone_Speaker.ino ( download here ), I2S_to_SD_16bit.ino ( download here ) and I2S_to_SD_24bit.ino ( download here ) ESP Board microphone SW301 Activating the component \u00b6 The component has a dip switch SW301 , which has to be activated in order to use the component. The component is connected to the following ports: Function SWITCH IO port Conflicts with Remarks SD 1 5 RFID , SW303-6, SDA; TFT , SW311-2, RESET; Grove Digital1 , SW206-2, IO5 SCK 2 17 Microphone , SW301-2, SCK; mikroBus , SW404-4, TX; Camera , SW403-1, RRST; Unit-Bus , SW201-2, CN212 - PIN 4; Grove UART , SW202-1, UART-RX; Grove Digital4 , SW209-2, IO17 SWS 3 18 RFID , SW303-5, SCL; TFT , SW311-5, SCK; TFT , SW314-2, T_CLK; mikroBus , SW405-3, SCK; Grove Digital4 , SW209-1, IO18 Switch 4 (LR) of SW301 is connected to GND. Using the component \u00b6 You need 6 jumpers to use the microphone connected to the board. The microphone can also be broken out of the board and can then be connected to the board by 6 cables. Info Required libraries In order to use the component you need the library \"i2s.h\". The latest version can be downloaded from the GitHub repository ( download here ). Sample project \u00b6 There are three example projects for the Arduino IDE which can be downloaded: I2S_Microphone_Speaker.ino ( download here ), I2S_to_SD_16bit.ino ( download here ) and I2S_to_SD_24bit.ino ( download here )","title":"Microphone"},{"location":"development-boards/esp32/microphone/#overview","text":"The component microphone includes the ICS-43432 chip, a digital I2S output microphone. It consists of a MEMS sensor, signal conditioning, an analog-to-digital converter, decimation and anti-aliasing filters, power management, and an industry standard 24-bit I\u00b2S interface. The ICS-43432 has a high SNR of 65 dBA and a wideband frequency response. Example There are three example projects for the Arduino IDE which can be downloaded: I2S_Microphone_Speaker.ino ( download here ), I2S_to_SD_16bit.ino ( download here ) and I2S_to_SD_24bit.ino ( download here ) ESP Board microphone SW301","title":"Overview"},{"location":"development-boards/esp32/microphone/#activating-the-component","text":"The component has a dip switch SW301 , which has to be activated in order to use the component. The component is connected to the following ports: Function SWITCH IO port Conflicts with Remarks SD 1 5 RFID , SW303-6, SDA; TFT , SW311-2, RESET; Grove Digital1 , SW206-2, IO5 SCK 2 17 Microphone , SW301-2, SCK; mikroBus , SW404-4, TX; Camera , SW403-1, RRST; Unit-Bus , SW201-2, CN212 - PIN 4; Grove UART , SW202-1, UART-RX; Grove Digital4 , SW209-2, IO17 SWS 3 18 RFID , SW303-5, SCL; TFT , SW311-5, SCK; TFT , SW314-2, T_CLK; mikroBus , SW405-3, SCK; Grove Digital4 , SW209-1, IO18 Switch 4 (LR) of SW301 is connected to GND.","title":"Activating the component"},{"location":"development-boards/esp32/microphone/#using-the-component","text":"You need 6 jumpers to use the microphone connected to the board. The microphone can also be broken out of the board and can then be connected to the board by 6 cables. Info Required libraries In order to use the component you need the library \"i2s.h\". The latest version can be downloaded from the GitHub repository ( download here ).","title":"Using the component"},{"location":"development-boards/esp32/microphone/#sample-project","text":"There are three example projects for the Arduino IDE which can be downloaded: I2S_Microphone_Speaker.ino ( download here ), I2S_to_SD_16bit.ino ( download here ) and I2S_to_SD_24bit.ino ( download here )","title":"Sample project"},{"location":"development-boards/esp32/mikro_bus/","text":"Overview \u00b6 The component mikroBUS\u2122 comprises a pair of 1\u00d78 female headers with a proprietary pin configuration and silkscreen markings. The pinout (always laid out in the same order) consists of three groups of communications pins (SPI, UART and I2C), six additional pins (PWM, Interrupt, Analog input, Reset and Chip select), and two power groups (+3.3V and 5V). Example An example project for the Arduino IDE is coming soon. ESP Board mikro Bus SW404,SW405 Activating the component \u00b6 Function IO port switch PWM IO12 SW404-1 INT IO14 SW404-2 RX IO16 SW404-3 TX IO17 SW404-4 SCL IO22 SW404-5 SDA IO21 SW404-6 MOSI IO23 SW405-1 MISO IO19 SW405-2 SCK IO18 SW405-3 CS IO2 SW405-4 RST IO13 SW405-5 AN IO33 SW405-6 Using the component \u00b6 Sample project \u00b6 An example project for the Arduino IDE is coming soon.","title":"mikroBUS"},{"location":"development-boards/esp32/mikro_bus/#overview","text":"The component mikroBUS\u2122 comprises a pair of 1\u00d78 female headers with a proprietary pin configuration and silkscreen markings. The pinout (always laid out in the same order) consists of three groups of communications pins (SPI, UART and I2C), six additional pins (PWM, Interrupt, Analog input, Reset and Chip select), and two power groups (+3.3V and 5V). Example An example project for the Arduino IDE is coming soon. ESP Board mikro Bus SW404,SW405","title":"Overview"},{"location":"development-boards/esp32/mikro_bus/#activating-the-component","text":"Function IO port switch PWM IO12 SW404-1 INT IO14 SW404-2 RX IO16 SW404-3 TX IO17 SW404-4 SCL IO22 SW404-5 SDA IO21 SW404-6 MOSI IO23 SW405-1 MISO IO19 SW405-2 SCK IO18 SW405-3 CS IO2 SW405-4 RST IO13 SW405-5 AN IO33 SW405-6","title":"Activating the component"},{"location":"development-boards/esp32/mikro_bus/#using-the-component","text":"","title":"Using the component"},{"location":"development-boards/esp32/mikro_bus/#sample-project","text":"An example project for the Arduino IDE is coming soon.","title":"Sample project"},{"location":"development-boards/esp32/motor/","text":"Overview \u00b6 The component MOTOR is a stepper driver for DRV8824/25 and A4988 breakout boards Example An example project for the Arduino IDE is provided in BasicStepperDriver.ino ( download here ) ESP Board motor SW304,SW305 Activating the component \u00b6 The component has two dip switches SW304 and SW305 for activating the component. Function SWITCH IO port Conflicts with Remarks DIR SW304-1 33 RGB LED , SW313, DIN; TFT , SW314, T_DO; mikroBus , SW405-6, AN STEP SW304-2 23 RFID , SW303-4, MOSI; TFT , SW311-4, MOSI; TFT , SW314-4, T_DIN; mikroBus , SW405-1, MOSI The four switchs of SW305 are connected to GND. The functions are as follows: Function SWITCH CFG3 SW305-1 CFG2 SW305-2 CFG1 SW305-3 EN SW305-4 Connect a stepper motor on J301. Motor connection from left to right: Function SWITCH GND external motor power supply VCC external motor power supply 2B motor coil 2 2A motor coil 2 1A motor coil 1 1B motor coil 1 Using the component \u00b6 You have to switch on SW304. Depending on your motor driver, you may need to turn on Enable (switch 4 of SW305). Setup the component \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <Arduino.h> #include <BasicStepperDriver.h> // Motor steps per revolution. Most steppers are 200 steps or 1.8 degrees/step #define MOTOR_STEPS 200 // All the wires needed for full functionality #define DIR 33 #define STEP 23 // Since microstepping is set externally, make sure this matches the selected mode // 1=full step, 2=half step etc. #define MICROSTEPS 16 // 2-wire basic config, microstepping is hardwired on the driver BasicStepperDriver stepper ( MOTOR_STEPS , DIR , STEP ); 1 2 3 4 5 6 7 8 void setup () { /* * Set target motor RPM. * These motors can do up to about 200rpm. * Too high will result in a high pitched whine and the motor does not move. */ stepper . setRPM ( 100 ); } Control the servo \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void loop () { // energize coils - the motor will hold position // stepper.enable(); /* * Tell the driver the microstep level we selected. * If mismatched, the motor will move at a different RPM than chosen. */ stepper . setMicrostep ( MICROSTEPS ); /* * Moving motor one full revolution using the degree notation */ stepper . rotate ( 360 ); delay ( 1000 ); /* * Moving motor to original position using steps */ stepper . move ( - 200 * MICROSTEPS ); // pause and allow the motor to be moved by hand // stepper.disable(); delay ( 1000 ); } Sample project \u00b6 A sample project for the Arduino IDE is provided in BasicStepperDriver.ino ( download here ).","title":"Motor"},{"location":"development-boards/esp32/motor/#overview","text":"The component MOTOR is a stepper driver for DRV8824/25 and A4988 breakout boards Example An example project for the Arduino IDE is provided in BasicStepperDriver.ino ( download here ) ESP Board motor SW304,SW305","title":"Overview"},{"location":"development-boards/esp32/motor/#activating-the-component","text":"The component has two dip switches SW304 and SW305 for activating the component. Function SWITCH IO port Conflicts with Remarks DIR SW304-1 33 RGB LED , SW313, DIN; TFT , SW314, T_DO; mikroBus , SW405-6, AN STEP SW304-2 23 RFID , SW303-4, MOSI; TFT , SW311-4, MOSI; TFT , SW314-4, T_DIN; mikroBus , SW405-1, MOSI The four switchs of SW305 are connected to GND. The functions are as follows: Function SWITCH CFG3 SW305-1 CFG2 SW305-2 CFG1 SW305-3 EN SW305-4 Connect a stepper motor on J301. Motor connection from left to right: Function SWITCH GND external motor power supply VCC external motor power supply 2B motor coil 2 2A motor coil 2 1A motor coil 1 1B motor coil 1","title":"Activating the component"},{"location":"development-boards/esp32/motor/#using-the-component","text":"You have to switch on SW304. Depending on your motor driver, you may need to turn on Enable (switch 4 of SW305).","title":"Using the component"},{"location":"development-boards/esp32/motor/#setup-the-component","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <Arduino.h> #include <BasicStepperDriver.h> // Motor steps per revolution. Most steppers are 200 steps or 1.8 degrees/step #define MOTOR_STEPS 200 // All the wires needed for full functionality #define DIR 33 #define STEP 23 // Since microstepping is set externally, make sure this matches the selected mode // 1=full step, 2=half step etc. #define MICROSTEPS 16 // 2-wire basic config, microstepping is hardwired on the driver BasicStepperDriver stepper ( MOTOR_STEPS , DIR , STEP ); 1 2 3 4 5 6 7 8 void setup () { /* * Set target motor RPM. * These motors can do up to about 200rpm. * Too high will result in a high pitched whine and the motor does not move. */ stepper . setRPM ( 100 ); }","title":"Setup the component"},{"location":"development-boards/esp32/motor/#control-the-servo","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void loop () { // energize coils - the motor will hold position // stepper.enable(); /* * Tell the driver the microstep level we selected. * If mismatched, the motor will move at a different RPM than chosen. */ stepper . setMicrostep ( MICROSTEPS ); /* * Moving motor one full revolution using the degree notation */ stepper . rotate ( 360 ); delay ( 1000 ); /* * Moving motor to original position using steps */ stepper . move ( - 200 * MICROSTEPS ); // pause and allow the motor to be moved by hand // stepper.disable(); delay ( 1000 ); }","title":"Control the servo"},{"location":"development-boards/esp32/motor/#sample-project","text":"A sample project for the Arduino IDE is provided in BasicStepperDriver.ino ( download here ).","title":"Sample project"},{"location":"development-boards/esp32/potentiometer/","text":"Overview \u00b6 The component POTENTIOMETER has two potentiomenters which could be used independently. Example An example project for the Arduino IDE is provided in ReadPot.ino ( download here ) ESP Board potentiometer SW300,SW302 Activating the component \u00b6 The component has two dip switchs SW300 and SW302 for activating the buttons. SW300 is for the left potentiometer and SW301 for the right potentiometer. In order to use the potentiometers it's necessary to switch on the appropriate switch. Function SWITCH IO port Conflicts with Remarks SENSOR_VN SW302 39 Grove ANALOG1 , SW204-1, VN SENSOR_VP SW300 36 Grove ANALOG1 , SW204-2, VP Using the component \u00b6 It's very important to switch on the right switches on SW300 and/or SW302 . The left potentiometer could be read on io port 39 and the right potentiometer on port 36 . The potentiometers are independent of each other. If you solely want to use one of the potentiometer, it's sufficient to switch on the appropriate switch. There is so special setup code necessary for using the potentiometers. Reading the left potentiometer \u00b6 1 int R300 = analogRead ( 39 ); Reading the right potentiometer \u00b6 1 int R302 = analogRead ( 36 ); Sample project \u00b6 An example project for the Arduino IDE is provided in ReadPot.ino ( download here ).","title":"Potentiometer"},{"location":"development-boards/esp32/potentiometer/#overview","text":"The component POTENTIOMETER has two potentiomenters which could be used independently. Example An example project for the Arduino IDE is provided in ReadPot.ino ( download here ) ESP Board potentiometer SW300,SW302","title":"Overview"},{"location":"development-boards/esp32/potentiometer/#activating-the-component","text":"The component has two dip switchs SW300 and SW302 for activating the buttons. SW300 is for the left potentiometer and SW301 for the right potentiometer. In order to use the potentiometers it's necessary to switch on the appropriate switch. Function SWITCH IO port Conflicts with Remarks SENSOR_VN SW302 39 Grove ANALOG1 , SW204-1, VN SENSOR_VP SW300 36 Grove ANALOG1 , SW204-2, VP","title":"Activating the component"},{"location":"development-boards/esp32/potentiometer/#using-the-component","text":"It's very important to switch on the right switches on SW300 and/or SW302 . The left potentiometer could be read on io port 39 and the right potentiometer on port 36 . The potentiometers are independent of each other. If you solely want to use one of the potentiometer, it's sufficient to switch on the appropriate switch. There is so special setup code necessary for using the potentiometers.","title":"Using the component"},{"location":"development-boards/esp32/potentiometer/#reading-the-left-potentiometer","text":"1 int R300 = analogRead ( 39 );","title":"Reading the left potentiometer"},{"location":"development-boards/esp32/potentiometer/#reading-the-right-potentiometer","text":"1 int R302 = analogRead ( 36 );","title":"Reading the right potentiometer"},{"location":"development-boards/esp32/potentiometer/#sample-project","text":"An example project for the Arduino IDE is provided in ReadPot.ino ( download here ).","title":"Sample project"},{"location":"development-boards/esp32/power-supply/","text":"Overview \u00b6 Here at CON100 you can connect an external power supply with 8-15V DC: Connect plus to the left port and minus to the right. Then put the switch to the position \"ON\". You need to set the switch to position ON if you want to use the board. Even if the board is powered by USB. ESP Board power supply switch on/off Activating the component \u00b6 There is no special source code needed for activating this component. Using the component \u00b6 There is no special source code needed for using this component. Sample project \u00b6 There is no specific source code necessary.","title":"Power Supply"},{"location":"development-boards/esp32/power-supply/#overview","text":"Here at CON100 you can connect an external power supply with 8-15V DC: Connect plus to the left port and minus to the right. Then put the switch to the position \"ON\". You need to set the switch to position ON if you want to use the board. Even if the board is powered by USB. ESP Board power supply switch on/off","title":"Overview"},{"location":"development-boards/esp32/power-supply/#activating-the-component","text":"There is no special source code needed for activating this component.","title":"Activating the component"},{"location":"development-boards/esp32/power-supply/#using-the-component","text":"There is no special source code needed for using this component.","title":"Using the component"},{"location":"development-boards/esp32/power-supply/#sample-project","text":"There is no specific source code necessary.","title":"Sample project"},{"location":"development-boards/esp32/program/","text":"Programming the ESP32 \u00b6 After a successful installation of the Arduino IDE it's necessary to install the ESP32 as development board inside the Arduino IDE. For this you have to do the following two steps: Register a new board manager Install the extension for ESP32 Note The communication between the host computer and the development board is done by USB. The used USB chipset is a Silicon Labs CP210x . It should be automatically recognized by the operation system. If there is no automatic recognition install the driver manually. The link to the driver page is here Register a new board manager \u00b6 Start the Arduino IDE, open the Preferences window with File > Preferences in the menu bar. IDE preferences select preferences The Preferences window has two tabs: Settings Network IDE Settings select Additional Boards Manager URLs It's not necessary to change the settings inside the Network tab. But a change in the tab Settings is necessary. Add an entry to the Additional Boards Manager URLs : You could directly paste the following url into the input field or open a separate window: 1 https://dl.espressif.com/dl/package_esp32_index.json IDE Enter additional URLs insert url Install the extension for ESP32 \u00b6 Now you can install the development extension for the ESP32 at the Arduino IDE. Go to Tools > Board > Boards Manager... IDE Boards Manager select Boards Manager Use the search input file. Search for esp32 and select Install . IDE Boards select install After the install a section ESP 32 in the menu Tools > Board should occur. IDE Boards select Boards Now select the ESP32 Dev Module in Tools -> Board . IDE ESP32 Dev Module select ESP32 Dev Module","title":"Programming the board"},{"location":"development-boards/esp32/program/#programming-the-esp32","text":"After a successful installation of the Arduino IDE it's necessary to install the ESP32 as development board inside the Arduino IDE. For this you have to do the following two steps: Register a new board manager Install the extension for ESP32 Note The communication between the host computer and the development board is done by USB. The used USB chipset is a Silicon Labs CP210x . It should be automatically recognized by the operation system. If there is no automatic recognition install the driver manually. The link to the driver page is here","title":"Programming the ESP32"},{"location":"development-boards/esp32/program/#register-a-new-board-manager","text":"Start the Arduino IDE, open the Preferences window with File > Preferences in the menu bar. IDE preferences select preferences The Preferences window has two tabs: Settings Network IDE Settings select Additional Boards Manager URLs It's not necessary to change the settings inside the Network tab. But a change in the tab Settings is necessary. Add an entry to the Additional Boards Manager URLs : You could directly paste the following url into the input field or open a separate window: 1 https://dl.espressif.com/dl/package_esp32_index.json IDE Enter additional URLs insert url","title":"Register a new board manager"},{"location":"development-boards/esp32/program/#install-the-extension-for-esp32","text":"Now you can install the development extension for the ESP32 at the Arduino IDE. Go to Tools > Board > Boards Manager... IDE Boards Manager select Boards Manager Use the search input file. Search for esp32 and select Install . IDE Boards select install After the install a section ESP 32 in the menu Tools > Board should occur. IDE Boards select Boards Now select the ESP32 Dev Module in Tools -> Board . IDE ESP32 Dev Module select ESP32 Dev Module","title":"Install the extension for ESP32"},{"location":"development-boards/esp32/rfid/","text":"Overview \u00b6 Read data from RFID RC522 Example An example project for the Arduino IDE can be downloaded: RFID-PICC.ino ( download here ) ESP Board rfid SW303 Activating the component \u00b6 The component has a dip switch SW303 for activating the RFID reader. The switch is connected to the following io ports: Function SWITCH IO port Conflicts with Remarks RST 1 22 Audio , SW306-4, DIN; mikroBus , SW404-5, SCL; Camera , SW400-6, SIOC/SCL IRQ 2 12 Gyro , SW310-2, AD0/SD0; mikroBus , SW404-1, PWM; Camera , SW402-3, D1; SD Card , SW406-2, DAT; Grove Digital1 , SW206-1, IIO12 MISO 3 19 Gyro , SW310-3, SDA/SDI; OLED , SW309-4, SDA; TFT , SW314-1, MISO; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN 2; Grove I2C , SW203-1, I2C - SDA MOSI 4 23 Motor , SW304-2, STEP; TFT , SW311-4, MOSI; TFT , SW314-4, T_DIN; mikroBus , SW405-1, MOSI SCL 5 18 Microphone , SW301-3, WS; RFID , SW303-5, SCL; TFT , SW311-5, SCK; TFT , SW314-2, T_CLK; mikroBus , SW405-3, SCK; Grove Digital4 , SW209-1, IO18 SDA 6 5 Microphone , SW301-1; TFT , SW311-2, RESET; Grove Digital1 , SW206-2, IO5 Using the component \u00b6 Info Required libraries In order to use the component you need the MFRC522-Library. The latested version could be download from the GitHub repository . If you want to use the version from GitHub download a zip archiv. Addtionally you could download a tested version. After the download it's necessary to add the library to your Arduino IDE. Open Sketch > Include Library > Add .ZIP Library ... and select the downloaded archive. After a sucessful installation the menu Sketch > Include Library should contain an entry MFRC522 in the category Contributed libraries . Setup the component \u00b6 1 2 3 4 5 6 7 8 void setup () { Serial . begin ( 115200 ); // Initialize serial communications with the PC while ( ! Serial ); // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4) SPI . begin (); // Init SPI bus mfrc522 . PCD_Init (); // Init MFRC522 mfrc522 . PCD_DumpVersionToSerial (); // Show details of PCD - MFRC522 Card Reader details Serial . println ( F ( \"Scan PICC to see UID, SAK, type, and data blocks...\" )); } Check for new cards \u00b6 1 2 3 if ( ! mfrc522 . PICC_IsNewCardPresent ()) { return ; } Select one of the cards \u00b6 1 2 3 if ( ! mfrc522 . PICC_ReadCardSerial ()) { return ; } Dump debug info about the card \u00b6 1 mfrc522 . PICC_DumpToSerial ( & ( mfrc522 . uid )); Sample project \u00b6 An example project for the Arduino IDE can be downloaded: RFID-PICC.ino ( download here )","title":"RFID"},{"location":"development-boards/esp32/rfid/#overview","text":"Read data from RFID RC522 Example An example project for the Arduino IDE can be downloaded: RFID-PICC.ino ( download here ) ESP Board rfid SW303","title":"Overview"},{"location":"development-boards/esp32/rfid/#activating-the-component","text":"The component has a dip switch SW303 for activating the RFID reader. The switch is connected to the following io ports: Function SWITCH IO port Conflicts with Remarks RST 1 22 Audio , SW306-4, DIN; mikroBus , SW404-5, SCL; Camera , SW400-6, SIOC/SCL IRQ 2 12 Gyro , SW310-2, AD0/SD0; mikroBus , SW404-1, PWM; Camera , SW402-3, D1; SD Card , SW406-2, DAT; Grove Digital1 , SW206-1, IIO12 MISO 3 19 Gyro , SW310-3, SDA/SDI; OLED , SW309-4, SDA; TFT , SW314-1, MISO; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN 2; Grove I2C , SW203-1, I2C - SDA MOSI 4 23 Motor , SW304-2, STEP; TFT , SW311-4, MOSI; TFT , SW314-4, T_DIN; mikroBus , SW405-1, MOSI SCL 5 18 Microphone , SW301-3, WS; RFID , SW303-5, SCL; TFT , SW311-5, SCK; TFT , SW314-2, T_CLK; mikroBus , SW405-3, SCK; Grove Digital4 , SW209-1, IO18 SDA 6 5 Microphone , SW301-1; TFT , SW311-2, RESET; Grove Digital1 , SW206-2, IO5","title":"Activating the component"},{"location":"development-boards/esp32/rfid/#using-the-component","text":"Info Required libraries In order to use the component you need the MFRC522-Library. The latested version could be download from the GitHub repository . If you want to use the version from GitHub download a zip archiv. Addtionally you could download a tested version. After the download it's necessary to add the library to your Arduino IDE. Open Sketch > Include Library > Add .ZIP Library ... and select the downloaded archive. After a sucessful installation the menu Sketch > Include Library should contain an entry MFRC522 in the category Contributed libraries .","title":"Using the component"},{"location":"development-boards/esp32/rfid/#setup-the-component","text":"1 2 3 4 5 6 7 8 void setup () { Serial . begin ( 115200 ); // Initialize serial communications with the PC while ( ! Serial ); // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4) SPI . begin (); // Init SPI bus mfrc522 . PCD_Init (); // Init MFRC522 mfrc522 . PCD_DumpVersionToSerial (); // Show details of PCD - MFRC522 Card Reader details Serial . println ( F ( \"Scan PICC to see UID, SAK, type, and data blocks...\" )); }","title":"Setup the component"},{"location":"development-boards/esp32/rfid/#check-for-new-cards","text":"1 2 3 if ( ! mfrc522 . PICC_IsNewCardPresent ()) { return ; }","title":"Check for new cards"},{"location":"development-boards/esp32/rfid/#select-one-of-the-cards","text":"1 2 3 if ( ! mfrc522 . PICC_ReadCardSerial ()) { return ; }","title":"Select one of the cards"},{"location":"development-boards/esp32/rfid/#dump-debug-info-about-the-card","text":"1 mfrc522 . PICC_DumpToSerial ( & ( mfrc522 . uid ));","title":"Dump debug info about the card"},{"location":"development-boards/esp32/rfid/#sample-project","text":"An example project for the Arduino IDE can be downloaded: RFID-PICC.ino ( download here )","title":"Sample project"},{"location":"development-boards/esp32/rgb-led/","text":"RGB LED strip \u00b6 The component RGB LED has four WS2813 RGB LEDs. The LEDs are connected to each other and therefore they could be handled like an LED strip. Example There are six example projects for the Arduino IDE which can be downloaded: RGB-LED-HSV.ino ( download here ), RGB-LED-WS2813.ino ( download here ), RGB-LED-WS2813-ColorBridge.ino ( download here ), RGB-LED-WS2813-POT-BR.ino ( download here ), RGB-LED-WS2813-POT-COLOR.ino ( download here ), and RGB-LED-WS2813-SmoothColors.ino ( download here ) ESP Board RGB LED SW312,SW313 USING THE COMPONENT \u00b6 The four LEDs are labeled on the board. The first LED in the strip is the LED D300 nearby the switches. Label on the board LED number D300 0 D301 1 D302 2 D303 3 Hardware activation of the RGB LED strip \u00b6 Caution The LEDs are connected to two GPIO-Pins. In order to control the LEDs you have to activate one connection and have to deactivate the other connection. With the switch SW313 you could active the connection to IO 33 of the ESP32. With SW312 you could active the connection to IO 2 of the ESP32. Activate the RGB LED on the board with either SW313 or SW312 . Preparing the IDE for using the LED strip \u00b6 The LED strip could be programmed by using the Adafruit Neopixel Library . This libray has to be installed in your Arduino IDE. The following steps are necessary: Download the latest version of the Library from here https://github.com/adafruit/Adafruit_NeoPixel/archive/master.zip Extract the the downloaded master.zip and rename the folder to Adafruit_Neopixel Copy the complete folder to the libraries directory of your Arduino IDE. Info The library order is named libraries and could be found in Windows under XXXXX and in Mac OS X in Documents/Arduino/libraries in the user directory. Now restart your Arduino IDE. After a successful installation the examples of the library should occur in File > Examples > Adafruit Neopixel ESP Board RGB LED Examples from the Neopixel libray Sample project \u00b6 There are six example projects for the Arduino IDE which can be downloaded: RGB-LED-HSV.ino ( download here ), RGB-LED-WS2813.ino ( download here ), RGB-LED-WS2813-ColorBridge.ino ( download here ), RGB-LED-WS2813-POT-BR.ino ( download here ), RGB-LED-WS2813-POT-COLOR.ino ( download here ), and RGB-LED-WS2813-SmoothColors.ino ( download here )","title":"RGB LED"},{"location":"development-boards/esp32/rgb-led/#rgb-led-strip","text":"The component RGB LED has four WS2813 RGB LEDs. The LEDs are connected to each other and therefore they could be handled like an LED strip. Example There are six example projects for the Arduino IDE which can be downloaded: RGB-LED-HSV.ino ( download here ), RGB-LED-WS2813.ino ( download here ), RGB-LED-WS2813-ColorBridge.ino ( download here ), RGB-LED-WS2813-POT-BR.ino ( download here ), RGB-LED-WS2813-POT-COLOR.ino ( download here ), and RGB-LED-WS2813-SmoothColors.ino ( download here ) ESP Board RGB LED SW312,SW313","title":"RGB LED strip"},{"location":"development-boards/esp32/rgb-led/#using-the-component","text":"The four LEDs are labeled on the board. The first LED in the strip is the LED D300 nearby the switches. Label on the board LED number D300 0 D301 1 D302 2 D303 3","title":"USING THE COMPONENT"},{"location":"development-boards/esp32/rgb-led/#hardware-activation-of-the-rgb-led-strip","text":"Caution The LEDs are connected to two GPIO-Pins. In order to control the LEDs you have to activate one connection and have to deactivate the other connection. With the switch SW313 you could active the connection to IO 33 of the ESP32. With SW312 you could active the connection to IO 2 of the ESP32. Activate the RGB LED on the board with either SW313 or SW312 .","title":"Hardware activation of the RGB LED strip"},{"location":"development-boards/esp32/rgb-led/#preparing-the-ide-for-using-the-led-strip","text":"The LED strip could be programmed by using the Adafruit Neopixel Library . This libray has to be installed in your Arduino IDE. The following steps are necessary: Download the latest version of the Library from here https://github.com/adafruit/Adafruit_NeoPixel/archive/master.zip Extract the the downloaded master.zip and rename the folder to Adafruit_Neopixel Copy the complete folder to the libraries directory of your Arduino IDE. Info The library order is named libraries and could be found in Windows under XXXXX and in Mac OS X in Documents/Arduino/libraries in the user directory. Now restart your Arduino IDE. After a successful installation the examples of the library should occur in File > Examples > Adafruit Neopixel ESP Board RGB LED Examples from the Neopixel libray","title":"Preparing the IDE for using the LED strip"},{"location":"development-boards/esp32/rgb-led/#sample-project","text":"There are six example projects for the Arduino IDE which can be downloaded: RGB-LED-HSV.ino ( download here ), RGB-LED-WS2813.ino ( download here ), RGB-LED-WS2813-ColorBridge.ino ( download here ), RGB-LED-WS2813-POT-BR.ino ( download here ), RGB-LED-WS2813-POT-COLOR.ino ( download here ), and RGB-LED-WS2813-SmoothColors.ino ( download here )","title":"Sample project"},{"location":"development-boards/esp32/sd_card/","text":"Overview \u00b6 At component SD card you can read and write data to a sd card inserted in the socket. Example There are two example projects for the Arduino IDE which can be downloaded: SD-Dir.ino ( download here ) and SD-ReadWrite.ino ( download here ) ESP Board sd card SW406,SW407 Activating the component \u00b6 Function SWITCH IO port Conflicts with Remarks CD/DAT3 IO13 SW406-1 DAT2 IO12 SW406-2 DAT1 IO4 SW406-3 DAT0 IO2 SW406-4 CLK IO14 SW406-5 CMD IO15 SW406-6 LED IO32 SW407-1 CDET IO27 SW407-2 Using the component \u00b6 Setup \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <SPI.h> #include <mySD.h> #define CS 13 #define CLK 14 #define MISO 2 #define MOSI 15 File root ; void setup () { delay ( 3000 ); // delay for SD-Card issue -> upload switches OFF, aber booting switch to ON. Litle bit tricky :-) // Open serial communications and wait for port to open: Serial . begin ( 115200 ); while ( ! Serial ) { ; // wait for serial port to connect. Needed for Leonardo only } Serial . print ( \"Initializing SD card...\" ); if ( ! SD . begin ( CS , MOSI , MISO , CLK )) { Serial . println ( \"initialization failed!\" ); return ; } Serial . println ( \"initialization done.\" ); root = SD . open ( \"/\" ); printDirectory ( root , 0 ); Serial . println ( \"done!\" ); } Print directory \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void printDirectory ( File dir , int numTabs ) { // Begin at the start of the directory dir . rewindDirectory (); while ( true ) { File entry = dir . openNextFile (); if ( ! entry ) { // no more files //Serial.println(\"**nomorefiles**\"); break ; } for ( uint8_t i = 0 ; i < numTabs ; i ++ ) { Serial . print ( '\\t' ); // we'll have a nice indentation } // Print the 8.3 name Serial . print ( entry . name ()); // Recurse for directories, otherwise print the file size if ( entry . isDirectory ()) { Serial . println ( \"/\" ); printDirectory ( entry , numTabs + 1 ); } else { // files have sizes, directories do not Serial . print ( \" \\t\\t \" ); Serial . println ( entry . size (), DEC ); } entry . close (); } } Sample project \u00b6 There are two example projects for the Arduino IDE which can be downloaded: SD-Dir.ino ( download here ) and SD-ReadWrite.ino ( download here )","title":"SD Card"},{"location":"development-boards/esp32/sd_card/#overview","text":"At component SD card you can read and write data to a sd card inserted in the socket. Example There are two example projects for the Arduino IDE which can be downloaded: SD-Dir.ino ( download here ) and SD-ReadWrite.ino ( download here ) ESP Board sd card SW406,SW407","title":"Overview"},{"location":"development-boards/esp32/sd_card/#activating-the-component","text":"Function SWITCH IO port Conflicts with Remarks CD/DAT3 IO13 SW406-1 DAT2 IO12 SW406-2 DAT1 IO4 SW406-3 DAT0 IO2 SW406-4 CLK IO14 SW406-5 CMD IO15 SW406-6 LED IO32 SW407-1 CDET IO27 SW407-2","title":"Activating the component"},{"location":"development-boards/esp32/sd_card/#using-the-component","text":"","title":"Using the component"},{"location":"development-boards/esp32/sd_card/#setup","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <SPI.h> #include <mySD.h> #define CS 13 #define CLK 14 #define MISO 2 #define MOSI 15 File root ; void setup () { delay ( 3000 ); // delay for SD-Card issue -> upload switches OFF, aber booting switch to ON. Litle bit tricky :-) // Open serial communications and wait for port to open: Serial . begin ( 115200 ); while ( ! Serial ) { ; // wait for serial port to connect. Needed for Leonardo only } Serial . print ( \"Initializing SD card...\" ); if ( ! SD . begin ( CS , MOSI , MISO , CLK )) { Serial . println ( \"initialization failed!\" ); return ; } Serial . println ( \"initialization done.\" ); root = SD . open ( \"/\" ); printDirectory ( root , 0 ); Serial . println ( \"done!\" ); }","title":"Setup"},{"location":"development-boards/esp32/sd_card/#print-directory","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void printDirectory ( File dir , int numTabs ) { // Begin at the start of the directory dir . rewindDirectory (); while ( true ) { File entry = dir . openNextFile (); if ( ! entry ) { // no more files //Serial.println(\"**nomorefiles**\"); break ; } for ( uint8_t i = 0 ; i < numTabs ; i ++ ) { Serial . print ( '\\t' ); // we'll have a nice indentation } // Print the 8.3 name Serial . print ( entry . name ()); // Recurse for directories, otherwise print the file size if ( entry . isDirectory ()) { Serial . println ( \"/\" ); printDirectory ( entry , numTabs + 1 ); } else { // files have sizes, directories do not Serial . print ( \" \\t\\t \" ); Serial . println ( entry . size (), DEC ); } entry . close (); } }","title":"Print directory"},{"location":"development-boards/esp32/sd_card/#sample-project","text":"There are two example projects for the Arduino IDE which can be downloaded: SD-Dir.ino ( download here ) and SD-ReadWrite.ino ( download here )","title":"Sample project"},{"location":"development-boards/esp32/temperature/","text":"Overview \u00b6 The component TEMPERATURE has a Dallas chip DS18B20+ for temperature measurement Example There are five example projects for the Arduino IDE which could be downloaded: DS18B20.ino ( download here ), DS18B20-Temperature-Control-Library-1.ino ( download here ), DS18B20-Temperature-Control-Library-2.ino ( download here ), Temp-Oled.ino ( download here ) and Temp-TFT.ino ( download here ). ESP Board temperature SW315 Activating the component \u00b6 The component has a dip switch SW315 for activating the temperature sensor. The switch is connected to the following io ports: Function SWITCH IO port Conflicts with Remarks DQ 1 16 Audio , SW306-1, SD_MODE; mirkoBus , SW404-3, RX; Camera , SW403-2, WRST; Unit-Bus , WS201-1, CN212 - PIN 3; Grove UART , SW202-2, UART TX Using the component \u00b6 Info Required libraries In order to use the component you need the OneWire-Library. The latest version could be download from the GitHub repository . If you want to use the version from GitHub download a zip archiv. Addtionally you could download a tested version. After the download it's necessary to add the library to your Arduino IDE. Open Sketch > Include Library > Add .ZIP Library ... and select the downloaded archive. After a successful installation the menu Sketch > Include Library should contain an entry OneWire in the category Contributed libraries . Import the necessary libraries \u00b6 1 #include <OneWire.h> Setup the component \u00b6 For using the temperature sensor the library from Dallas is used. This library controls the sensor and will be configured on the io port 16: 1 OneWire ds ( 16 ); Note In serveral examples in the Internet it's mentioned that a pull-up resistor for SDA is necessary. This resistor is already on the board. Therefore you need no additional pull-up resistor in order to use this component. Beside the initialisation of the dallas library there is no special code in the setup method necessary: 1 2 3 void setup ( void ) { Serial . begin ( 115200 ); } Searching for the address on the bus \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 byte i ; byte present = 0 ; byte data [ 12 ]; byte addr [ 8 ]; float celsius , fahrenheit ; if ( ! ds . search ( addr )) { Serial . println ( \"No more addresses\" ); ds . reset_search (); delay ( 250 ); return ; } Serial . print ( \"ROM =\" ); for ( i = 0 ; i < 8 ; i ++ ) { Serial . write ( ' ' ); Serial . print ( addr [ i ], HEX ); } if ( OneWire :: crc8 ( addr , 7 ) != addr [ 7 ]) { Serial . println ( \"CRC is not valid!\" ); return ; } Select the chip and read the data \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ds . reset (); ds . select ( addr ); ds . write ( 0x44 , 1 ); // start conversion, with parasite power on at the end delay ( 1000 ); // maybe 750ms is enough, maybe not // we might do a ds.depower() here, but the reset will take care of it. present = ds . reset (); ds . select ( addr ); ds . write ( 0xBE ); // Read Scratchpad Serial . print ( \" Data = \" ); Serial . print ( present , HEX ); Serial . print ( \" \" ); for ( i = 0 ; i < 9 ; i ++ ) { // we need 9 bytes data [ i ] = ds . read (); Serial . print ( data [ i ], HEX ); Serial . print ( \" \" ); } Serial . print ( \" CRC=\" ); Serial . print ( OneWire :: crc8 ( data , 8 ), HEX ); Serial . println (); Convert the data \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Convert the data to actual temperature // because the result is a 16 bit signed integer, it should // be stored to an \"int16_t\" type, which is always 16 bits // even when compiled on a 32 bit processor. int16_t raw = ( data [ 1 ] << 8 ) | data [ 0 ]; byte cfg = ( data [ 4 ] & 0x60 ); // at lower res, the low bits are undefined, so let's zero them if ( cfg == 0x00 ) raw = raw & ~ 7 ; // 9 bit resolution, 93.75 ms else if ( cfg == 0x20 ) raw = raw & ~ 3 ; // 10 bit res, 187.5 ms else if ( cfg == 0x40 ) raw = raw & ~ 1 ; // 11 bit res, 375 ms //// default is 12 bit resolution, 750 ms conversion time celsius = ( float ) raw / 16.0 ; fahrenheit = celsius * 1.8 + 32.0 ; Sample project \u00b6 There are five example projects for the Arduino IDE which could be downloaded: DS18B20.ino ( download here ), DS18B20-Temperature-Control-Library-1.ino ( download here ), DS18B20-Temperature-Control-Library-2.ino ( download here ), Temp-Oled.ino ( download here ) and Temp-TFT.ino ( download here ).","title":"Temperature"},{"location":"development-boards/esp32/temperature/#overview","text":"The component TEMPERATURE has a Dallas chip DS18B20+ for temperature measurement Example There are five example projects for the Arduino IDE which could be downloaded: DS18B20.ino ( download here ), DS18B20-Temperature-Control-Library-1.ino ( download here ), DS18B20-Temperature-Control-Library-2.ino ( download here ), Temp-Oled.ino ( download here ) and Temp-TFT.ino ( download here ). ESP Board temperature SW315","title":"Overview"},{"location":"development-boards/esp32/temperature/#activating-the-component","text":"The component has a dip switch SW315 for activating the temperature sensor. The switch is connected to the following io ports: Function SWITCH IO port Conflicts with Remarks DQ 1 16 Audio , SW306-1, SD_MODE; mirkoBus , SW404-3, RX; Camera , SW403-2, WRST; Unit-Bus , WS201-1, CN212 - PIN 3; Grove UART , SW202-2, UART TX","title":"Activating the component"},{"location":"development-boards/esp32/temperature/#using-the-component","text":"Info Required libraries In order to use the component you need the OneWire-Library. The latest version could be download from the GitHub repository . If you want to use the version from GitHub download a zip archiv. Addtionally you could download a tested version. After the download it's necessary to add the library to your Arduino IDE. Open Sketch > Include Library > Add .ZIP Library ... and select the downloaded archive. After a successful installation the menu Sketch > Include Library should contain an entry OneWire in the category Contributed libraries .","title":"Using the component"},{"location":"development-boards/esp32/temperature/#import-the-necessary-libraries","text":"1 #include <OneWire.h>","title":"Import the necessary libraries"},{"location":"development-boards/esp32/temperature/#setup-the-component","text":"For using the temperature sensor the library from Dallas is used. This library controls the sensor and will be configured on the io port 16: 1 OneWire ds ( 16 ); Note In serveral examples in the Internet it's mentioned that a pull-up resistor for SDA is necessary. This resistor is already on the board. Therefore you need no additional pull-up resistor in order to use this component. Beside the initialisation of the dallas library there is no special code in the setup method necessary: 1 2 3 void setup ( void ) { Serial . begin ( 115200 ); }","title":"Setup the component"},{"location":"development-boards/esp32/temperature/#searching-for-the-address-on-the-bus","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 byte i ; byte present = 0 ; byte data [ 12 ]; byte addr [ 8 ]; float celsius , fahrenheit ; if ( ! ds . search ( addr )) { Serial . println ( \"No more addresses\" ); ds . reset_search (); delay ( 250 ); return ; } Serial . print ( \"ROM =\" ); for ( i = 0 ; i < 8 ; i ++ ) { Serial . write ( ' ' ); Serial . print ( addr [ i ], HEX ); } if ( OneWire :: crc8 ( addr , 7 ) != addr [ 7 ]) { Serial . println ( \"CRC is not valid!\" ); return ; }","title":"Searching for the address on the bus"},{"location":"development-boards/esp32/temperature/#select-the-chip-and-read-the-data","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ds . reset (); ds . select ( addr ); ds . write ( 0x44 , 1 ); // start conversion, with parasite power on at the end delay ( 1000 ); // maybe 750ms is enough, maybe not // we might do a ds.depower() here, but the reset will take care of it. present = ds . reset (); ds . select ( addr ); ds . write ( 0xBE ); // Read Scratchpad Serial . print ( \" Data = \" ); Serial . print ( present , HEX ); Serial . print ( \" \" ); for ( i = 0 ; i < 9 ; i ++ ) { // we need 9 bytes data [ i ] = ds . read (); Serial . print ( data [ i ], HEX ); Serial . print ( \" \" ); } Serial . print ( \" CRC=\" ); Serial . print ( OneWire :: crc8 ( data , 8 ), HEX ); Serial . println ();","title":"Select the chip and read the data"},{"location":"development-boards/esp32/temperature/#convert-the-data","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Convert the data to actual temperature // because the result is a 16 bit signed integer, it should // be stored to an \"int16_t\" type, which is always 16 bits // even when compiled on a 32 bit processor. int16_t raw = ( data [ 1 ] << 8 ) | data [ 0 ]; byte cfg = ( data [ 4 ] & 0x60 ); // at lower res, the low bits are undefined, so let's zero them if ( cfg == 0x00 ) raw = raw & ~ 7 ; // 9 bit resolution, 93.75 ms else if ( cfg == 0x20 ) raw = raw & ~ 3 ; // 10 bit res, 187.5 ms else if ( cfg == 0x40 ) raw = raw & ~ 1 ; // 11 bit res, 375 ms //// default is 12 bit resolution, 750 ms conversion time celsius = ( float ) raw / 16.0 ; fahrenheit = celsius * 1.8 + 32.0 ;","title":"Convert the data"},{"location":"development-boards/esp32/temperature/#sample-project","text":"There are five example projects for the Arduino IDE which could be downloaded: DS18B20.ino ( download here ), DS18B20-Temperature-Control-Library-1.ino ( download here ), DS18B20-Temperature-Control-Library-2.ino ( download here ), Temp-Oled.ino ( download here ) and Temp-TFT.ino ( download here ).","title":"Sample project"},{"location":"development-boards/esp32/tft/","text":"Overview \u00b6 The component TFT supports a 2.8 inch TFT display with a resolution of 240*320 pixels.The display is not soldered on the board, but there is a 14 pin connector for a TFT display. The ILI9341 has been tested. Example There are four sample projects for the Arduino IDE which could be downloaded: TFT-Box3D ( download here ), TFT-Graphic-Test ( download here ), TFT-HelloWorld ( download here ) and TFT-HowToUseFonts ( download here ). And there are two examples for the Arduino IDE for using the touch functionality which could be downloaded: TFT-TouchBtn ( download here ) and TFT-TouchDraw ( download here ). ESP Board TFT SW311,SW314 Activating the component \u00b6 There are two dip switches for the component: SW311 and SW314 . If you want to use the TFT display all switches on SW311 have to be on on. If you additonally want to use the touchpad of the display all switch of SW314 have to be on. The following two tables shows the functions and the potential conflicts with other components SW311 \u00b6 All switches of SW311 have to be activated in order to use the display. Function SWITCH IO port Conflicts with Remarks CS 1 2 RGB LED , SW312, DIN; SD Card , SW406-4, DAT0 RESET 2 5 Micropohne , SW301-1, SD; RFID , SW303-6, SDA; Grove Digital1 , SW206-2, IO5 D/C 3 15 SD Card , SW406-6, CMD; Grove Digital3 , SW208-2, IO15 MOSI 4 23 RFID , SW303-4, MOSI; Motor Driver , SW304-2, STEP; TFT , SW314-4, T_DIN; mikroBus , SW405-1, MOSI SCK 5 18 TFT , SW314-2, T_CLK; mikroBus , SW405-3, SCK; Grove Digital4 , IO18, IO18 LED 6 VCC - SW314 \u00b6 All switches of SW311 and SW314 have to be activated in order to use the display with the touchpad . Function SWITCH IO port Conflicts with Remarks MISO 1 19 RFID , SW303-3, MISO; Gyro , SW310-3, SDA/SDI; OLED , SW309-2, SDA; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN 5; Grove I2C , SW203-1, S2C - SDA T_CLK 2 18 TFT , SW311-5, SCK; mikroBus , SW405-3, SCK; Grove Digital4 , IO18, IO18 T_CS 3 GND - T_DIN 4 23 RFID , SW303-4, MOSI; Motor Driver , SW304-2, STEP; TFT , SW311-4, MOSI; mikroBus , SW405-1, MOSI T_DO 5 33 Motor Driver , SW304-1, DIR; RGB , SW313, DIN; mikroBus , SW405-6, AN T_IRQ 6 not connected (NC) - Using the component \u00b6 Info Required libraries In order to use the component you need the Ucglib in Version 1.5.2. This version could be downloaded from GitHub . Additionally you could download from this site.. After the download it's necessary to add both libraries to your Arduino IDE. Open Sketch > Include Library > Add .ZIP Library ... and select the downloaded archive. Do it for both libraries. After a sucessful installation the menu Sketch > Include Library should contain an entry Ucglib in the category Contributed libraries . Including necessary libaries \u00b6 1 #include <Ucglib.h> Definition the appropriate constructor \u00b6 1 Ucglib_ILI9341_18x240x320_HWSPI ucg ( /*cd=*/ 5 , /*cs=*/ 33 , /*reset=*/ 17 ); Configuration \u00b6 1 2 3 4 5 6 void setup ( void ) { delay ( 1000 ); ucg . begin ( UCG_FONT_MODE_TRANSPARENT ); ucg . clearScreen (); } Writing on the display \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 void loop ( void ) { ucg . setFont ( ucg_font_ncenR12_tr ); ucg . setColor ( 255 , 255 , 255 ); ucg . setColor ( 1 , 255 , 0 , 0 ); ucg . setPrintPos ( 0 , 25 ); ucg . print ( \"Hello World!\" ); delay ( 500 ); } Sample project \u00b6 There are four sample projects for the Arduino IDE which could be downloaded: TFT-Box3D ( download here ), TFT-Graphic-Test ( download here ), TFT-HelloWorld ( download here ) and TFT-HowToUseFonts ( download here ). And there are two examples for the Arduino IDE for using the touch functionality which could be downloaded: TFT-TouchBtn ( download here ) and TFT-TouchDraw ( download here ).","title":"TFT"},{"location":"development-boards/esp32/tft/#overview","text":"The component TFT supports a 2.8 inch TFT display with a resolution of 240*320 pixels.The display is not soldered on the board, but there is a 14 pin connector for a TFT display. The ILI9341 has been tested. Example There are four sample projects for the Arduino IDE which could be downloaded: TFT-Box3D ( download here ), TFT-Graphic-Test ( download here ), TFT-HelloWorld ( download here ) and TFT-HowToUseFonts ( download here ). And there are two examples for the Arduino IDE for using the touch functionality which could be downloaded: TFT-TouchBtn ( download here ) and TFT-TouchDraw ( download here ). ESP Board TFT SW311,SW314","title":"Overview"},{"location":"development-boards/esp32/tft/#activating-the-component","text":"There are two dip switches for the component: SW311 and SW314 . If you want to use the TFT display all switches on SW311 have to be on on. If you additonally want to use the touchpad of the display all switch of SW314 have to be on. The following two tables shows the functions and the potential conflicts with other components","title":"Activating the component"},{"location":"development-boards/esp32/tft/#sw311","text":"All switches of SW311 have to be activated in order to use the display. Function SWITCH IO port Conflicts with Remarks CS 1 2 RGB LED , SW312, DIN; SD Card , SW406-4, DAT0 RESET 2 5 Micropohne , SW301-1, SD; RFID , SW303-6, SDA; Grove Digital1 , SW206-2, IO5 D/C 3 15 SD Card , SW406-6, CMD; Grove Digital3 , SW208-2, IO15 MOSI 4 23 RFID , SW303-4, MOSI; Motor Driver , SW304-2, STEP; TFT , SW314-4, T_DIN; mikroBus , SW405-1, MOSI SCK 5 18 TFT , SW314-2, T_CLK; mikroBus , SW405-3, SCK; Grove Digital4 , IO18, IO18 LED 6 VCC -","title":"SW311"},{"location":"development-boards/esp32/tft/#sw314","text":"All switches of SW311 and SW314 have to be activated in order to use the display with the touchpad . Function SWITCH IO port Conflicts with Remarks MISO 1 19 RFID , SW303-3, MISO; Gyro , SW310-3, SDA/SDI; OLED , SW309-2, SDA; mikroBus , SW405-2, MISO; Unit-Bus , SW200-2, CN212 - PIN 5; Grove I2C , SW203-1, S2C - SDA T_CLK 2 18 TFT , SW311-5, SCK; mikroBus , SW405-3, SCK; Grove Digital4 , IO18, IO18 T_CS 3 GND - T_DIN 4 23 RFID , SW303-4, MOSI; Motor Driver , SW304-2, STEP; TFT , SW311-4, MOSI; mikroBus , SW405-1, MOSI T_DO 5 33 Motor Driver , SW304-1, DIR; RGB , SW313, DIN; mikroBus , SW405-6, AN T_IRQ 6 not connected (NC) -","title":"SW314"},{"location":"development-boards/esp32/tft/#using-the-component","text":"Info Required libraries In order to use the component you need the Ucglib in Version 1.5.2. This version could be downloaded from GitHub . Additionally you could download from this site.. After the download it's necessary to add both libraries to your Arduino IDE. Open Sketch > Include Library > Add .ZIP Library ... and select the downloaded archive. Do it for both libraries. After a sucessful installation the menu Sketch > Include Library should contain an entry Ucglib in the category Contributed libraries .","title":"Using the component"},{"location":"development-boards/esp32/tft/#including-necessary-libaries","text":"1 #include <Ucglib.h>","title":"Including necessary libaries"},{"location":"development-boards/esp32/tft/#definition-the-appropriate-constructor","text":"1 Ucglib_ILI9341_18x240x320_HWSPI ucg ( /*cd=*/ 5 , /*cs=*/ 33 , /*reset=*/ 17 );","title":"Definition the appropriate constructor"},{"location":"development-boards/esp32/tft/#configuration","text":"1 2 3 4 5 6 void setup ( void ) { delay ( 1000 ); ucg . begin ( UCG_FONT_MODE_TRANSPARENT ); ucg . clearScreen (); }","title":"Configuration"},{"location":"development-boards/esp32/tft/#writing-on-the-display","text":"1 2 3 4 5 6 7 8 9 10 11 12 void loop ( void ) { ucg . setFont ( ucg_font_ncenR12_tr ); ucg . setColor ( 255 , 255 , 255 ); ucg . setColor ( 1 , 255 , 0 , 0 ); ucg . setPrintPos ( 0 , 25 ); ucg . print ( \"Hello World!\" ); delay ( 500 ); }","title":"Writing on the display"},{"location":"development-boards/esp32/tft/#sample-project","text":"There are four sample projects for the Arduino IDE which could be downloaded: TFT-Box3D ( download here ), TFT-Graphic-Test ( download here ), TFT-HelloWorld ( download here ) and TFT-HowToUseFonts ( download here ). And there are two examples for the Arduino IDE for using the touch functionality which could be downloaded: TFT-TouchBtn ( download here ) and TFT-TouchDraw ( download here ).","title":"Sample project"},{"location":"development-boards/esp32/unit-bus/","text":"Overview \u00b6 This is the connector for the Unit Bus. Example An example project for the Arduino IDE is coming soon. ESP Board unit Bus SW200,SW201 Activating the component \u00b6 Function SWITCH Connector IO port Conflicts with Remarks RX SW201-1 CN212 PIN 4 IO17 TX SW201-2 CN212 PIN 3 IO16 SDA SW200-1 CN212 PIN 5 IO19 SCL SW200-2 CN212 PIN 6 IO4 +5V CN212 PIN 2 +5V GND CN212 PIN 1 GND Using the component \u00b6 Sample project \u00b6 An example project for the Arduino IDE is coming soon.","title":"Unit-Bus"},{"location":"development-boards/esp32/unit-bus/#overview","text":"This is the connector for the Unit Bus. Example An example project for the Arduino IDE is coming soon. ESP Board unit Bus SW200,SW201","title":"Overview"},{"location":"development-boards/esp32/unit-bus/#activating-the-component","text":"Function SWITCH Connector IO port Conflicts with Remarks RX SW201-1 CN212 PIN 4 IO17 TX SW201-2 CN212 PIN 3 IO16 SDA SW200-1 CN212 PIN 5 IO19 SCL SW200-2 CN212 PIN 6 IO4 +5V CN212 PIN 2 +5V GND CN212 PIN 1 GND","title":"Activating the component"},{"location":"development-boards/esp32/unit-bus/#using-the-component","text":"","title":"Using the component"},{"location":"development-boards/esp32/unit-bus/#sample-project","text":"An example project for the Arduino IDE is coming soon.","title":"Sample project"},{"location":"development-boards/esp32/usb-programming/","text":"Overview \u00b6 The board is programmed via USB. For this, the board is providing a micro usb port. This port could be used to power the board, too. ESP Board usb programming USB Activating the component \u00b6 There is no special source code needed for activating this component. Using the component \u00b6 There is no special source code needed for using this component. At component POWER SUPPLY you need to set the switch to position ON if you want to use the board. Sample project \u00b6 There is no specific source code necessary.","title":"USB Programming"},{"location":"development-boards/esp32/usb-programming/#overview","text":"The board is programmed via USB. For this, the board is providing a micro usb port. This port could be used to power the board, too. ESP Board usb programming USB","title":"Overview"},{"location":"development-boards/esp32/usb-programming/#activating-the-component","text":"There is no special source code needed for activating this component.","title":"Activating the component"},{"location":"development-boards/esp32/usb-programming/#using-the-component","text":"There is no special source code needed for using this component. At component POWER SUPPLY you need to set the switch to position ON if you want to use the board.","title":"Using the component"},{"location":"development-boards/esp32/usb-programming/#sample-project","text":"There is no specific source code necessary.","title":"Sample project"},{"location":"development-boards/esp32/webserver/","text":"Overview \u00b6 The EBB ESP32 board is ideal for creating a webserver. Here you can find a few sample programs. Example There are four example projects for the Arduino IDE which could be downloaded: PacketMonitor32.ino ( download here ). WiFi traffic monitor. Shows the traffic of all nearby devices on the selected WiFi channel at OLED. ESP32_Webserver.ino ( download here ). A webserver. Show textbox from Webserver at OLED, switch RGB LEDs, and set background color of textboxes. Camera_Webserver.ino ( download here ). A camera webserver. Insert SSID and password and goto IP address of your EBB board to see the camera picture. EspEmail.ino ( download here ). An email client. When pressing the OK button the EBB board will send an email over smtp2go. ESP Board ESP-WROOM-32 SW210 Activating the component \u00b6 Active all four switches of SW210 . Using the component \u00b6 There is no special source code needed for using this component. Sample project \u00b6 There are four example projects for the Arduino IDE which could be downloaded: PacketMonitor32.ino ( download here ). WiFi traffic monitor. Shows the traffic of all nearby devices on the selected WiFi channel at OLED. ESP32_Webserver.ino ( download here ). A webserver. Show textbox from Webserver at OLED, switch RGB LEDs, and set background color of textboxes. Camera_Webserver.ino ( download here ). A camera webserver. Insert SSID and password and goto IP address of your EBB board to see the camera picture. EspEmail.ino ( download here ). An email client. When pressing the OK button the EBB board will send an email over smtp2go.","title":"Webserver"},{"location":"development-boards/esp32/webserver/#overview","text":"The EBB ESP32 board is ideal for creating a webserver. Here you can find a few sample programs. Example There are four example projects for the Arduino IDE which could be downloaded: PacketMonitor32.ino ( download here ). WiFi traffic monitor. Shows the traffic of all nearby devices on the selected WiFi channel at OLED. ESP32_Webserver.ino ( download here ). A webserver. Show textbox from Webserver at OLED, switch RGB LEDs, and set background color of textboxes. Camera_Webserver.ino ( download here ). A camera webserver. Insert SSID and password and goto IP address of your EBB board to see the camera picture. EspEmail.ino ( download here ). An email client. When pressing the OK button the EBB board will send an email over smtp2go. ESP Board ESP-WROOM-32 SW210","title":"Overview"},{"location":"development-boards/esp32/webserver/#activating-the-component","text":"Active all four switches of SW210 .","title":"Activating the component"},{"location":"development-boards/esp32/webserver/#using-the-component","text":"There is no special source code needed for using this component.","title":"Using the component"},{"location":"development-boards/esp32/webserver/#sample-project","text":"There are four example projects for the Arduino IDE which could be downloaded: PacketMonitor32.ino ( download here ). WiFi traffic monitor. Shows the traffic of all nearby devices on the selected WiFi channel at OLED. ESP32_Webserver.ino ( download here ). A webserver. Show textbox from Webserver at OLED, switch RGB LEDs, and set background color of textboxes. Camera_Webserver.ino ( download here ). A camera webserver. Insert SSID and password and goto IP address of your EBB board to see the camera picture. EspEmail.ino ( download here ). An email client. When pressing the OK button the EBB board will send an email over smtp2go.","title":"Sample project"},{"location":"development-boards/sensorio/","text":"SensorIO: IoT development Kit \u00b6 Introduction \u00b6 SensorIO is a powerful and versatile ARM Cortex\u00ae-M4 , mbed\u2122 -Enabled, Internet-of-Things development board targeted to the prototyping and development of connected devices. Its rich set of features makes it a versatile prototyping and development platform for Wi-Fi\u2122 connected products. It was designed with flexibility in mind, and unlike any other development board on the market, SensorIO has full support for Arduino R3 shields, Seedstudio's Grove modules and MikroBUS Click expansion boards. Documentation structure \u00b6 This guide will show you the capabilities of the board and walk you through the basic steps needed to create a connected device. The guide is broken-down in 3 parts for ease of use: Getting Started : if you are anxious and can't wait to start developing, here you will find a quick overview of the out-of-the-box application and will get you up-to-speed with the SensorIO development workflow and tooling setup. Hardware documentation details the different functional blocks and helps the users to understand the functionalities of the expansion interfaces, how to configure the software-controlled multiplexers, list all the peripherals exposed and pinouts and provides technical specifications. Firmware documentation : this section details sensors' drivers and all code facilities for easy SensorIO programming. Firmware flexibility Note that, even though the board is mbed\u2122 -Enabled, thus providing a quick and powerful firmware development platform and ecosystem, the onboard ST-Link\u2122-V2.1 interface can also be used to flash and debug firmware based on different RTOS' or bare-metal applications (i.e. FreeRTOS\u00ae + STMicro SDK ).","title":"SensorIO: IoT development Kit"},{"location":"development-boards/sensorio/#sensorio-iot-development-kit","text":"","title":"SensorIO: IoT development Kit"},{"location":"development-boards/sensorio/#introduction","text":"SensorIO is a powerful and versatile ARM Cortex\u00ae-M4 , mbed\u2122 -Enabled, Internet-of-Things development board targeted to the prototyping and development of connected devices. Its rich set of features makes it a versatile prototyping and development platform for Wi-Fi\u2122 connected products. It was designed with flexibility in mind, and unlike any other development board on the market, SensorIO has full support for Arduino R3 shields, Seedstudio's Grove modules and MikroBUS Click expansion boards.","title":"Introduction"},{"location":"development-boards/sensorio/#documentation-structure","text":"This guide will show you the capabilities of the board and walk you through the basic steps needed to create a connected device. The guide is broken-down in 3 parts for ease of use: Getting Started : if you are anxious and can't wait to start developing, here you will find a quick overview of the out-of-the-box application and will get you up-to-speed with the SensorIO development workflow and tooling setup. Hardware documentation details the different functional blocks and helps the users to understand the functionalities of the expansion interfaces, how to configure the software-controlled multiplexers, list all the peripherals exposed and pinouts and provides technical specifications. Firmware documentation : this section details sensors' drivers and all code facilities for easy SensorIO programming. Firmware flexibility Note that, even though the board is mbed\u2122 -Enabled, thus providing a quick and powerful firmware development platform and ecosystem, the onboard ST-Link\u2122-V2.1 interface can also be used to flash and debug firmware based on different RTOS' or bare-metal applications (i.e. FreeRTOS\u00ae + STMicro SDK ).","title":"Documentation structure"},{"location":"development-boards/sensorio/bma253/","text":"Accelerometer \u00b6 Description \u00b6 BMA253 is a digital, triaxial acceleration sensor. Communication is carried over I2C interface. Two independently programmed interrupt lines provide various motion triggers and asynchronous data readout capability. Part details \u00b6 Manufacturer: Bosch Sensortec GmbH Part number: BMA253 Datasheet: link Code example \u00b6 Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page. BMA253 driver \u00b6 Mbed OS driver for SensorIO can be found here: BMA253 on Github . Code \u00b6 1. Latest data In this example IRQ line is used to provide callback with most recent acceleration data. Please mind that sensor's callback is executed in the context of sensor's own thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \"I2C.h\" #include \"Serial.h\" #include \"InterruptIn.h\" #include \"DigitalOut.h\" #include \"bma253.h\" #include \"mbed_wait_api.h\" mbed :: Serial console ( USBTX , USBRX , 115200 ); events :: EventQueue scheduler ; constexpr uint8_t BMA253_I2C_ADDRESS = 0 b0011000 << 1 ; mbed :: InterruptIn bma253Irq1 ( ACCEL_INT1 ); mbed :: InterruptIn bma253Irq2 ( ACCEL_INT2 ); mbed :: I2C iic ( SENSORS_SDA , SENSORS_SCL ); Bma253 sensor ( iic , BMA253_I2C_ADDRESS , { & bma253Irq1 , & bma253Irq2 }); // executor in this context void measDone ( Bma253 :: Output & data ) { console . printf ( \"Accelerometer output: \\r\\n \" \"x = %f mg [new: %d] \\r\\n \" \"y = %f mg [new: %d] \\r\\n \" \"z = %f mg [new: %d] \\r\\n \" \"temp = %f C \\r\\n \" , data . x , data . newData [ 0 ], data . y , data . newData [ 1 ], data . z , data . newData [ 2 ], data . temp ); } // callback from driver in separate execution context void dataCallback ( Bma253 :: Output data ) { // not necessary if moving to scheduler execution context is not needed scheduler . call ( measDone , data ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); // enable sensor and configure interrupt to trigger on a new data event Bma253 :: Config accConfig ; accConfig . attachCallback ( Bma253 :: IrqLine :: LINE_1 , & dataCallback ) . enableEvent ( Bma253 :: IrqLine :: LINE_1 , Bma253 :: Event :: NEW_DATA ); const bool configOk = sensor . setConfig ( accConfig ); if ( configOk ) { console . printf ( \"Sensor configured correctly \\n \" ); sensor . enable (); } else { console . printf ( \"Sensor configuration failed \\n \" ); } // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here . 2. Tap detection ESD or short-circuit damage possible! This example requires touching the board. To avoid damage it has to be done with keeping in mind ESD protection rules. Avoid touching any conductive parts or elements. It is advised to 'tap' only plastic and safe parts of the board, like mikroBUS black plastic pin port. In this example IRQ line is used to provide data when tap is detected. Please change sensor config code lines from main function in previous example to: 1 2 3 4 Bma253 :: Config accConfig ; accConfig . bw = Bma253 :: FilterBandwidth :: BW_500_Hz ; accConfig . attachCallback ( Bma253 :: IrqLine :: LINE_1 , & dataCallback ) . enableEvent ( Bma253 :: IrqLine :: LINE_1 , Bma253 :: Event :: SINGLE_TAP ); SINGLE_TAP config enables tap detection event. FilterBandwidth::BW_500_Hz is a non-default setting for filtering acceleration data used for tap detection. Higher bandwidth is desirable for detecting dynamic events Try taping gently safe parts on the board and observe output.","title":"Accelerometer"},{"location":"development-boards/sensorio/bma253/#accelerometer","text":"","title":"Accelerometer"},{"location":"development-boards/sensorio/bma253/#description","text":"BMA253 is a digital, triaxial acceleration sensor. Communication is carried over I2C interface. Two independently programmed interrupt lines provide various motion triggers and asynchronous data readout capability.","title":"Description"},{"location":"development-boards/sensorio/bma253/#part-details","text":"Manufacturer: Bosch Sensortec GmbH Part number: BMA253 Datasheet: link","title":"Part details"},{"location":"development-boards/sensorio/bma253/#code-example","text":"Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page.","title":"Code example"},{"location":"development-boards/sensorio/bma253/#bma253-driver","text":"Mbed OS driver for SensorIO can be found here: BMA253 on Github .","title":"BMA253 driver"},{"location":"development-boards/sensorio/bma253/#code","text":"1. Latest data In this example IRQ line is used to provide callback with most recent acceleration data. Please mind that sensor's callback is executed in the context of sensor's own thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \"I2C.h\" #include \"Serial.h\" #include \"InterruptIn.h\" #include \"DigitalOut.h\" #include \"bma253.h\" #include \"mbed_wait_api.h\" mbed :: Serial console ( USBTX , USBRX , 115200 ); events :: EventQueue scheduler ; constexpr uint8_t BMA253_I2C_ADDRESS = 0 b0011000 << 1 ; mbed :: InterruptIn bma253Irq1 ( ACCEL_INT1 ); mbed :: InterruptIn bma253Irq2 ( ACCEL_INT2 ); mbed :: I2C iic ( SENSORS_SDA , SENSORS_SCL ); Bma253 sensor ( iic , BMA253_I2C_ADDRESS , { & bma253Irq1 , & bma253Irq2 }); // executor in this context void measDone ( Bma253 :: Output & data ) { console . printf ( \"Accelerometer output: \\r\\n \" \"x = %f mg [new: %d] \\r\\n \" \"y = %f mg [new: %d] \\r\\n \" \"z = %f mg [new: %d] \\r\\n \" \"temp = %f C \\r\\n \" , data . x , data . newData [ 0 ], data . y , data . newData [ 1 ], data . z , data . newData [ 2 ], data . temp ); } // callback from driver in separate execution context void dataCallback ( Bma253 :: Output data ) { // not necessary if moving to scheduler execution context is not needed scheduler . call ( measDone , data ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); // enable sensor and configure interrupt to trigger on a new data event Bma253 :: Config accConfig ; accConfig . attachCallback ( Bma253 :: IrqLine :: LINE_1 , & dataCallback ) . enableEvent ( Bma253 :: IrqLine :: LINE_1 , Bma253 :: Event :: NEW_DATA ); const bool configOk = sensor . setConfig ( accConfig ); if ( configOk ) { console . printf ( \"Sensor configured correctly \\n \" ); sensor . enable (); } else { console . printf ( \"Sensor configuration failed \\n \" ); } // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here . 2. Tap detection ESD or short-circuit damage possible! This example requires touching the board. To avoid damage it has to be done with keeping in mind ESD protection rules. Avoid touching any conductive parts or elements. It is advised to 'tap' only plastic and safe parts of the board, like mikroBUS black plastic pin port. In this example IRQ line is used to provide data when tap is detected. Please change sensor config code lines from main function in previous example to: 1 2 3 4 Bma253 :: Config accConfig ; accConfig . bw = Bma253 :: FilterBandwidth :: BW_500_Hz ; accConfig . attachCallback ( Bma253 :: IrqLine :: LINE_1 , & dataCallback ) . enableEvent ( Bma253 :: IrqLine :: LINE_1 , Bma253 :: Event :: SINGLE_TAP ); SINGLE_TAP config enables tap detection event. FilterBandwidth::BW_500_Hz is a non-default setting for filtering acceleration data used for tap detection. Higher bandwidth is desirable for detecting dynamic events Try taping gently safe parts on the board and observe output.","title":"Code"},{"location":"development-boards/sensorio/button/","text":"User button \u00b6 Description \u00b6 SensorIO has one button that can be used by firmware. Code example \u00b6 Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page. Button driver \u00b6 Button does not need external driver - only Mbed OS built-in InterruptIn class is required. Code \u00b6 Pin definitions \u00b6 1 2 USER_BUTTON = PC_13 , BUTTON1 = USER_BUTTON , Example \u00b6 In this example user button is used to turn LD2 on and off. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \"mbed_events.h\" #include \"DigitalOut.h\" #include \"InterruptIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); events :: EventQueue scheduler ; mbed :: DigitalOut green ( RGB_GREEN ); void ledStatus ( int status ) { console . printf ( \"Green Led is %s \\r\\n \" , ( status == 1 ) ? \"ON\" : \"OFF\" ); } void buttonPressed () { // toggle led state green = ! green ; // log led state via Serial (via EventLoop) scheduler . call ( & ledStatus , green ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); mbed :: InterruptIn button ( USER_BUTTON ); // attach function to button press button . fall ( & buttonPressed ); // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here .","title":"User button"},{"location":"development-boards/sensorio/button/#user-button","text":"","title":"User button"},{"location":"development-boards/sensorio/button/#description","text":"SensorIO has one button that can be used by firmware.","title":"Description"},{"location":"development-boards/sensorio/button/#code-example","text":"Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page.","title":"Code example"},{"location":"development-boards/sensorio/button/#button-driver","text":"Button does not need external driver - only Mbed OS built-in InterruptIn class is required.","title":"Button driver"},{"location":"development-boards/sensorio/button/#code","text":"","title":"Code"},{"location":"development-boards/sensorio/button/#pin-definitions","text":"1 2 USER_BUTTON = PC_13 , BUTTON1 = USER_BUTTON ,","title":"Pin definitions"},{"location":"development-boards/sensorio/button/#example","text":"In this example user button is used to turn LD2 on and off. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \"mbed_events.h\" #include \"DigitalOut.h\" #include \"InterruptIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); events :: EventQueue scheduler ; mbed :: DigitalOut green ( RGB_GREEN ); void ledStatus ( int status ) { console . printf ( \"Green Led is %s \\r\\n \" , ( status == 1 ) ? \"ON\" : \"OFF\" ); } void buttonPressed () { // toggle led state green = ! green ; // log led state via Serial (via EventLoop) scheduler . call ( & ledStatus , green ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); mbed :: InterruptIn button ( USER_BUTTON ); // attach function to button press button . fall ( & buttonPressed ); // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here .","title":"Example"},{"location":"development-boards/sensorio/code-setup/","text":"Basic setup for all firmware examples \u00b6 All firmware examples in this documentation are based on Mbed OS . Tools These steps assume that mbed-cli and GNU Arm Embedded Toolchain are already installed. For instructions on tooling setup visit Tooling setup . Using template repository \u00b6 The easiest way to start is to clone SensorIO template repository: 1 git clone https://github.com/slashdevteam/sensorio-template.git sensorio-example and initialize submodules: 1 2 cd sensorio-example git submodule update --init --recursive add any necessary drivers, for example for light sensor: 1 git clone https://github.com/slashdevteam/ltr303-mbed.git edit main.cpp , compile and flash . Manually \u00b6 Steps needed to compile Mbed OS based firmware for SensorIO: Create a new directory for your project, for example: 1 mkdir sensorio-example Enter this new directory, for example: 1 cd sensorio-example Get Mbed OS source: 1 2 git clone https://github.com/slashdevteam/mbed-os.git ` git checkout -t origin/sensorio-dev-target Mbed OS repository SensorIO is currently in the process of Mbed Enabled certification, hence the need to clone a fork of Mbed OS. Get appropriate drivers, for example: 1 git clone https://github.com/slashdevteam/ltr303-mbed.git Download or copy-paste example main.cpp into sensorio-example directory. Download compilation profile: release or debug . Initialize Mbed OS project: 1 mbed config root . Select SensorIO as build target: 1 mbed target SENSORIO Select GNU GCC Toolchain as default: 1 mbed toolchain GCC_ARM Compile firmware example: 1 mbed compile --profile debug.json Flash binary and enjoy!","title":"Basic setup for all firmware examples"},{"location":"development-boards/sensorio/code-setup/#basic-setup-for-all-firmware-examples","text":"All firmware examples in this documentation are based on Mbed OS . Tools These steps assume that mbed-cli and GNU Arm Embedded Toolchain are already installed. For instructions on tooling setup visit Tooling setup .","title":"Basic setup for all firmware examples"},{"location":"development-boards/sensorio/code-setup/#using-template-repository","text":"The easiest way to start is to clone SensorIO template repository: 1 git clone https://github.com/slashdevteam/sensorio-template.git sensorio-example and initialize submodules: 1 2 cd sensorio-example git submodule update --init --recursive add any necessary drivers, for example for light sensor: 1 git clone https://github.com/slashdevteam/ltr303-mbed.git edit main.cpp , compile and flash .","title":"Using template repository"},{"location":"development-boards/sensorio/code-setup/#manually","text":"Steps needed to compile Mbed OS based firmware for SensorIO: Create a new directory for your project, for example: 1 mkdir sensorio-example Enter this new directory, for example: 1 cd sensorio-example Get Mbed OS source: 1 2 git clone https://github.com/slashdevteam/mbed-os.git ` git checkout -t origin/sensorio-dev-target Mbed OS repository SensorIO is currently in the process of Mbed Enabled certification, hence the need to clone a fork of Mbed OS. Get appropriate drivers, for example: 1 git clone https://github.com/slashdevteam/ltr303-mbed.git Download or copy-paste example main.cpp into sensorio-example directory. Download compilation profile: release or debug . Initialize Mbed OS project: 1 mbed config root . Select SensorIO as build target: 1 mbed target SENSORIO Select GNU GCC Toolchain as default: 1 mbed toolchain GCC_ARM Compile firmware example: 1 mbed compile --profile debug.json Flash binary and enjoy!","title":"Manually"},{"location":"development-boards/sensorio/compilation/","text":"Mbed OS based firmware compilation \u00b6 Once Mbed OS project is set up , firmware can be compiled with simple command from terminal: 1 mbed compile --profile debug.json and the resulting binaries can be found in ./BUILD/SENSORIO/GCC_ARM-DEBUG/ directory. For optimized/release binary build command uses a different profile: 1 mbed compile --profile release.json and the resulting binaries can be found in ./BUILD/SENSORIO/GCC_ARM/ directory.","title":"Mbed OS based firmware compilation"},{"location":"development-boards/sensorio/compilation/#mbed-os-based-firmware-compilation","text":"Once Mbed OS project is set up , firmware can be compiled with simple command from terminal: 1 mbed compile --profile debug.json and the resulting binaries can be found in ./BUILD/SENSORIO/GCC_ARM-DEBUG/ directory. For optimized/release binary build command uses a different profile: 1 mbed compile --profile release.json and the resulting binaries can be found in ./BUILD/SENSORIO/GCC_ARM/ directory.","title":"Mbed OS based firmware compilation"},{"location":"development-boards/sensorio/datasheet/","text":"Technical specifications \u00b6 Absolute maximum ratings \u00b6 Parameter Min Typ Max Unit Supply Input Voltage (USB) -0.3 - +5.7 V Supply Output Current - MikroBUS +5V - - 2.0 A Supply Output Current - MikroBUS +3.3V - - 2.0 A Supply Output Current - Arduino +5V - - 1.0 A Supply Output Current - Arduino +3.3V - - 2.0 A Supply Output Current - Grove Vcc output - - 1.0 A Storage Temperature -40 - +85 \u00b0C Recommended operating conditions \u00b6 Parameter Min Typ Max Unit Supply Input Voltage (USB) +2.5 +5.0 +5.5 V Supply Input Current (WiFi off, LEDs & display on) - 70 90 mA Supply Input Current (WiFi, LEDs & display on) - 105 150 mA Power consumption (WiFi, LEDs & display on) - 0.5 0.75 W Operation Temperature -20 - +60 \u00b0C Humidity Range / non-condensing - - 95 %RH STM32F413 operating frequency - 100 (1) 100 MHz (1) default configuration for the mbed target. Wi-Fi Specifications (TI CC3120R) \u00b6 Wi-Fi modes: 802.11b/g/n Security: WPA2 Personal and Enterprise Security: WEP, WPA/WPA2 PSK, WPA2 Enterprise (802.1x) Secure Sockets: SSLv3, TLS1.0/1.1/TLS1.2 (integrated on the CC3210, newer versions can be further supported from the main MCU application) Secure Key Storage Software Tamper Detection TX Power: 18.0dBm@1DSSS 14.5dBm@54OFDM RX Sensitivity: -96.0dBm @ 1DSSS -74.5 dBm @ 54 OFDM On-board PCB Antenna: Return loss @ WiFi bands (2.412-2.472 GHz): -19.4 dB max. (VSWR: 1.24:1) Bandwidth (defined @ VSWR 2:1): 200 MHz External u-Fl connector: Characteristic impedance: 50 \u03a9 Maximum output power: 18.0dBm I/O Characteristics \u00b6 All I/Os are CMOS and TTL compliant. The following characteristics are based on the STM32F423ZH datasheet: Parameter Min Typ Max Unit Input logic LOW level voltage - - 0.9 V Input logic HIGH level voltage 2.3 - - V Input hysteresis 0.1 - - V Weak pull-up equivalent resistor 30 40 50 k\u03a9 Weak pull-down equivalent resistor 30 40 50 k\u03a9 I/O pin capacitance - 5 - pF Notes: For I/O timings and maximum operating frequency of the different peripherals (I2C, SPI, UART, I2S) please refer to the STM32F413ZH datasheet . The main oscillator is driven by the external crystal Y4 (16.000 MHz \u00b1 10 p.p.m.). The low frequency oscillator is driven by the crystal Y3 (32.768 kHz \u00b1 20 p.p.m.). Solid-state outputs characteristics \u00b6 Toshiba TLP241A : Parameter Min Typ Max Unit ON-state current (continuous) - - 2 A ON-state current (pulsed, t=100 mseg, duty=10%) - - 6 A ON-state resistance (continuous) - 90 150 m\u03a9 Isolation voltage 5,000 - - V Maximum DC voltage (1) - - 26 V[dc] Maximum AC voltage (1) - - 20 V[rms] (1) Limited by the protection varistors (R63 and R69). Mechanical Dimensions \u00b6 Dimension Value Unit Comment External dimensions 100.97 x 65.79 x 19 mm Mounting holes diameter 3.25 mm for M3 screws size Mounting holes distances 93.22 (X), 58.17 (Y) mm","title":"Datasheet"},{"location":"development-boards/sensorio/datasheet/#technical-specifications","text":"","title":"Technical specifications"},{"location":"development-boards/sensorio/datasheet/#absolute-maximum-ratings","text":"Parameter Min Typ Max Unit Supply Input Voltage (USB) -0.3 - +5.7 V Supply Output Current - MikroBUS +5V - - 2.0 A Supply Output Current - MikroBUS +3.3V - - 2.0 A Supply Output Current - Arduino +5V - - 1.0 A Supply Output Current - Arduino +3.3V - - 2.0 A Supply Output Current - Grove Vcc output - - 1.0 A Storage Temperature -40 - +85 \u00b0C","title":"Absolute maximum ratings"},{"location":"development-boards/sensorio/datasheet/#recommended-operating-conditions","text":"Parameter Min Typ Max Unit Supply Input Voltage (USB) +2.5 +5.0 +5.5 V Supply Input Current (WiFi off, LEDs & display on) - 70 90 mA Supply Input Current (WiFi, LEDs & display on) - 105 150 mA Power consumption (WiFi, LEDs & display on) - 0.5 0.75 W Operation Temperature -20 - +60 \u00b0C Humidity Range / non-condensing - - 95 %RH STM32F413 operating frequency - 100 (1) 100 MHz (1) default configuration for the mbed target.","title":"Recommended operating conditions"},{"location":"development-boards/sensorio/datasheet/#wi-fi-specifications-ti-cc3120r","text":"Wi-Fi modes: 802.11b/g/n Security: WPA2 Personal and Enterprise Security: WEP, WPA/WPA2 PSK, WPA2 Enterprise (802.1x) Secure Sockets: SSLv3, TLS1.0/1.1/TLS1.2 (integrated on the CC3210, newer versions can be further supported from the main MCU application) Secure Key Storage Software Tamper Detection TX Power: 18.0dBm@1DSSS 14.5dBm@54OFDM RX Sensitivity: -96.0dBm @ 1DSSS -74.5 dBm @ 54 OFDM On-board PCB Antenna: Return loss @ WiFi bands (2.412-2.472 GHz): -19.4 dB max. (VSWR: 1.24:1) Bandwidth (defined @ VSWR 2:1): 200 MHz External u-Fl connector: Characteristic impedance: 50 \u03a9 Maximum output power: 18.0dBm","title":"Wi-Fi Specifications (TI CC3120R)"},{"location":"development-boards/sensorio/datasheet/#io-characteristics","text":"All I/Os are CMOS and TTL compliant. The following characteristics are based on the STM32F423ZH datasheet: Parameter Min Typ Max Unit Input logic LOW level voltage - - 0.9 V Input logic HIGH level voltage 2.3 - - V Input hysteresis 0.1 - - V Weak pull-up equivalent resistor 30 40 50 k\u03a9 Weak pull-down equivalent resistor 30 40 50 k\u03a9 I/O pin capacitance - 5 - pF Notes: For I/O timings and maximum operating frequency of the different peripherals (I2C, SPI, UART, I2S) please refer to the STM32F413ZH datasheet . The main oscillator is driven by the external crystal Y4 (16.000 MHz \u00b1 10 p.p.m.). The low frequency oscillator is driven by the crystal Y3 (32.768 kHz \u00b1 20 p.p.m.).","title":"I/O Characteristics"},{"location":"development-boards/sensorio/datasheet/#solid-state-outputs-characteristics","text":"Toshiba TLP241A : Parameter Min Typ Max Unit ON-state current (continuous) - - 2 A ON-state current (pulsed, t=100 mseg, duty=10%) - - 6 A ON-state resistance (continuous) - 90 150 m\u03a9 Isolation voltage 5,000 - - V Maximum DC voltage (1) - - 26 V[dc] Maximum AC voltage (1) - - 20 V[rms] (1) Limited by the protection varistors (R63 and R69).","title":"Solid-state outputs characteristics"},{"location":"development-boards/sensorio/datasheet/#mechanical-dimensions","text":"Dimension Value Unit Comment External dimensions 100.97 x 65.79 x 19 mm Mounting holes diameter 3.25 mm for M3 screws size Mounting holes distances 93.22 (X), 58.17 (Y) mm","title":"Mechanical Dimensions"},{"location":"development-boards/sensorio/debugging/","text":"Depending on your needs SensorIO offers several ways of monitoring and debugging your firmware. With SensorIO only \u00b6 RGB Led \u00b6 On-board RGB LED ( LD1 ) can be programmed to show firmware status. Detailed usage is covered on LED page. OLED display \u00b6 Firmware can also use on-board OLED display to show pictures and/or text messages. Detailed usage is covered on OLED page. With PC \u00b6 Logging \u00b6 Once SensorIO is connected to PC with USB cable it should be visible both as a removable drive and as a serial port (usually called COMX on Windows and ttyUSBX on macOS/Linux). Terminal emulators, like PuTTY , CoolTerm or picocom and many others, can connect to SensorIO serial port and display messages sent from firmware. By default SensorIO uses 115200 baudrate. Mbed OS makes it easy to use serial port in firmware: Include Mbed OS Serial header: 1 #include \"Serial.h\" Create Serial object: 1 mbed :: Serial pc ( USBTX , USBRX , 115200 ); Use this object to send text to PC: 1 pc . printf ( \"This is SensorIO!\" ); Full Serial documentation is available on Mbed OS pages . GDB \u00b6 Debugging with GDB is more advanced than previous methods, but offers complete control and insight into firmware execution. Build type For correct operation firmware should be build with debug profile. In order to start debugging with GDB: Make sure that SensorIO is connected to PC with USB cable. If using external debugger it should also be connected to both PC and SensorIO JTAG/SWD port. Start GDB server (a program that will allow GDB to communicate with debugger) in first console: for OpenOCD and on-board ST-Link V2: 1 openocd -f stlink-v2.cfg -f stm32f4x_stlink.cfg for JLink: 1 JLinkGDBServer -if SWD -device STM32F413ZH -speed 8000 Start GDB in another console: 1 arm-none-eabi-gdb /path/to/firmware.elf Binary extension Please note that for GDB to know most about firmware under debug it has to use .elf binary with debug symbols. Connect from GDB (second console) to GDB server: for OpenOCD and on-board ST-Link V2: 1 target extended-remote:3333 for JLink: 1 target extended-remote:2331 GDB server ports Ports used by GDB servers are configurable. Numbers - 3333 and 2331 - in examples reflect default ports for OpenOCD and JLink respectively. Allow GDB to sync to firmware state by allowing it to run, by executing following command from GDB: 1 continue Stop firmware execution by pressing CTRL+C in GDB. Flash the binary to SensorIO from GDB: 1 load Flashing Whenever you change source code and recompiled binary has the same name/path as in step 4, it can be flashed with the same load command. As a bonus GDB will automatically pick up and understand all changes - no need to quit GDB! Now firmware is redy for debugging - setting breakpoints, stepping through code execution and watching variables' values. Here is a good GDB tutorial to get started.","title":"Debugging"},{"location":"development-boards/sensorio/debugging/#with-sensorio-only","text":"","title":"With SensorIO only"},{"location":"development-boards/sensorio/debugging/#rgb-led","text":"On-board RGB LED ( LD1 ) can be programmed to show firmware status. Detailed usage is covered on LED page.","title":"RGB Led"},{"location":"development-boards/sensorio/debugging/#oled-display","text":"Firmware can also use on-board OLED display to show pictures and/or text messages. Detailed usage is covered on OLED page.","title":"OLED display"},{"location":"development-boards/sensorio/debugging/#with-pc","text":"","title":"With PC"},{"location":"development-boards/sensorio/debugging/#logging","text":"Once SensorIO is connected to PC with USB cable it should be visible both as a removable drive and as a serial port (usually called COMX on Windows and ttyUSBX on macOS/Linux). Terminal emulators, like PuTTY , CoolTerm or picocom and many others, can connect to SensorIO serial port and display messages sent from firmware. By default SensorIO uses 115200 baudrate. Mbed OS makes it easy to use serial port in firmware: Include Mbed OS Serial header: 1 #include \"Serial.h\" Create Serial object: 1 mbed :: Serial pc ( USBTX , USBRX , 115200 ); Use this object to send text to PC: 1 pc . printf ( \"This is SensorIO!\" ); Full Serial documentation is available on Mbed OS pages .","title":"Logging"},{"location":"development-boards/sensorio/debugging/#gdb","text":"Debugging with GDB is more advanced than previous methods, but offers complete control and insight into firmware execution. Build type For correct operation firmware should be build with debug profile. In order to start debugging with GDB: Make sure that SensorIO is connected to PC with USB cable. If using external debugger it should also be connected to both PC and SensorIO JTAG/SWD port. Start GDB server (a program that will allow GDB to communicate with debugger) in first console: for OpenOCD and on-board ST-Link V2: 1 openocd -f stlink-v2.cfg -f stm32f4x_stlink.cfg for JLink: 1 JLinkGDBServer -if SWD -device STM32F413ZH -speed 8000 Start GDB in another console: 1 arm-none-eabi-gdb /path/to/firmware.elf Binary extension Please note that for GDB to know most about firmware under debug it has to use .elf binary with debug symbols. Connect from GDB (second console) to GDB server: for OpenOCD and on-board ST-Link V2: 1 target extended-remote:3333 for JLink: 1 target extended-remote:2331 GDB server ports Ports used by GDB servers are configurable. Numbers - 3333 and 2331 - in examples reflect default ports for OpenOCD and JLink respectively. Allow GDB to sync to firmware state by allowing it to run, by executing following command from GDB: 1 continue Stop firmware execution by pressing CTRL+C in GDB. Flash the binary to SensorIO from GDB: 1 load Flashing Whenever you change source code and recompiled binary has the same name/path as in step 4, it can be flashed with the same load command. As a bonus GDB will automatically pick up and understand all changes - no need to quit GDB! Now firmware is redy for debugging - setting breakpoints, stepping through code execution and watching variables' values. Here is a good GDB tutorial to get started.","title":"GDB"},{"location":"development-boards/sensorio/demo-app/","text":"Demo Application \u00b6","title":"Demo Application"},{"location":"development-boards/sensorio/demo-app/#demo-application","text":"","title":"Demo Application"},{"location":"development-boards/sensorio/flashing/","text":"Flashing SensorIO \u00b6 SensorIO offers several methods of flashing. Example commands assume that binary is built with Mbed OS, however most of these methods work with any binary built for SensorIO MCU. For all methods SensorIO has to be connected to computer with a USB cable. Drag & Drop \u00b6 An easy way to flash new firmware to SensorIO is to drag the binary from build folder (for Mbed OS it is usually located in ./BUILD/SENSORIO/GCC_ARM-DEBUG/ directory) and drop it to SENSORIO removable drive. Once the copy is complete removable drive will disappear and LD1 LED will blink red and green. After a few seconds removable drive should reappear and SensorIO will start executing new firmware. Copy from terminal \u00b6 Of course, Drag & drop can be executed directly from terminal: 1 cp /path/to/firmware.bin /path/to/SENSORIO After this command, SensorIO should behave the same way as in Drag & drop . On some operating systems syncing (via sync ) and/or explicit SENSORIO removal might be required. OpenOCD \u00b6 With a correctly installed OpenOCD binary can be flash from command line: 1 openocd -f stlink-v2.cfg -f stm32f4x_stlink.cfg -c \"program ./path/to/firmware.elf verify reset exit\" This command assumes that SensorIO is connected only via USB cable and flashing is done with on-board ST-Link V2 debugger. For other debuggers (like Segger JLink) configuration files have to be adjusted. Segger JLink \u00b6 SensorIO has a separate 10-pin JTAG/SWD header that allows connecting external debuggers to the board. Once Segger JLink debugger is connected to this header and Segger tools are installed, binary can be quickly flashed from terminal: Create a sensorio.jlink command file with following contents (needed only once): 1 2 3 4 5 6 7 8 si 1 speed 1000 device STM32F413ZH halt loadfile path/to/firmware.hex r g q Flash new binary with JLink application: 1 JLinkExe -commanderscript sensorio.jlink GDB \u00b6 Binaries can also be flash from GDB prompt. Instructions are on Debugging with GDB page. Mbed CLI \u00b6 Mbed CLI This method will work only for binaries built with Mbed OS and will be available once SensorIO Mbed Enabled certification is complete. To compile and flash new Mbed OS based firmware to SensorIO execute this command (after proper Code setup ): 1 mbed compile --flash --profile debug.json","title":"Flashing SensorIO"},{"location":"development-boards/sensorio/flashing/#flashing-sensorio","text":"SensorIO offers several methods of flashing. Example commands assume that binary is built with Mbed OS, however most of these methods work with any binary built for SensorIO MCU. For all methods SensorIO has to be connected to computer with a USB cable.","title":"Flashing SensorIO"},{"location":"development-boards/sensorio/flashing/#drag-drop","text":"An easy way to flash new firmware to SensorIO is to drag the binary from build folder (for Mbed OS it is usually located in ./BUILD/SENSORIO/GCC_ARM-DEBUG/ directory) and drop it to SENSORIO removable drive. Once the copy is complete removable drive will disappear and LD1 LED will blink red and green. After a few seconds removable drive should reappear and SensorIO will start executing new firmware.","title":"Drag &amp; Drop"},{"location":"development-boards/sensorio/flashing/#copy-from-terminal","text":"Of course, Drag & drop can be executed directly from terminal: 1 cp /path/to/firmware.bin /path/to/SENSORIO After this command, SensorIO should behave the same way as in Drag & drop . On some operating systems syncing (via sync ) and/or explicit SENSORIO removal might be required.","title":"Copy from terminal"},{"location":"development-boards/sensorio/flashing/#openocd","text":"With a correctly installed OpenOCD binary can be flash from command line: 1 openocd -f stlink-v2.cfg -f stm32f4x_stlink.cfg -c \"program ./path/to/firmware.elf verify reset exit\" This command assumes that SensorIO is connected only via USB cable and flashing is done with on-board ST-Link V2 debugger. For other debuggers (like Segger JLink) configuration files have to be adjusted.","title":"OpenOCD"},{"location":"development-boards/sensorio/flashing/#segger-jlink","text":"SensorIO has a separate 10-pin JTAG/SWD header that allows connecting external debuggers to the board. Once Segger JLink debugger is connected to this header and Segger tools are installed, binary can be quickly flashed from terminal: Create a sensorio.jlink command file with following contents (needed only once): 1 2 3 4 5 6 7 8 si 1 speed 1000 device STM32F413ZH halt loadfile path/to/firmware.hex r g q Flash new binary with JLink application: 1 JLinkExe -commanderscript sensorio.jlink","title":"Segger JLink"},{"location":"development-boards/sensorio/flashing/#gdb","text":"Binaries can also be flash from GDB prompt. Instructions are on Debugging with GDB page.","title":"GDB"},{"location":"development-boards/sensorio/flashing/#mbed-cli","text":"Mbed CLI This method will work only for binaries built with Mbed OS and will be available once SensorIO Mbed Enabled certification is complete. To compile and flash new Mbed OS based firmware to SensorIO execute this command (after proper Code setup ): 1 mbed compile --flash --profile debug.json","title":"Mbed CLI"},{"location":"development-boards/sensorio/fw-overview/","text":"Peripherals \u00b6 OLED display - SSD1306 128x32 pixels Relays - TLP241A RGB Led User button Multiplexers for Grove and Arduino connectors Sensors \u00b6 I2C All on-board sensors are attached to the same I2C bus - I2C2 . Pin names are defined as SENSORS_SDA and SENSORS_SCL ( PF_0 and PF_1 accordingly). Luminosity - LTR303-ALS Acceleration - BMA253","title":"Fw overview"},{"location":"development-boards/sensorio/fw-overview/#peripherals","text":"OLED display - SSD1306 128x32 pixels Relays - TLP241A RGB Led User button Multiplexers for Grove and Arduino connectors","title":"Peripherals"},{"location":"development-boards/sensorio/fw-overview/#sensors","text":"I2C All on-board sensors are attached to the same I2C bus - I2C2 . Pin names are defined as SENSORS_SDA and SENSORS_SCL ( PF_0 and PF_1 accordingly). Luminosity - LTR303-ALS Acceleration - BMA253","title":"Sensors"},{"location":"development-boards/sensorio/hardware-overview/","text":"Hardware description \u00b6 In order to maximize the flexibility of use for different applications, all the expansion interfaces have software-configurable support for 3.3V and 5V boards, providing compatibility for more than 500+ different expansion boards available from various manufacturers. The core of the SensorIO board is the ST-Micro STM32F413ZH , a powerful ARM Cortex\u00ae-M4 MCU with a very rich set of peripherals presented into a 144-balls 10x10mm BGA chip. Features \u00b6 This is an overview of the main components and features: STM32F413ZH MCU, ARM Cortex\u2122-M4 , 1.5 Mbytes of Flash memory, 320 Kbytes of RAM, FPU unit w/ DSP instructions, 125 DMIPS @ 100 MHz. WiFi: CC3120R SimpleLink\u00ae \u2028Wi-Fi 802.11b/g/n 128x32 0.91\u2019\u2019 OLED display LiteOn LTR303-ALS ambient light sensor Bosch Sensortec BMA253 : 3-axis accelerometer with motion triggered interrups Bosch Sensortec BME680 : Environmental sensor (temperature, humidity, barometric pressure, VOC air quality) 2x opto-relay outputs ( Toshiba TLP241A , 2A/24Vac) 2x MikroBUS\u2122 expansion sockets Arduino\u2122 R3 socket with 3.3V & 5V support on I/Os and Analog Inputs 2x Grove\u2122 connectors Software programable individual 3.3V / 5V switches Each connector provides software configurable UART, I2C, PWM, GPIO and Analog interfacing Onboard ST-Link\u2122/V2-1 debugger - mbed\u2122 compatible Micro SD/MMC flash memory socket (for datalogging, storing credentials, etc.) User & reset buttons, RGB color LED Total peripherals exposed on the expansion connectors: 8 x UART interfaces 3 x I2C buses 2 x SPI buses 2 x I2S interfaces 3 x CAN buses 19 x PWM capable outputs 15 x Analog input channels 2 x Isolated, high-power outputs (solid state relays) 47 x Total exposed GPIOs! Block Diagram \u00b6 USB functions: Power input (1) Debugging port (GDB compatible) Virtual Serial COMM Mass storage programming (simply drag & drop to flash) (1) The board can be powered through the on-board USB Micro B connector or directly by the +5V pins of the MikroBUS connectors. Please check the Technical specifications and the circuit Schematics for more details. Full 5V support in all the I/Os The board supports 5V input logic levels in all of the I/Os. The analog inputs of the Arduino and Grove interfaces also provide 5V-support through level conditioning stages. Check the expansion interfaces section for more information. ST-Link Debugger \u00b6 The target MCU can be programmed in 3 different ways: Using the flashing and debugging functionalities of the ST-Link interface (check the Getting Started and Tools for more information) Using the Cortex-M\u2122 10-pin connector present in the front (SWD). Debug probes like Segger's J-Link\u00ae can be attached to this connector if preferred Just drag and drop the compiled binary file into the Mass Storage Device created in the host PC when the board is plugged into the USB The ST-Link interface also exposes a virtual serial port in addition to the SWD debugging interface, which can be used to print debug and logging information during the application development. WiFi \u00b6 SensorIO integrates the Industrial-grade CC3120R SoC from Texas Instruments , a Wi-Fi\u00ae Network Processor designed for Internet of Things applications. A dedicated ARM\u00ae Cortex\u00ae-M3 Microcontroller Unit (MCU) completely offloads Wi-Fi and Internet protocols from the application MCU. This subsystem includes an 802.11b/g/n radio, baseband, and MAC with a powerful crypto engine for fast, secure Internet connections with 256-bit encryption. The device also supports WPA2 personal and enterprise security. It uses an external SPI flash to store the Wi-Fi\u00ae and security stacks. Expansion interfaces \u00b6 The board takes advantage of the main MCU's 20+ communication interfaces available through its 114 I/O ports to provide an unmached set of options to extend its functionalities through the expansion interfaces (Grove, MikroBUS and ArduinoR3 sockets). Maximum flexibility with peripherals multiplexing Most of the Grove interfaces on other \u200bGrove-compatible\u200b boards include multiple connectors since they have one fixed bus hard-wired per connector. This means that, in order to support the 4 interfaces types, they need to provide several connectors. SensorIO supports all the interface types in each connector, thus achieving maximum flexibility. User interaction \u00b6 In order to quickly evaluate the board and prototype a serie of use-cases, the device integrates a set of sensors , two opto-isolated solid state relays for controlling power outputs, an RGB LED, a push-button and a small 128x32 pixels OLED monocrome display useful to show real-time information. Please refer to the Schematics section to learn how to control these peripherals. Most of the peripherals are showcased on the out-of-the-box application .","title":"Hardware overview"},{"location":"development-boards/sensorio/hardware-overview/#hardware-description","text":"In order to maximize the flexibility of use for different applications, all the expansion interfaces have software-configurable support for 3.3V and 5V boards, providing compatibility for more than 500+ different expansion boards available from various manufacturers. The core of the SensorIO board is the ST-Micro STM32F413ZH , a powerful ARM Cortex\u00ae-M4 MCU with a very rich set of peripherals presented into a 144-balls 10x10mm BGA chip.","title":"Hardware description"},{"location":"development-boards/sensorio/hardware-overview/#features","text":"This is an overview of the main components and features: STM32F413ZH MCU, ARM Cortex\u2122-M4 , 1.5 Mbytes of Flash memory, 320 Kbytes of RAM, FPU unit w/ DSP instructions, 125 DMIPS @ 100 MHz. WiFi: CC3120R SimpleLink\u00ae \u2028Wi-Fi 802.11b/g/n 128x32 0.91\u2019\u2019 OLED display LiteOn LTR303-ALS ambient light sensor Bosch Sensortec BMA253 : 3-axis accelerometer with motion triggered interrups Bosch Sensortec BME680 : Environmental sensor (temperature, humidity, barometric pressure, VOC air quality) 2x opto-relay outputs ( Toshiba TLP241A , 2A/24Vac) 2x MikroBUS\u2122 expansion sockets Arduino\u2122 R3 socket with 3.3V & 5V support on I/Os and Analog Inputs 2x Grove\u2122 connectors Software programable individual 3.3V / 5V switches Each connector provides software configurable UART, I2C, PWM, GPIO and Analog interfacing Onboard ST-Link\u2122/V2-1 debugger - mbed\u2122 compatible Micro SD/MMC flash memory socket (for datalogging, storing credentials, etc.) User & reset buttons, RGB color LED Total peripherals exposed on the expansion connectors: 8 x UART interfaces 3 x I2C buses 2 x SPI buses 2 x I2S interfaces 3 x CAN buses 19 x PWM capable outputs 15 x Analog input channels 2 x Isolated, high-power outputs (solid state relays) 47 x Total exposed GPIOs!","title":"Features"},{"location":"development-boards/sensorio/hardware-overview/#block-diagram","text":"USB functions: Power input (1) Debugging port (GDB compatible) Virtual Serial COMM Mass storage programming (simply drag & drop to flash) (1) The board can be powered through the on-board USB Micro B connector or directly by the +5V pins of the MikroBUS connectors. Please check the Technical specifications and the circuit Schematics for more details. Full 5V support in all the I/Os The board supports 5V input logic levels in all of the I/Os. The analog inputs of the Arduino and Grove interfaces also provide 5V-support through level conditioning stages. Check the expansion interfaces section for more information.","title":"Block Diagram"},{"location":"development-boards/sensorio/hardware-overview/#st-link-debugger","text":"The target MCU can be programmed in 3 different ways: Using the flashing and debugging functionalities of the ST-Link interface (check the Getting Started and Tools for more information) Using the Cortex-M\u2122 10-pin connector present in the front (SWD). Debug probes like Segger's J-Link\u00ae can be attached to this connector if preferred Just drag and drop the compiled binary file into the Mass Storage Device created in the host PC when the board is plugged into the USB The ST-Link interface also exposes a virtual serial port in addition to the SWD debugging interface, which can be used to print debug and logging information during the application development.","title":"ST-Link Debugger"},{"location":"development-boards/sensorio/hardware-overview/#wifi","text":"SensorIO integrates the Industrial-grade CC3120R SoC from Texas Instruments , a Wi-Fi\u00ae Network Processor designed for Internet of Things applications. A dedicated ARM\u00ae Cortex\u00ae-M3 Microcontroller Unit (MCU) completely offloads Wi-Fi and Internet protocols from the application MCU. This subsystem includes an 802.11b/g/n radio, baseband, and MAC with a powerful crypto engine for fast, secure Internet connections with 256-bit encryption. The device also supports WPA2 personal and enterprise security. It uses an external SPI flash to store the Wi-Fi\u00ae and security stacks.","title":"WiFi"},{"location":"development-boards/sensorio/hardware-overview/#expansion-interfaces","text":"The board takes advantage of the main MCU's 20+ communication interfaces available through its 114 I/O ports to provide an unmached set of options to extend its functionalities through the expansion interfaces (Grove, MikroBUS and ArduinoR3 sockets). Maximum flexibility with peripherals multiplexing Most of the Grove interfaces on other \u200bGrove-compatible\u200b boards include multiple connectors since they have one fixed bus hard-wired per connector. This means that, in order to support the 4 interfaces types, they need to provide several connectors. SensorIO supports all the interface types in each connector, thus achieving maximum flexibility.","title":"Expansion interfaces"},{"location":"development-boards/sensorio/hardware-overview/#user-interaction","text":"In order to quickly evaluate the board and prototype a serie of use-cases, the device integrates a set of sensors , two opto-isolated solid state relays for controlling power outputs, an RGB LED, a push-button and a small 128x32 pixels OLED monocrome display useful to show real-time information. Please refer to the Schematics section to learn how to control these peripherals. Most of the peripherals are showcased on the out-of-the-box application .","title":"User interaction"},{"location":"development-boards/sensorio/interfaces/","text":"Expansion interfaces \u00b6 This section describes the Grove, MikroBUS and Arduino R3 expansion interfaces: MikroBUS sockets \u00b6 Socket introduction \u00b6 The mikroBUS\u2122 socket comprises a pair of 1\u00d78 female headers with a proprietary pin configuration and silkscreen markings. The pinout consists of three groups of communications pins (SPI, UART and I2C), six additional pins (PWM, Interrupt, Analog input, Reset and Chip select), and two power groups (+3.3V and 5V). The company Mikroelectronica produces over 500 expansion boards called \"Click modules\", available through various distributors. These modules are often useful for rapid prototyping and evaluation of a broad variety of sensors, interfaces and actuators. The figure below shows the MikroBUS#1 schematic, the second interface is identical. Pinout \u00b6 The pin-mapping to the MCU is listed in the pinout section . The pinout table shows also the alternative functions when available (as a CAN Bus or I2S interface for audio for instance). Pin sharing limitation Please note that, although the STM32F413 MCU provides a rich set and number of peripherals, in some cases the buses need to be shared between the expansion interfaces. For example, both MikroBUS sockets share one SPI bus, which doesn't present a problem if this interface is used as a bus, since each interface has it's own Chip Select line exposed (MBx_CS), but if these pins are intended to be used as independent GPIOs, only one interface can be used at a time. Refer to the Pinouts section for more details. The capture below shows the I2C pull-up resistors. Note the I2C lines shared between the MikroBUS 1 and 2 interfaces: Click boards orientation Please note the correct orientation mark in the image below. An incorrect installation could damage the module or the SensorIO board. Grove connectors \u00b6 Grove system introduction \u00b6 The Seedstudio\u2019s \u200b Grove system \u200b consist of a 4-pin standardized connector and expansion boards that are attached using extension cables. The connector uses two pins for power (GND and 3.3V or 5V depending on the module) and two for signals: Grove interface types There are basically 4 types of interfaces for these modules: Digital: \u200bboth pins are either digital Input or Output. Usually used for relays or motor control, but some modules also use proprietary control protocols as in the \u200bLED Bar module\u200b. Analog: \u200b2 analog inputs. Common modules providing analog levels are potentiometers and gas sensors. UART: \u200bFull-duplex serial interface (TXD and RXD). The RF Link module or \u200bRFID reader use this interface for instance. I2C: \u200bThis bus can support daisy chaining in some cases. Some sensor modules and LCD displays use this bus. The image below shows the Grove connectors marking and the corresponding signal names. Analog multiplexers \u00b6 As each pin can be used to connect up to 4 different types of peripherals (PWM / I2C / UART and Analog input) and these peripherals in most cases aren't mapped to the same pins on the MCU, each connector is routed through a 2-channel 4x1 Analog Multiplexer SN74LV4052A . The figure below shows the internal logic of the MUX: X and Y are the two selectable channels (they can be viewed as switches with 4 positions). The switches position is controlled by the digital inputs A and B (INH disable the switches and it's not used). Therefore the connection from X to (X0 .. X3) depends on the state of the control inputs [B:A]. The schematic below shows the multiplexer for the Grove 2 connector ( Grove 1 follows the same schema): On the left side are routed the pin 1 and 2 of the connector and the control pins and on the right-side the peripherals to the MCU. The analog input is routed to the level conditioning stage detailed below. The following table shows the configuration for the control pins of the multiplexers (logic levels for A and B). The pin mapping for each connector and the corresponding multiplexed peripherals can be found on the pinouts section . Position Grove_n_MUX_B Grove_n_MUX_A Peripheral Connected 0 0 0 PWM (default) 1 0 1 UART 2 1 0 I2C 3 1 1 Analog In Level conditioning \u00b6 Analog levels conditioning Some Grove modules are designed to work with 5V supply and they provide a 0 to 5V analog output. As the maximum input voltage for the MCU's integrated ADC is 3.3V, a level conditioning and protection stage is added per channel (replicated 4 times). The image below shows the circuit for the pin 1 of the Grove 2 connector. R45 and R46 transtlate the input voltage with a ratio of 0.68. The operational amplifier U6C acts as a buffer to provide better input impedance to the ADC channel. The input impedance presented to the Grove pins is then 147 k\u03a9. The double Schottky diode D4 limits the voltage at the ADC input to approximately -0.3V or 3.6V to protect the MCU in case that the input voltage exceeds the allowed limits. Power switches \u00b6 Software configurable 5V / 3.3V power switches As some of the Grove modules support either 5V or 3.3V power only, SensorIO integrates two separate software-configurable 5/3.3V switches to provide the proper voltage to the power pins. Most boards support only 3.3V for the interfaces and power, and some of them provide the option to switch to 5V by unsoldering/soldering resistors or manually changing the position of jumpers. SensorIO has a software-controlled switching functionality, individually per connector for maximum flexibility. The schematic below shows the power switch for the Grove 1 connector. When the control pin is low (default), the output will provide 3.3V, when the output is pushed high, the power pin will be connected to 5V. Arduino R3 socket \u00b6 The Arduino R3 socket is a traditional form factor and there are multiple companies providing extension boards or so called \"shields\" for different applications. The figure below shows the pinout: The NRST input signal is connected to the reset line driven by the main Reset push-button (S2). Some shields use this signal to initialize their internal logic (as is the case of some GPS / GSM modem shields). The IOREF pin is optionally used by some shields to select the digital pins interfacing level (3.3V or 5V). 5V compatibility for inputs and outputs Some Arduino shields use 5V logic levels for the digital interfaces. This doesn't present a problem for the STM32F413 inputs since they are 5V tolerant. The issue would be evident when the MCU outputs are used to drive the inputs on these shields: some logic families are compatible with 3.3V input levels, but some are not. To overcome this potential incompatibility, the board uses a Schottky diode (D6 in the capture below) in series with the 5V power rail to produce a small voltage drop on the Arduino 5V pin. This reduces the shield Vcc to about 4.7V, which is not an issue for the correct functioning of these logic families since it's tolerated in the nominal range, but enough to allow the outputs of the MCU to fit in the safe range for the logic HIGH (in other words: a 3.3V output on the MCU will ensure a high level on the shield's inputs for all the logic families). Analog multiplexer \u00b6 The interface defines 6 analog inputs, and as this interface has a long legacy coming from a 8-bit 5V logic level MCU, the ranges on the analog inputs could be still 5V on some shields, while the STM32F413 internal ADCs support 3.3V maximum. SensorIO solve this problem in a similar fashion to the Grove interface: it uses the SN74LV4051A , an 8 to 1 analog multiplexer to switch between the 6 analog inputs and a voltage adaptation and protection stage to translate the 0-5V range into 0-3.3V: 'Calibrating' the A0-A6 analog channels As the multiplexer has 2 free inputs (Y6 and Y7), we can take advantage of this and use them to get the possibility to switch the ARD_ANALOG output to 5V and 0V. By doing this, we can compensate for the small errors added by the multiplexer and the level translator stage. The procedure could be the following: Select input Y6 (routed to 5V). Read the ADC output (it could be useful to take several measurements and simply average them) and store the result. Select input Y7 (routed to 0V). Average several ADC readings and store the result. Use the stored values to compensate for readings on the channels A0 to A5. An example implementation of this procedure can be found on the [firmware ADC section]. The schematic below shows the signal conditioning stage (from 5V to 3.2V) and diode clamping circuit to protect the internal ADC from voltages out of its maximum ranges. The following table shows the combination of the multiplexer control lines needed to select each channel: Position MUX_C MUX_B MUX_A Channel selected Y0 0 0 0 A0 Y1 0 0 1 A1 Y2 0 1 0 A2 Y3 0 1 1 A3 Y4 1 0 0 A4 ( 1 ) Y5 1 0 1 A5 ( 1 ) Y6 1 1 0 Calibration High (5V) Y7 1 1 1 Calibration Low (0V) A4 and A5 inputs In the Arduino UNO R3, and in some shields, the A4 and A5 inputs are internally connected with the I2C bus on the D15 and D14 pins (SDA and SCL lines). Therefore, in order to use the A4 and A5 pins as Analog Inputs, the correspondent I2C pins on the MCU (PB_4 and PA_8) need to be configured as high-impedance (or input, which the default state).","title":"Expansion interfaces"},{"location":"development-boards/sensorio/interfaces/#expansion-interfaces","text":"This section describes the Grove, MikroBUS and Arduino R3 expansion interfaces:","title":"Expansion interfaces"},{"location":"development-boards/sensorio/interfaces/#mikrobus-sockets","text":"","title":"MikroBUS sockets"},{"location":"development-boards/sensorio/interfaces/#socket-introduction","text":"The mikroBUS\u2122 socket comprises a pair of 1\u00d78 female headers with a proprietary pin configuration and silkscreen markings. The pinout consists of three groups of communications pins (SPI, UART and I2C), six additional pins (PWM, Interrupt, Analog input, Reset and Chip select), and two power groups (+3.3V and 5V). The company Mikroelectronica produces over 500 expansion boards called \"Click modules\", available through various distributors. These modules are often useful for rapid prototyping and evaluation of a broad variety of sensors, interfaces and actuators. The figure below shows the MikroBUS#1 schematic, the second interface is identical.","title":"Socket introduction"},{"location":"development-boards/sensorio/interfaces/#pinout","text":"The pin-mapping to the MCU is listed in the pinout section . The pinout table shows also the alternative functions when available (as a CAN Bus or I2S interface for audio for instance). Pin sharing limitation Please note that, although the STM32F413 MCU provides a rich set and number of peripherals, in some cases the buses need to be shared between the expansion interfaces. For example, both MikroBUS sockets share one SPI bus, which doesn't present a problem if this interface is used as a bus, since each interface has it's own Chip Select line exposed (MBx_CS), but if these pins are intended to be used as independent GPIOs, only one interface can be used at a time. Refer to the Pinouts section for more details. The capture below shows the I2C pull-up resistors. Note the I2C lines shared between the MikroBUS 1 and 2 interfaces: Click boards orientation Please note the correct orientation mark in the image below. An incorrect installation could damage the module or the SensorIO board.","title":"Pinout"},{"location":"development-boards/sensorio/interfaces/#grove-connectors","text":"","title":"Grove connectors"},{"location":"development-boards/sensorio/interfaces/#grove-system-introduction","text":"The Seedstudio\u2019s \u200b Grove system \u200b consist of a 4-pin standardized connector and expansion boards that are attached using extension cables. The connector uses two pins for power (GND and 3.3V or 5V depending on the module) and two for signals: Grove interface types There are basically 4 types of interfaces for these modules: Digital: \u200bboth pins are either digital Input or Output. Usually used for relays or motor control, but some modules also use proprietary control protocols as in the \u200bLED Bar module\u200b. Analog: \u200b2 analog inputs. Common modules providing analog levels are potentiometers and gas sensors. UART: \u200bFull-duplex serial interface (TXD and RXD). The RF Link module or \u200bRFID reader use this interface for instance. I2C: \u200bThis bus can support daisy chaining in some cases. Some sensor modules and LCD displays use this bus. The image below shows the Grove connectors marking and the corresponding signal names.","title":"Grove system introduction"},{"location":"development-boards/sensorio/interfaces/#analog-multiplexers","text":"As each pin can be used to connect up to 4 different types of peripherals (PWM / I2C / UART and Analog input) and these peripherals in most cases aren't mapped to the same pins on the MCU, each connector is routed through a 2-channel 4x1 Analog Multiplexer SN74LV4052A . The figure below shows the internal logic of the MUX: X and Y are the two selectable channels (they can be viewed as switches with 4 positions). The switches position is controlled by the digital inputs A and B (INH disable the switches and it's not used). Therefore the connection from X to (X0 .. X3) depends on the state of the control inputs [B:A]. The schematic below shows the multiplexer for the Grove 2 connector ( Grove 1 follows the same schema): On the left side are routed the pin 1 and 2 of the connector and the control pins and on the right-side the peripherals to the MCU. The analog input is routed to the level conditioning stage detailed below. The following table shows the configuration for the control pins of the multiplexers (logic levels for A and B). The pin mapping for each connector and the corresponding multiplexed peripherals can be found on the pinouts section . Position Grove_n_MUX_B Grove_n_MUX_A Peripheral Connected 0 0 0 PWM (default) 1 0 1 UART 2 1 0 I2C 3 1 1 Analog In","title":"Analog multiplexers"},{"location":"development-boards/sensorio/interfaces/#level-conditioning","text":"Analog levels conditioning Some Grove modules are designed to work with 5V supply and they provide a 0 to 5V analog output. As the maximum input voltage for the MCU's integrated ADC is 3.3V, a level conditioning and protection stage is added per channel (replicated 4 times). The image below shows the circuit for the pin 1 of the Grove 2 connector. R45 and R46 transtlate the input voltage with a ratio of 0.68. The operational amplifier U6C acts as a buffer to provide better input impedance to the ADC channel. The input impedance presented to the Grove pins is then 147 k\u03a9. The double Schottky diode D4 limits the voltage at the ADC input to approximately -0.3V or 3.6V to protect the MCU in case that the input voltage exceeds the allowed limits.","title":"Level conditioning"},{"location":"development-boards/sensorio/interfaces/#power-switches","text":"Software configurable 5V / 3.3V power switches As some of the Grove modules support either 5V or 3.3V power only, SensorIO integrates two separate software-configurable 5/3.3V switches to provide the proper voltage to the power pins. Most boards support only 3.3V for the interfaces and power, and some of them provide the option to switch to 5V by unsoldering/soldering resistors or manually changing the position of jumpers. SensorIO has a software-controlled switching functionality, individually per connector for maximum flexibility. The schematic below shows the power switch for the Grove 1 connector. When the control pin is low (default), the output will provide 3.3V, when the output is pushed high, the power pin will be connected to 5V.","title":"Power switches"},{"location":"development-boards/sensorio/interfaces/#arduino-r3-socket","text":"The Arduino R3 socket is a traditional form factor and there are multiple companies providing extension boards or so called \"shields\" for different applications. The figure below shows the pinout: The NRST input signal is connected to the reset line driven by the main Reset push-button (S2). Some shields use this signal to initialize their internal logic (as is the case of some GPS / GSM modem shields). The IOREF pin is optionally used by some shields to select the digital pins interfacing level (3.3V or 5V). 5V compatibility for inputs and outputs Some Arduino shields use 5V logic levels for the digital interfaces. This doesn't present a problem for the STM32F413 inputs since they are 5V tolerant. The issue would be evident when the MCU outputs are used to drive the inputs on these shields: some logic families are compatible with 3.3V input levels, but some are not. To overcome this potential incompatibility, the board uses a Schottky diode (D6 in the capture below) in series with the 5V power rail to produce a small voltage drop on the Arduino 5V pin. This reduces the shield Vcc to about 4.7V, which is not an issue for the correct functioning of these logic families since it's tolerated in the nominal range, but enough to allow the outputs of the MCU to fit in the safe range for the logic HIGH (in other words: a 3.3V output on the MCU will ensure a high level on the shield's inputs for all the logic families).","title":"Arduino R3 socket"},{"location":"development-boards/sensorio/interfaces/#analog-multiplexer","text":"The interface defines 6 analog inputs, and as this interface has a long legacy coming from a 8-bit 5V logic level MCU, the ranges on the analog inputs could be still 5V on some shields, while the STM32F413 internal ADCs support 3.3V maximum. SensorIO solve this problem in a similar fashion to the Grove interface: it uses the SN74LV4051A , an 8 to 1 analog multiplexer to switch between the 6 analog inputs and a voltage adaptation and protection stage to translate the 0-5V range into 0-3.3V: 'Calibrating' the A0-A6 analog channels As the multiplexer has 2 free inputs (Y6 and Y7), we can take advantage of this and use them to get the possibility to switch the ARD_ANALOG output to 5V and 0V. By doing this, we can compensate for the small errors added by the multiplexer and the level translator stage. The procedure could be the following: Select input Y6 (routed to 5V). Read the ADC output (it could be useful to take several measurements and simply average them) and store the result. Select input Y7 (routed to 0V). Average several ADC readings and store the result. Use the stored values to compensate for readings on the channels A0 to A5. An example implementation of this procedure can be found on the [firmware ADC section]. The schematic below shows the signal conditioning stage (from 5V to 3.2V) and diode clamping circuit to protect the internal ADC from voltages out of its maximum ranges. The following table shows the combination of the multiplexer control lines needed to select each channel: Position MUX_C MUX_B MUX_A Channel selected Y0 0 0 0 A0 Y1 0 0 1 A1 Y2 0 1 0 A2 Y3 0 1 1 A3 Y4 1 0 0 A4 ( 1 ) Y5 1 0 1 A5 ( 1 ) Y6 1 1 0 Calibration High (5V) Y7 1 1 1 Calibration Low (0V) A4 and A5 inputs In the Arduino UNO R3, and in some shields, the A4 and A5 inputs are internally connected with the I2C bus on the D15 and D14 pins (SDA and SCL lines). Therefore, in order to use the A4 and A5 pins as Analog Inputs, the correspondent I2C pins on the MCU (PB_4 and PA_8) need to be configured as high-impedance (or input, which the default state).","title":"Analog multiplexer"},{"location":"development-boards/sensorio/ltr303/","text":"Light sensor \u00b6 Description \u00b6 LTR-303 is a digital ambient light sensor. Communication is carried over I2C interface. Dynamic range spans from 0.01 lux to 64000 lux with different configuration options. Interrupt line provides asynchronous data readout capability. Part details \u00b6 Manufacturer: Lite-On Technology, Inc. Part number: LTR-303ALS-01 Datasheet: link Code example \u00b6 Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page. LTR303 driver \u00b6 Mbed OS driver for SensorIO can be found here: LTR303 on Github . Code \u00b6 In this example IRQ line is used to provide callback with lux value to user. Please mind that sensor's callback is executed in the context of sensor's own thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \"mbed_events.h\" #include \"Serial.h\" #include \"ltr303.h\" mbed :: Serial console ( USBTX , USBRX , 115200 ); mbed :: I2C iic ( SENSORS_SDA , SENSORS_SCL ); mbed :: InterruptIn irq ( LTR303_INT , PinMode :: PullUp ); events :: EventQueue scheduler ; Ltr303 sensor ( iic , irq ); void measDone ( float ); // callback from driver in separate execution context void dataCallback ( float result ) { scheduler . call_in ( 500 , measDone , result ); } // executor in this context void measDone ( float result ) { console . printf ( \"Light sensor output: %5.3f lux. \\n \" , result ); // request next measurement sensor . get ( dataCallback ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); // schedule first measurement, it will chain next in callback sensor . get ( dataCallback ); // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here .","title":"Light sensor"},{"location":"development-boards/sensorio/ltr303/#light-sensor","text":"","title":"Light sensor"},{"location":"development-boards/sensorio/ltr303/#description","text":"LTR-303 is a digital ambient light sensor. Communication is carried over I2C interface. Dynamic range spans from 0.01 lux to 64000 lux with different configuration options. Interrupt line provides asynchronous data readout capability.","title":"Description"},{"location":"development-boards/sensorio/ltr303/#part-details","text":"Manufacturer: Lite-On Technology, Inc. Part number: LTR-303ALS-01 Datasheet: link","title":"Part details"},{"location":"development-boards/sensorio/ltr303/#code-example","text":"Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page.","title":"Code example"},{"location":"development-boards/sensorio/ltr303/#ltr303-driver","text":"Mbed OS driver for SensorIO can be found here: LTR303 on Github .","title":"LTR303 driver"},{"location":"development-boards/sensorio/ltr303/#code","text":"In this example IRQ line is used to provide callback with lux value to user. Please mind that sensor's callback is executed in the context of sensor's own thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \"mbed_events.h\" #include \"Serial.h\" #include \"ltr303.h\" mbed :: Serial console ( USBTX , USBRX , 115200 ); mbed :: I2C iic ( SENSORS_SDA , SENSORS_SCL ); mbed :: InterruptIn irq ( LTR303_INT , PinMode :: PullUp ); events :: EventQueue scheduler ; Ltr303 sensor ( iic , irq ); void measDone ( float ); // callback from driver in separate execution context void dataCallback ( float result ) { scheduler . call_in ( 500 , measDone , result ); } // executor in this context void measDone ( float result ) { console . printf ( \"Light sensor output: %5.3f lux. \\n \" , result ); // request next measurement sensor . get ( dataCallback ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); // schedule first measurement, it will chain next in callback sensor . get ( dataCallback ); // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here .","title":"Code"},{"location":"development-boards/sensorio/multiplexers/","text":"SensorIO is extremely flexible and supports majority of Arduino shields and Grove extensions. This is achieved with hardware multiplexers and switches that can be controlled by firmware. Multiplexer driver \u00b6 There are two ways to set multiplexers: By directly controlling appropriate pins (see Pin Definitions sections) with Mbed OS built-in DigitalOut class By using a simple wrappers with more verbose, one-line settings from Github Arduino \u00b6 Multiplexer for Arduino selects which analog input pin on Arduino port ( A0 to A5 ) is connected to main MCU analog input ( PC_0 / ARD_ANALOG_IN ). Pin definitions \u00b6 1 2 3 4 5 6 /**** Arduino analog multiplexer ***/ ARD_MUX_A = PG_6 , ARD_MUX_B = PG_7 , ARD_MUX_C = PG_8 , ARD_ANALOG_IN = PC_0 , Pin settings \u00b6 ARD_MUX_C ARD_MUX_B ARD_MUX_A Selection 0 0 0 A0 0 0 1 A1 0 1 0 A2 0 1 1 A3 1 0 0 A4 1 0 1 A5 1 1 0 CALIB_HIGH 1 1 1 CALIB_LOW A4 and A5 Pins A4 and A5 are internally connected to D14 and D15 in some shields, therefore, remember to configure D14 (PB4) and D15 (PA8) in high impedance mode (set as INPUT) to use these analog inputs. CALIB_HIGH and CALIB_LOW MUX values 6 and 7 can be used to calibrate the Analog Inputs to the Max and Min values respectively. Example \u00b6 This snippet shows how to route pin A3 from Arduino port to MCU analog input ( PC_0 / ARD_ANALOG_IN ) with DigitalOut class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \"DigitalOut.h\" #include \"AnalogIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); mbed :: DigitalOut ardMuxA ( ARD_MUX_A ); mbed :: DigitalOut ardMuxB ( ARD_MUX_B ); mbed :: DigitalOut ardMuxC ( ARD_MUX_C ); mbed :: AnalogIn ardAnalogIn ( ARD_ANALOG_IN ); // select pin A3 with multiplexer ardMuxA = 0 ; ardMuxB = 1 ; ardMuxC = 1 ; // read value float analogValue = ardAnalogIn . read (); console . printf ( \"analogValue is %f \\r\\n \" , analogValue ); } This file can be downloaded here . This snippet shows the same functionality, but with ArduinoMultiplexer wrapper: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \"arduinomultiplexer.h\" #include \"AnalogIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); ArduinoMultiplexer multiplexer ; mbed :: AnalogIn ardAnalogIn ( ARD_ANALOG_IN ); // select pin A3 with multiplexer multiplexer . select ( ArduinoMultiplexer :: Input :: SELECT_A3 ); // read value float analogValue = ardAnalogIn . read (); console . printf ( \"analogValue is %f \\r\\n \" , analogValue ); } This file can be downloaded here . Grove \u00b6 Each Grove connector has a voltage level switch and mode selection multiplexer. Voltage level switch can be used to select between 3.3V and 5V on Vcc pin. Mode multiplexer selects function of two signal pins, from PWM, to UART, to I2C to analog input. Pin definitions \u00b6 Grove 1 connector: 1 2 3 4 5 6 /**** Grove 1 multiplexer pins ****/ GROVE1_MUX_A = PD_10 , GROVE1_MUX_B = PD_11 , /**** Grove 1 3V3/5V switch pin ****/ GROVE1_SW_5V = PG_9 , Grove 2 connector: 1 2 3 4 5 6 /**** Grove 2 multiplexer pins ****/ GROVE2_MUX_A = PG_4 , GROVE2_MUX_B = PG_5 , /**** Grove 2 3V3/5V switch pin ****/ GROVE2_SW_5V = PG_10 , Pin settings \u00b6 Mode multiplexer: GROVEX_MUX_A GROVEX_MUX_B Mode 0 0 PWM 0 1 UART 1 0 I2C 1 1 ANALOG_IN Voltage switch: GROVEX_SW_5V Vcc [V] 0 3.3 1 5 I2C on Grove Driver for I2C on Grove connectors (both connectors share the same I2C bus) is not yet ready. Example \u00b6 This snippet shows how to configure Grove 1 connector as UART with 3.3V Vcc and Grove 2 connector as analog input with 5V Vcc: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \"grovemultiplexer.h\" #include \"grovetwomultiplexer.h\" #include \"AnalogIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); // using generic Grove multiplexer class GroveMultiplexer grove1Multiplexer ( GROVE1_MUX_A , GROVE1_MUX_B , GROVE1_SW_5V ); // using SensorIO Grove 2 multiplexer class GroveTwoMultiplexer grove2Multiplexer ; // select voltage (3.3V is default, so no need to change Grove 1) grove2Multiplexer . select ( GroveMultiplexer :: Voltage :: VCC_5V ); grove1Multiplexer . select ( GroveMultiplexer :: Mode :: UART ); grove2Multiplexer . select ( GroveMultiplexer :: Mode :: ANALOG_IN ); mbed :: AnalogIn grove2AnalogIn ( GROVE2_AI2 ); mbed :: Serial grove1Uart ( GROVE1_TX , GROVE1_RX , 9600 ); // read value float analogValue = grove2AnalogIn . read (); console . printf ( \"analogValue is %f \\r\\n \" , analogValue ); // send data over Grove 1 UART grove1Uart . puts ( \"From SensorIO to Grove\" ); } This file can be downloaded here . Grove multiplexers can also be used with just DigitalOut instead of GroveMultiplexer class. For this please refer to Arduino example .","title":"Multiplexers"},{"location":"development-boards/sensorio/multiplexers/#multiplexer-driver","text":"There are two ways to set multiplexers: By directly controlling appropriate pins (see Pin Definitions sections) with Mbed OS built-in DigitalOut class By using a simple wrappers with more verbose, one-line settings from Github","title":"Multiplexer driver"},{"location":"development-boards/sensorio/multiplexers/#arduino","text":"Multiplexer for Arduino selects which analog input pin on Arduino port ( A0 to A5 ) is connected to main MCU analog input ( PC_0 / ARD_ANALOG_IN ).","title":"Arduino"},{"location":"development-boards/sensorio/multiplexers/#pin-definitions","text":"1 2 3 4 5 6 /**** Arduino analog multiplexer ***/ ARD_MUX_A = PG_6 , ARD_MUX_B = PG_7 , ARD_MUX_C = PG_8 , ARD_ANALOG_IN = PC_0 ,","title":"Pin definitions"},{"location":"development-boards/sensorio/multiplexers/#pin-settings","text":"ARD_MUX_C ARD_MUX_B ARD_MUX_A Selection 0 0 0 A0 0 0 1 A1 0 1 0 A2 0 1 1 A3 1 0 0 A4 1 0 1 A5 1 1 0 CALIB_HIGH 1 1 1 CALIB_LOW A4 and A5 Pins A4 and A5 are internally connected to D14 and D15 in some shields, therefore, remember to configure D14 (PB4) and D15 (PA8) in high impedance mode (set as INPUT) to use these analog inputs. CALIB_HIGH and CALIB_LOW MUX values 6 and 7 can be used to calibrate the Analog Inputs to the Max and Min values respectively.","title":"Pin settings"},{"location":"development-boards/sensorio/multiplexers/#example","text":"This snippet shows how to route pin A3 from Arduino port to MCU analog input ( PC_0 / ARD_ANALOG_IN ) with DigitalOut class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \"DigitalOut.h\" #include \"AnalogIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); mbed :: DigitalOut ardMuxA ( ARD_MUX_A ); mbed :: DigitalOut ardMuxB ( ARD_MUX_B ); mbed :: DigitalOut ardMuxC ( ARD_MUX_C ); mbed :: AnalogIn ardAnalogIn ( ARD_ANALOG_IN ); // select pin A3 with multiplexer ardMuxA = 0 ; ardMuxB = 1 ; ardMuxC = 1 ; // read value float analogValue = ardAnalogIn . read (); console . printf ( \"analogValue is %f \\r\\n \" , analogValue ); } This file can be downloaded here . This snippet shows the same functionality, but with ArduinoMultiplexer wrapper: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \"arduinomultiplexer.h\" #include \"AnalogIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); ArduinoMultiplexer multiplexer ; mbed :: AnalogIn ardAnalogIn ( ARD_ANALOG_IN ); // select pin A3 with multiplexer multiplexer . select ( ArduinoMultiplexer :: Input :: SELECT_A3 ); // read value float analogValue = ardAnalogIn . read (); console . printf ( \"analogValue is %f \\r\\n \" , analogValue ); } This file can be downloaded here .","title":"Example"},{"location":"development-boards/sensorio/multiplexers/#grove","text":"Each Grove connector has a voltage level switch and mode selection multiplexer. Voltage level switch can be used to select between 3.3V and 5V on Vcc pin. Mode multiplexer selects function of two signal pins, from PWM, to UART, to I2C to analog input.","title":"Grove"},{"location":"development-boards/sensorio/multiplexers/#pin-definitions_1","text":"Grove 1 connector: 1 2 3 4 5 6 /**** Grove 1 multiplexer pins ****/ GROVE1_MUX_A = PD_10 , GROVE1_MUX_B = PD_11 , /**** Grove 1 3V3/5V switch pin ****/ GROVE1_SW_5V = PG_9 , Grove 2 connector: 1 2 3 4 5 6 /**** Grove 2 multiplexer pins ****/ GROVE2_MUX_A = PG_4 , GROVE2_MUX_B = PG_5 , /**** Grove 2 3V3/5V switch pin ****/ GROVE2_SW_5V = PG_10 ,","title":"Pin definitions"},{"location":"development-boards/sensorio/multiplexers/#pin-settings_1","text":"Mode multiplexer: GROVEX_MUX_A GROVEX_MUX_B Mode 0 0 PWM 0 1 UART 1 0 I2C 1 1 ANALOG_IN Voltage switch: GROVEX_SW_5V Vcc [V] 0 3.3 1 5 I2C on Grove Driver for I2C on Grove connectors (both connectors share the same I2C bus) is not yet ready.","title":"Pin settings"},{"location":"development-boards/sensorio/multiplexers/#example_1","text":"This snippet shows how to configure Grove 1 connector as UART with 3.3V Vcc and Grove 2 connector as analog input with 5V Vcc: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \"grovemultiplexer.h\" #include \"grovetwomultiplexer.h\" #include \"AnalogIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); // using generic Grove multiplexer class GroveMultiplexer grove1Multiplexer ( GROVE1_MUX_A , GROVE1_MUX_B , GROVE1_SW_5V ); // using SensorIO Grove 2 multiplexer class GroveTwoMultiplexer grove2Multiplexer ; // select voltage (3.3V is default, so no need to change Grove 1) grove2Multiplexer . select ( GroveMultiplexer :: Voltage :: VCC_5V ); grove1Multiplexer . select ( GroveMultiplexer :: Mode :: UART ); grove2Multiplexer . select ( GroveMultiplexer :: Mode :: ANALOG_IN ); mbed :: AnalogIn grove2AnalogIn ( GROVE2_AI2 ); mbed :: Serial grove1Uart ( GROVE1_TX , GROVE1_RX , 9600 ); // read value float analogValue = grove2AnalogIn . read (); console . printf ( \"analogValue is %f \\r\\n \" , analogValue ); // send data over Grove 1 UART grove1Uart . puts ( \"From SensorIO to Grove\" ); } This file can be downloaded here . Grove multiplexers can also be used with just DigitalOut instead of GroveMultiplexer class. For this please refer to Arduino example .","title":"Example"},{"location":"development-boards/sensorio/oled/","text":"OLED display \u00b6 Description \u00b6 SensorIO's display is a monochrome (white) OLED screen with 128x32 pixels and based on SSD1306 controller. Communication is carried over SPI interface ( SPI4 ). Part details \u00b6 Manufacturer: Univision Technology Inc. Part number: UG-2832HSSWEG04 Datasheet: link Code example \u00b6 Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page. SSD1306 driver \u00b6 Mbed OS driver for SensorIO can be found here: SSD1306 on Github . Code \u00b6 Pin definitions \u00b6 1 2 3 4 5 6 /**** OLED pins (SPI4) ****/ OLED_CLK = PE_2 , OLED_RESET = PE_3 , OLED_CS = PE_4 , OLED_DC = PE_5 , OLED_MOSI = PE_6 , Example \u00b6 This example shows basic usage of text display and image acceleration (scrolling and inverting). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \"SPI.h\" #include \"ssd1306.h\" #include \"ssd1306spibus.h\" #include \"mbed_wait_api.h\" using mbed :: SPI ; constexpr size_t OLED_WIDTH = 128 ; constexpr size_t OLED_HEIGHT = 32 ; int main ( int argc , char ** argv ) { SPI spi ( OLED_MOSI , OLED_DC , OLED_CLK ); Ssd1306SPIBus spiBus ( spi , OLED_RESET , OLED_CS , OLED_DC ); Ssd1306 oled ( spiBus , OLED_WIDTH , OLED_HEIGHT ); while ( 1 ) { oled . clear (); oled . printf ( FontSize :: BIG , 0 , // X offset in pixels 0 , // Y offset in pixels \"SensorIO\" ); wait ( 2 ); oled . scrollUp (); wait ( 2 ); oled . stopScroll (); oled . invert (); wait ( 2 ); oled . clear (); wait ( 2 ); } } Example main.cpp file can be downloaded from here .","title":"OLED display"},{"location":"development-boards/sensorio/oled/#oled-display","text":"","title":"OLED display"},{"location":"development-boards/sensorio/oled/#description","text":"SensorIO's display is a monochrome (white) OLED screen with 128x32 pixels and based on SSD1306 controller. Communication is carried over SPI interface ( SPI4 ).","title":"Description"},{"location":"development-boards/sensorio/oled/#part-details","text":"Manufacturer: Univision Technology Inc. Part number: UG-2832HSSWEG04 Datasheet: link","title":"Part details"},{"location":"development-boards/sensorio/oled/#code-example","text":"Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page.","title":"Code example"},{"location":"development-boards/sensorio/oled/#ssd1306-driver","text":"Mbed OS driver for SensorIO can be found here: SSD1306 on Github .","title":"SSD1306 driver"},{"location":"development-boards/sensorio/oled/#code","text":"","title":"Code"},{"location":"development-boards/sensorio/oled/#pin-definitions","text":"1 2 3 4 5 6 /**** OLED pins (SPI4) ****/ OLED_CLK = PE_2 , OLED_RESET = PE_3 , OLED_CS = PE_4 , OLED_DC = PE_5 , OLED_MOSI = PE_6 ,","title":"Pin definitions"},{"location":"development-boards/sensorio/oled/#example","text":"This example shows basic usage of text display and image acceleration (scrolling and inverting). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \"SPI.h\" #include \"ssd1306.h\" #include \"ssd1306spibus.h\" #include \"mbed_wait_api.h\" using mbed :: SPI ; constexpr size_t OLED_WIDTH = 128 ; constexpr size_t OLED_HEIGHT = 32 ; int main ( int argc , char ** argv ) { SPI spi ( OLED_MOSI , OLED_DC , OLED_CLK ); Ssd1306SPIBus spiBus ( spi , OLED_RESET , OLED_CS , OLED_DC ); Ssd1306 oled ( spiBus , OLED_WIDTH , OLED_HEIGHT ); while ( 1 ) { oled . clear (); oled . printf ( FontSize :: BIG , 0 , // X offset in pixels 0 , // Y offset in pixels \"SensorIO\" ); wait ( 2 ); oled . scrollUp (); wait ( 2 ); oled . stopScroll (); oled . invert (); wait ( 2 ); oled . clear (); wait ( 2 ); } } Example main.cpp file can be downloaded from here .","title":"Example"},{"location":"development-boards/sensorio/pinouts/","text":"Board Pinouts \u00b6 The MCU PinNames mappings are listed as [PortName_Bit]. When available, the alternative functions are described (as extra ADC channels, CAN Bus or I2S for audio for instance). mbed target pin-mapping In the mbed platform, the pin mappings are done in the SensorIO target ( mbed-os/targets/TARGET_STM/TARGET_STM32F4/TARGET_STM32F413xH/TARGET_SENSORIO/PinNames.h ) OnBoard interfaces \u00b6 RGB LED \u00b6 PinName Signal Name Description / Alternative functions PF_3 RED_LED DigitalOut / TIM5_CH1 (PWM) PF_4 GREEN_LED DigitalOut / TIM5_CH2 (PWM) PF_5 BLUE_LED DigitalOut / TIM5_CH3 (PWM) User Button \u00b6 PinName Signal Name Description / Alternative functions PC_13 BUTTON_1 DigitalIn / InterruptIn IRQ on input change In the STM32F4XX, all the I/Os can be configured to trigger interrupts when configured as inputs ( InterruptIn in mbed) Relays \u00b6 PinName Signal Name Description PG_2 RELAY_1 DigitalOut PG_3 RELAY_2 DigitalOut Sensors \u00b6 PinName Signal Name Description PF_0 I2C_SDA Sensors I2C data line PF_1 I2C_SCL Sensors I2C clock line PD_4 ACCEL_INT1 BMA253 IRQ #1 PD_5 ACCEL_INT2 BMA253 IRQ #2 PG_13 LTR303_INT Luminosity sensor IRQ OLED display \u00b6 PinName Signal Name Description PE_6 OLED_MOSI SPI4 data PE_2 OLED_SCK SPI4 clock PE_5 OLED_D/C# Data / #command PE_3 OLED_RESET Display reset line PE_4 OLED_CS SPI4 Chip Select Micro-SD / MMC \u00b6 PinName Signal Name Description PC_8 MMC_D0 MMC Data 0 PC_9 MMC_D1 MMC Data 1 PC_10 MMC_D2 MMC Data 2 PC_11 MMC_D3/CD MMC Data 3 / Card Detect PC_12 MMC_CLK MMC bus clock PD_2 MMC_CMD MMC command / data CC3120 WiFi \u00b6 PinName Signal Name Description PE_8 CC_NRESET CC3120 #Reset PE_9 CC_IRQ CC3120 Interrupt PE_10 CC_RESTORE Ext.Flash Factory Restore PA_4 CC_SPI_CS SPI1_NSS (Chip Select) PA_5 CC_SPI_CLK SPI1 Clock PA_6 CC_SPI_MISO SPI1 MISO PA_7 CC_SPI_MOSI SPI1 MOSI Expansion interfaces \u00b6 MikroBUS \u00b6 Shared signals The I2C (I2C1) and SPI (SPI5) buses are shared by both connectors (but not with other interfaces). This should be taken in account if these pins want to be used as digital IN/OUT (in this case, only one MikroBUS interface should be used). MB1 \u00b6 PinName Signal Name Description / Alternative functions PB_6 MB_I2C_SCL I2C1 Clock (shared with MB2) PB_7 MB_I2C_SDA I2C1 Data (shared with MB2) PE_12 MB_SPI_SCK SPI5 Clock (shared with MB2) PE_13 MB_SPI_MISO SPI5 MISO (shared with MB2) PE_14 MB_SPI_MOSI SPI5 MOSI (shared with MB2) PB_1 MB1_SPI_CS SPI Chip Select / PWM / AnalogIn (ADC1_IN9) PG_14 MB1_RST Reset / UART6_TX PD_0 MB2_INT IRQ (InterruptIn) / UART4_RX / CAN1_RX PC_1 MB1_AN AnalogIn (ADC1_IN11) PB_14 MB1_PWM PWM out PF_6 MB1_UART_RX UART7 RXD / PWM PF_7 MB1_UART_TX UART7 TXD / PWM MB2 \u00b6 PinName Signal Name Description / Alternative functions PB_6 MB_I2C_SCL I2C1 clock (shared with MB1) PB_7 MB_I2C_SDA I2C1 data (shared with MB1) PE_12 MB_SPI_SCK SPI5 Clock (shared with MB1) PE_13 MB_SPI_MISO SPI5 MISO (shared with MB1) PE_14 MB_SPI_MOSI SPI5 MOSI (shared with MB1) PE_11 MB2_SPI_CS SPI Chip Select / PWM PG_15 MB2_RST Reset / I/O PC_6 MB2_INT IRQ (InterruptIn) / PWM / I2C_SCL / I2S2_MCK / USART6_TX PC_2 MB2_AN AnalogIn (ADC1_IN12) PB_15 MB2_PWM PWM out / I2S2_SD PB_12 MB2_UART_RX UART5 RXD / I2S2_CK / CAN2_RX PB_13 MB2_UART_TX UART5 TXD / PWM / I2S2_CK / CAN2_TX Grove \u00b6 Pin multiplexing This interface multiplexes the UART, I2C, Analog and PWM lines to the external connectors. Please check the Grove description for information on how to configure them. Grove 1 \u00b6 PinName Signal Name Description / Alternative functions I2C: PF_14 I2CFMP1_SCL I2C Clock (shared with Grove 2) PF_15 I2CFMP1_SDA I2C Data (shared with Grove 2) UART: PE_0 GROVE1_RXD UART8_RX PE_1 GROVE1_TXD UART8_TX Analog: PC_3 GROVE1_AI1 Pin#1 Analog Input (ADC1_IN13) PC_4 GROVE1_AI2 Pin#2 Analog Input (ADC1_IN14) PWM / I/O: PD_14 GROVE1_P1_PWM Pin#1 PWM out PD_15 GROVE1_P2_PWM Pin#2 PWM out MUX & Power control PD_10 GROVE1_MUXA Multiplexer pin A PD_11 GROVE1_MUXB Multiplexer pin B PG_9 GROVE1_SW_5V VCC control switch (3.3V/5V) Grove 2 \u00b6 PinName Signal Name Description / Alternative functions I2C: PF_14 I2CFMP1_SCL I2C Clock (shared with Grove 1) PF_15 I2CFMP1_SDA I2C Data (shared with Grove 1) UART: PG_0 GROVE2_RXD UART9_RX PG_1 GROVE2_TXD UART9_TX Analog: PB_0 GROVE2_AI1 Pin#1 Analog Input (ADC1_IN8) PC_5 GROVE2_AI2 Pin#2 Analog Input (ADC1_IN15) PWM / I/O: PD_12 GROVE2_P1_PWM Pin#1 PWM out PD_13 GROVE2_P2_PWM Pin#2 PWM out MUX & Power control PG_4 GROVE1_MUXA Multiplexer pin A PG_5 GROVE1_MUXB Multiplexer pin B PG_10 GROVE1_SW_5V VCC control switch (3.3V/5V) Arduino R3 \u00b6 Analog multiplexing This interface uses an analog multiplexer for the Analog Inputs A0 to A5. Check the Arduino interface for more information. PinName Signal Name Description / Alternative functions PB_4 (1) ARD_A4/SDA I2C3_SDA / PWM / UART7_TX / CAN3_TX PA_8 (1) ARD_A5/SCL I2C3_SCL / PWM / UART7_TX / CAN3_RX PA_1 ARD_D0/RX UART4_RX / PWM / ADC1_IN1 PA_0 ARD_D1/TX UART4_TX / PWM / ADC1_IN0 PF_9 ARD_D2 UART8_RX / PWM PA_2 ARD_D3 PWM (TIM9_CH1) PF_10 ARD_D4 PWM (TIM5_CH4) PA_3 ARD_D5 PWM (TIM9_CH2) / UART2_TX / I2S2_CKIN / ADC1_IN2 PB_10 ARD_D6 PWM (TIM2_CH3) / I2S3_MCK / USART3_TX PF_11 ARD_D7 I/O PF_12 ARD_D8 I/O PB_11 ARD_D9 PWM (TIM2_CH4) / I2S3_MCK PA_11 ARD_D10/CS SPI2_NSS (Chip Select) / PWM / CAN1_RX / UART6_TX PA_10 ARD_D11/MOSI SPI2_MOSI / PWM / UART1_RX PA_12 ARD_D12/MISO SPI2_MISO / UART6_RX/ CAN1_TX/ UART4_RX PC_0 ARD_ANALOG_IN Analog inputs [A0:A5] + Calib LOW/HIGH Analog MUX control PG_6 ARD_MUX_A Analog Multiplexer pin A PG_7 ARD_MUX_B Analog Multiplexer pin B PG_8 ARD_MUX_C Analog Multiplexer pin C Shared signals (1) In the Arduino UNO R3 interface, the pin A4 is shared with D14 and A5 is shared with D15. Therefore, if these pins are to be used as Analog Inputs, the correspondent I2C pins PB_4 and PA_8 need to be configured as Input (high-impedance, default behaviour).","title":"Pinouts"},{"location":"development-boards/sensorio/pinouts/#board-pinouts","text":"The MCU PinNames mappings are listed as [PortName_Bit]. When available, the alternative functions are described (as extra ADC channels, CAN Bus or I2S for audio for instance). mbed target pin-mapping In the mbed platform, the pin mappings are done in the SensorIO target ( mbed-os/targets/TARGET_STM/TARGET_STM32F4/TARGET_STM32F413xH/TARGET_SENSORIO/PinNames.h )","title":"Board Pinouts"},{"location":"development-boards/sensorio/pinouts/#onboard-interfaces","text":"","title":"OnBoard interfaces"},{"location":"development-boards/sensorio/pinouts/#rgb-led","text":"PinName Signal Name Description / Alternative functions PF_3 RED_LED DigitalOut / TIM5_CH1 (PWM) PF_4 GREEN_LED DigitalOut / TIM5_CH2 (PWM) PF_5 BLUE_LED DigitalOut / TIM5_CH3 (PWM)","title":"RGB LED"},{"location":"development-boards/sensorio/pinouts/#user-button","text":"PinName Signal Name Description / Alternative functions PC_13 BUTTON_1 DigitalIn / InterruptIn IRQ on input change In the STM32F4XX, all the I/Os can be configured to trigger interrupts when configured as inputs ( InterruptIn in mbed)","title":"User Button"},{"location":"development-boards/sensorio/pinouts/#relays","text":"PinName Signal Name Description PG_2 RELAY_1 DigitalOut PG_3 RELAY_2 DigitalOut","title":"Relays"},{"location":"development-boards/sensorio/pinouts/#sensors","text":"PinName Signal Name Description PF_0 I2C_SDA Sensors I2C data line PF_1 I2C_SCL Sensors I2C clock line PD_4 ACCEL_INT1 BMA253 IRQ #1 PD_5 ACCEL_INT2 BMA253 IRQ #2 PG_13 LTR303_INT Luminosity sensor IRQ","title":"Sensors"},{"location":"development-boards/sensorio/pinouts/#oled-display","text":"PinName Signal Name Description PE_6 OLED_MOSI SPI4 data PE_2 OLED_SCK SPI4 clock PE_5 OLED_D/C# Data / #command PE_3 OLED_RESET Display reset line PE_4 OLED_CS SPI4 Chip Select","title":"OLED display"},{"location":"development-boards/sensorio/pinouts/#micro-sd-mmc","text":"PinName Signal Name Description PC_8 MMC_D0 MMC Data 0 PC_9 MMC_D1 MMC Data 1 PC_10 MMC_D2 MMC Data 2 PC_11 MMC_D3/CD MMC Data 3 / Card Detect PC_12 MMC_CLK MMC bus clock PD_2 MMC_CMD MMC command / data","title":"Micro-SD / MMC"},{"location":"development-boards/sensorio/pinouts/#cc3120-wifi","text":"PinName Signal Name Description PE_8 CC_NRESET CC3120 #Reset PE_9 CC_IRQ CC3120 Interrupt PE_10 CC_RESTORE Ext.Flash Factory Restore PA_4 CC_SPI_CS SPI1_NSS (Chip Select) PA_5 CC_SPI_CLK SPI1 Clock PA_6 CC_SPI_MISO SPI1 MISO PA_7 CC_SPI_MOSI SPI1 MOSI","title":"CC3120 WiFi"},{"location":"development-boards/sensorio/pinouts/#expansion-interfaces","text":"","title":"Expansion interfaces"},{"location":"development-boards/sensorio/pinouts/#mikrobus","text":"Shared signals The I2C (I2C1) and SPI (SPI5) buses are shared by both connectors (but not with other interfaces). This should be taken in account if these pins want to be used as digital IN/OUT (in this case, only one MikroBUS interface should be used).","title":"MikroBUS"},{"location":"development-boards/sensorio/pinouts/#mb1","text":"PinName Signal Name Description / Alternative functions PB_6 MB_I2C_SCL I2C1 Clock (shared with MB2) PB_7 MB_I2C_SDA I2C1 Data (shared with MB2) PE_12 MB_SPI_SCK SPI5 Clock (shared with MB2) PE_13 MB_SPI_MISO SPI5 MISO (shared with MB2) PE_14 MB_SPI_MOSI SPI5 MOSI (shared with MB2) PB_1 MB1_SPI_CS SPI Chip Select / PWM / AnalogIn (ADC1_IN9) PG_14 MB1_RST Reset / UART6_TX PD_0 MB2_INT IRQ (InterruptIn) / UART4_RX / CAN1_RX PC_1 MB1_AN AnalogIn (ADC1_IN11) PB_14 MB1_PWM PWM out PF_6 MB1_UART_RX UART7 RXD / PWM PF_7 MB1_UART_TX UART7 TXD / PWM","title":"MB1"},{"location":"development-boards/sensorio/pinouts/#mb2","text":"PinName Signal Name Description / Alternative functions PB_6 MB_I2C_SCL I2C1 clock (shared with MB1) PB_7 MB_I2C_SDA I2C1 data (shared with MB1) PE_12 MB_SPI_SCK SPI5 Clock (shared with MB1) PE_13 MB_SPI_MISO SPI5 MISO (shared with MB1) PE_14 MB_SPI_MOSI SPI5 MOSI (shared with MB1) PE_11 MB2_SPI_CS SPI Chip Select / PWM PG_15 MB2_RST Reset / I/O PC_6 MB2_INT IRQ (InterruptIn) / PWM / I2C_SCL / I2S2_MCK / USART6_TX PC_2 MB2_AN AnalogIn (ADC1_IN12) PB_15 MB2_PWM PWM out / I2S2_SD PB_12 MB2_UART_RX UART5 RXD / I2S2_CK / CAN2_RX PB_13 MB2_UART_TX UART5 TXD / PWM / I2S2_CK / CAN2_TX","title":"MB2"},{"location":"development-boards/sensorio/pinouts/#grove","text":"Pin multiplexing This interface multiplexes the UART, I2C, Analog and PWM lines to the external connectors. Please check the Grove description for information on how to configure them.","title":"Grove"},{"location":"development-boards/sensorio/pinouts/#grove-1","text":"PinName Signal Name Description / Alternative functions I2C: PF_14 I2CFMP1_SCL I2C Clock (shared with Grove 2) PF_15 I2CFMP1_SDA I2C Data (shared with Grove 2) UART: PE_0 GROVE1_RXD UART8_RX PE_1 GROVE1_TXD UART8_TX Analog: PC_3 GROVE1_AI1 Pin#1 Analog Input (ADC1_IN13) PC_4 GROVE1_AI2 Pin#2 Analog Input (ADC1_IN14) PWM / I/O: PD_14 GROVE1_P1_PWM Pin#1 PWM out PD_15 GROVE1_P2_PWM Pin#2 PWM out MUX & Power control PD_10 GROVE1_MUXA Multiplexer pin A PD_11 GROVE1_MUXB Multiplexer pin B PG_9 GROVE1_SW_5V VCC control switch (3.3V/5V)","title":"Grove 1"},{"location":"development-boards/sensorio/pinouts/#grove-2","text":"PinName Signal Name Description / Alternative functions I2C: PF_14 I2CFMP1_SCL I2C Clock (shared with Grove 1) PF_15 I2CFMP1_SDA I2C Data (shared with Grove 1) UART: PG_0 GROVE2_RXD UART9_RX PG_1 GROVE2_TXD UART9_TX Analog: PB_0 GROVE2_AI1 Pin#1 Analog Input (ADC1_IN8) PC_5 GROVE2_AI2 Pin#2 Analog Input (ADC1_IN15) PWM / I/O: PD_12 GROVE2_P1_PWM Pin#1 PWM out PD_13 GROVE2_P2_PWM Pin#2 PWM out MUX & Power control PG_4 GROVE1_MUXA Multiplexer pin A PG_5 GROVE1_MUXB Multiplexer pin B PG_10 GROVE1_SW_5V VCC control switch (3.3V/5V)","title":"Grove 2"},{"location":"development-boards/sensorio/pinouts/#arduino-r3","text":"Analog multiplexing This interface uses an analog multiplexer for the Analog Inputs A0 to A5. Check the Arduino interface for more information. PinName Signal Name Description / Alternative functions PB_4 (1) ARD_A4/SDA I2C3_SDA / PWM / UART7_TX / CAN3_TX PA_8 (1) ARD_A5/SCL I2C3_SCL / PWM / UART7_TX / CAN3_RX PA_1 ARD_D0/RX UART4_RX / PWM / ADC1_IN1 PA_0 ARD_D1/TX UART4_TX / PWM / ADC1_IN0 PF_9 ARD_D2 UART8_RX / PWM PA_2 ARD_D3 PWM (TIM9_CH1) PF_10 ARD_D4 PWM (TIM5_CH4) PA_3 ARD_D5 PWM (TIM9_CH2) / UART2_TX / I2S2_CKIN / ADC1_IN2 PB_10 ARD_D6 PWM (TIM2_CH3) / I2S3_MCK / USART3_TX PF_11 ARD_D7 I/O PF_12 ARD_D8 I/O PB_11 ARD_D9 PWM (TIM2_CH4) / I2S3_MCK PA_11 ARD_D10/CS SPI2_NSS (Chip Select) / PWM / CAN1_RX / UART6_TX PA_10 ARD_D11/MOSI SPI2_MOSI / PWM / UART1_RX PA_12 ARD_D12/MISO SPI2_MISO / UART6_RX/ CAN1_TX/ UART4_RX PC_0 ARD_ANALOG_IN Analog inputs [A0:A5] + Calib LOW/HIGH Analog MUX control PG_6 ARD_MUX_A Analog Multiplexer pin A PG_7 ARD_MUX_B Analog Multiplexer pin B PG_8 ARD_MUX_C Analog Multiplexer pin C Shared signals (1) In the Arduino UNO R3 interface, the pin A4 is shared with D14 and A5 is shared with D15. Therefore, if these pins are to be used as Analog Inputs, the correspondent I2C pins PB_4 and PA_8 need to be configured as Input (high-impedance, default behaviour).","title":"Arduino R3"},{"location":"development-boards/sensorio/relays/","text":"Relays \u00b6 Description \u00b6 SensorIO has 2 on-board, normally opened (1-Form-A) photorelays that can be used as programmable switches for devices with power supply up to 26Vdc or 18Vac and up to 2A. Part details \u00b6 Manufacturer: Toschiba Corporation Part number: TLP241A Datasheet: link Code example \u00b6 Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page. Relay driver \u00b6 Relays do not need external driver - only Mbed OS built-in DigitalOut class is required. Code \u00b6 Pin definitions \u00b6 1 2 3 /**** Relay pins ****/ RELAY_1 = PG_2 , RELAY_2 = PG_3 , Example \u00b6 In this example user button is used to toggle state of RELAY_1 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \"mbed_events.h\" #include \"DigitalOut.h\" #include \"InterruptIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); events :: EventQueue scheduler ; mbed :: DigitalOut relay ( RELAY_1 ); void relayStatus ( int status ) { console . printf ( \"Relay is %s \\r\\n \" , ( status == 1 ) ? \"ON\" : \"OFF\" ); } void buttonPressed () { // toggle relay state relay = ! relay ; // log relay state via Serial (via EventLoop) scheduler . call ( & relayStatus , relay ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); mbed :: InterruptIn button ( USER_BUTTON ); // attach function to button press button . fall ( & buttonPressed ); // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here .","title":"Relays"},{"location":"development-boards/sensorio/relays/#relays","text":"","title":"Relays"},{"location":"development-boards/sensorio/relays/#description","text":"SensorIO has 2 on-board, normally opened (1-Form-A) photorelays that can be used as programmable switches for devices with power supply up to 26Vdc or 18Vac and up to 2A.","title":"Description"},{"location":"development-boards/sensorio/relays/#part-details","text":"Manufacturer: Toschiba Corporation Part number: TLP241A Datasheet: link","title":"Part details"},{"location":"development-boards/sensorio/relays/#code-example","text":"Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page.","title":"Code example"},{"location":"development-boards/sensorio/relays/#relay-driver","text":"Relays do not need external driver - only Mbed OS built-in DigitalOut class is required.","title":"Relay driver"},{"location":"development-boards/sensorio/relays/#code","text":"","title":"Code"},{"location":"development-boards/sensorio/relays/#pin-definitions","text":"1 2 3 /**** Relay pins ****/ RELAY_1 = PG_2 , RELAY_2 = PG_3 ,","title":"Pin definitions"},{"location":"development-boards/sensorio/relays/#example","text":"In this example user button is used to toggle state of RELAY_1 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \"mbed_events.h\" #include \"DigitalOut.h\" #include \"InterruptIn.h\" #include \"Serial.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); events :: EventQueue scheduler ; mbed :: DigitalOut relay ( RELAY_1 ); void relayStatus ( int status ) { console . printf ( \"Relay is %s \\r\\n \" , ( status == 1 ) ? \"ON\" : \"OFF\" ); } void buttonPressed () { // toggle relay state relay = ! relay ; // log relay state via Serial (via EventLoop) scheduler . call ( & relayStatus , relay ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); mbed :: InterruptIn button ( USER_BUTTON ); // attach function to button press button . fall ( & buttonPressed ); // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here .","title":"Example"},{"location":"development-boards/sensorio/rgbled/","text":"RGB Led \u00b6 Description \u00b6 SensorIO has one high brightness, user programmable RGB Led ( LD2 ). Each color can be switched separately via toggling a pin or via PWM. Code example \u00b6 Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page. RGB Led driver \u00b6 RGB Led driver via PWM can be downloaded here (header only library): link . Led control via pin toggling can be done with Mbed OS built-in DigitalOut class. Code \u00b6 Pin definitions \u00b6 1 2 3 4 5 6 7 8 RGB_RED = PF_3 , // TIM5_CH1 RGB_GREEN = PF_4 , // TIM5_CH2 RGB_BLUE = PF_5 , // TIM5_CH3 LED1 = RGB_GREEN , // Green LED2 = RGB_BLUE , // Blue LED3 = RGB_RED , // Red LED4 = LED1 , LED_RED = LED3 , Example \u00b6 In this example user button is used to turn on and off RGB Led which toggles colors in HSV palette. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \"mbed_events.h\" #include \"InterruptIn.h\" #include \"Serial.h\" #include \"rgbled.h\" #include \"Ticker.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); events :: EventQueue scheduler ; mbed :: Ticker tickColor ; RGBLed rgb ( RGB_RED , RGB_GREEN , RGB_BLUE ); bool ledOn = false ; // Color toggling with HSV palette float h = 0.0f ; float s = 0.75f ; float v = 0.005f ; void changeColor () { if ( ledOn ) { rgb . set ( h , s , v ); h += 0.44f ; if ( h > 360.0f ) { h = 0.0f ; } } else { rgb . set ( 0.0f , 0.0f , 0.0f ); } } void scheduleColorChange () { scheduler . call ( & changeColor ); } void rgbLedStatus ( int status ) { console . printf ( \"RGB Led is %s \\r\\n \" , ( status == 1 ) ? \"ON\" : \"OFF\" ); } void buttonPressed () { // toggle RGB Led state ledOn = ! ledOn ; // log RGB Led state via Serial (via EventLoop) scheduler . call ( & rgbLedStatus , ledOn ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); mbed :: InterruptIn button ( USER_BUTTON ); // attach function to button press button . fall ( & buttonPressed ); tickColor . attach ( & scheduleColorChange , 1.0f / 60.0f ); // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here .","title":"RGB Led"},{"location":"development-boards/sensorio/rgbled/#rgb-led","text":"","title":"RGB Led"},{"location":"development-boards/sensorio/rgbled/#description","text":"SensorIO has one high brightness, user programmable RGB Led ( LD2 ). Each color can be switched separately via toggling a pin or via PWM.","title":"Description"},{"location":"development-boards/sensorio/rgbled/#code-example","text":"Compiling example This example is based on Mbed OS and requires a simple setup. For full description check Code Setup page.","title":"Code example"},{"location":"development-boards/sensorio/rgbled/#rgb-led-driver","text":"RGB Led driver via PWM can be downloaded here (header only library): link . Led control via pin toggling can be done with Mbed OS built-in DigitalOut class.","title":"RGB Led driver"},{"location":"development-boards/sensorio/rgbled/#code","text":"","title":"Code"},{"location":"development-boards/sensorio/rgbled/#pin-definitions","text":"1 2 3 4 5 6 7 8 RGB_RED = PF_3 , // TIM5_CH1 RGB_GREEN = PF_4 , // TIM5_CH2 RGB_BLUE = PF_5 , // TIM5_CH3 LED1 = RGB_GREEN , // Green LED2 = RGB_BLUE , // Blue LED3 = RGB_RED , // Red LED4 = LED1 , LED_RED = LED3 ,","title":"Pin definitions"},{"location":"development-boards/sensorio/rgbled/#example","text":"In this example user button is used to turn on and off RGB Led which toggles colors in HSV palette. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \"mbed_events.h\" #include \"InterruptIn.h\" #include \"Serial.h\" #include \"rgbled.h\" #include \"Ticker.h\" mbed :: Serial console ( SERIAL_TX , SERIAL_RX , 115200 ); events :: EventQueue scheduler ; mbed :: Ticker tickColor ; RGBLed rgb ( RGB_RED , RGB_GREEN , RGB_BLUE ); bool ledOn = false ; // Color toggling with HSV palette float h = 0.0f ; float s = 0.75f ; float v = 0.005f ; void changeColor () { if ( ledOn ) { rgb . set ( h , s , v ); h += 0.44f ; if ( h > 360.0f ) { h = 0.0f ; } } else { rgb . set ( 0.0f , 0.0f , 0.0f ); } } void scheduleColorChange () { scheduler . call ( & changeColor ); } void rgbLedStatus ( int status ) { console . printf ( \"RGB Led is %s \\r\\n \" , ( status == 1 ) ? \"ON\" : \"OFF\" ); } void buttonPressed () { // toggle RGB Led state ledOn = ! ledOn ; // log RGB Led state via Serial (via EventLoop) scheduler . call ( & rgbLedStatus , ledOn ); } int main ( int argc , char ** argv ) { console . printf ( \"This is SensorIO \\r\\n \" ); mbed :: InterruptIn button ( USER_BUTTON ); // attach function to button press button . fall ( & buttonPressed ); tickColor . attach ( & scheduleColorChange , 1.0f / 60.0f ); // running event loop scheduler . dispatch_forever (); } Example main.cpp file can be downloaded from here .","title":"Example"},{"location":"development-boards/sensorio/schematics/","text":"Circuit Schematics \u00b6 The full SensorIO design Schematics can be found here , and as a quick reference, some of the relevant sections are detailed below: Power supply \u00b6 Power input The primary power source during development is the USB Micro B connector. The figure below shows the connections for USB connector (P1) and ESD protection diodes (D1). The ferrite L2 helps to reduce noise coming from the USB shielding. The USB data lines are routed to the STM32F103 (ST-Link probe) . The VBUS rail is connected through the AP22802A load switch, which provides an over-load current protection: when the current reaches 2A, limits the current to 1A until the short-circuit state is resolved: Alternative 5V input If the device needs to be installed in a permanent setup, it is also possible to provide 5V power through any of the MikroBUS sockets' +5V pins. Please note that, in case these pins are used to power the board, the AP22802A protection will be bypassed, therefore care must be taken to avoid damages caused by short circuits. To convert the 5V from to the 3.3V that most of the sub-circuits need, the board uses the NCP6324B from On-Semiconductor (U2). The NCP6324B is a 3MHz, 2A synchronous buck-converter with high efficiency and low ripple. The feedback resistors R2 and R3 set the output voltage close to 3.3V. The red LED (LD3) is turned on when the VCC_3V3 power bus is active. ST-Link \u00b6 The board integrates the ST-Link/V2-1 from STMicroelectronics . This debugger probe is based on the STM32F103 Cortex\u00ae-M3 MCU, running at 72 MHz. This MCU interfaces directly to the USB connector. It uses a ST-Micro proprietary protocol to transfer the SWD/JTAG protocol data, control the Reset/Run/Stop states of the target MCU and converts a Virtual Comm Port into the physical UART connected to the target MCU (STLK_TX and STLK_RX lines) which can be used by the application to print logging data or receive commands from the host PC. The NPN transistor (Q1) is used to push the USB_DP line to force a USB re-enumeration after a firmware update. The bi-color LED (LD1) indicates the state of the ST-Link interface: LD1 status indication: Blinking RED : the first USB enumeration with the PC is taking place RED : communication between the PC and ST-LINK/V2 is established (end of enumeration) Blinking GREEN / RED : data being exchanged between the target and the PC GREEN : the last communication has been successful ORANGE : ST-LINK/V2 communication with the target has failed. Please check the tools section for more information on how to flash a binary and connect to a GDB client. Main MCU \u00b6 The target MCU uses the STM32F413Z HJ6 version (UFBGA144 packaging version, 1.5MB Flash, 320KB RAM). Please check the board pinouts section and the SensorIO schematics for a full reference of the exposed I/Os. Clocks \u00b6 The MCU uses 2 external crystals for the reference oscillators: Y4 (16 MHz): used as a precise main clock source (the MCU has a less-precise internal RC-oscillator): Y3 (32.768 kHz) which can be used to mantain a real-time clock or power management: Analog VREF \u00b6 The image below shows the connections for the Analog supply and VREF pins used by the internal 12-bit ADC: The LC filter (L10 and C86) attenuates the \"digital\" noise that can be present in the VCC power rail. VREF+ is wired to the AnalogVCC and decoupled by C87 and C88. With this configuration, the input range for the ADC converter will be [0-3.3V]. Please refer to the expansion interfaces section for more information on using the analog inputs. RGB LED \u00b6 The User Status (LD2) is a RGB LED (a red, a blue and a green LEDs packaged together). Each LED is controlled separately. The 3 control pins are wired to the timer TIM5 CH[1:3] so the brightness can be regulated using PWM (pulse-width modulation). The snippet below shows how to use PWM to controll the brightness of the blue LED: mbed example: dimming the blue LED 1 2 3 PwmOut blueLed ( PF_5 ); //Port F bit #5 blueLed . period ( 1 / 100f ); //Set PWM frequency to 100Hz (1/100 seconds) blueLed . write ( 0.2f ); //Set Duty Cycle to 20% Push-buttons \u00b6 The board has 2 push-buttons: The MCU Reset (located next to the OLED display): A user-programmable button (S1) , wired to PC_13: The snippet below shows how configure the button to trigger an interrupt on press: mbed example: button interrupt 1 2 3 4 5 6 7 8 9 10 11 12 13 InterruptIn button ( PC_13 ); DigitalOut greenLed ( PF_4 ); void pinInt (){ greenLed = ! greenLed ; //flip the green LED on each button press } int main (){ button . fall ( & pinInt ); // attach the pinInt() function to the falling edge while ( 1 ){ // wait around, interrupts will interrupt this! printf ( \".\" ); wait ( 1 ); } } Tip: debouncing To detect a button press, remember that the mechanical action usually indroduces some signal bouncing. It's reasonable to add a delay of at least 20ms before taking any action (software debouncing). Wi-Fi \u00b6 The capture below shows the TI CC3210 Network Processor SoC and it's associated power supply and oscillator components: The CC3120 is powered by the main 3.3V rail, and integrates 3 internal DC/DC converters to generate the voltages needed for the operation of each SoC section. The main oscillator uses an external 40 MHz crystal (Y2) and a 32.768 kHz crystal (Y1) is used for power management and real-time bookkeping. An external SPI flash memory (MX25R1635FM1IL0, 16Mbit) is used to store the network stack and credentials. MCU interface \u00b6 The interfacing with the target MCU is done through the SPI bus (signals shown below). This interface contains also a \"factory restore\" pin, which can be used by the target application to restore the factory image. Factory restore In order to restore the original flash image, the CC_FACTORY_RESTORE line should to be hold in low state for minimum 8 seconds after the CC_nRESET is released. Flash programming interface \u00b6 The CC3210 exposes an extra UART which can be used to (re)program the external flash memory. These signals (along with the nHIB line) are exposed on testpoints on the back of the board. For more information on how to use this interface, refer to the SRU469C application note from TI. RF section \u00b6 The capture below shows the CC3120 RF 50\u03a9 interface. A bandpass filter centered on 2.45 GHz helps to remove unwanted noise entering the SoC. The LC-network formed by L4 and C11 performs the impedance matching from the PCB antenna to the 50 \u03a9 characteristic impedance required by the SoC. The capture below shows the return loss seen by the CC3210 RF pin. The VSWR is approximately 1.16:1 (-22 dB at the center of the WiFi band). In case that the board will be installed in a metallic box, or the WiFi range needs to be increased with a directional antenna, the circuit provides the option to use an external antenna connected to the u-Fl connector. Using an external antenna In order to route the RF signal to the u-Fl connector instead of the PCB antenna, the 0 \u03a9 resistor R5 needs to be unsoldered and installed in the R4 location. The small J1 connector is used for testing purposes, the matching test probe MXHQ87WA3000 from Murata Electronics can be used for such purposes. When the probe is connected, the connector switches off the output side. Solid State Relays \u00b6 The outputs OUT1 and OUT2 , are driven by the opto-isolated \"solid-state relay\" TLP241A from Toshiba Semiconductor . These devices consist of a MOSFET transistor optically coupled (electrically isolated) to an infrared light emitting diode. They are housed in a 4-pin DIP package. TLP241A output characteristics: ON-state current: 2 A max. continuous, 6 A pulsed (t=100 mseg, duty=10%) ON-state resistance: 150 m\u03a9 (continuous) Isolation voltage: 5,000 Vrms Maximum DC voltage: 26 V (limited by the varistor) Maximum AC voltage: 20 Vrms (limited by the varistor) The outputs are mapped to PG_2 (OUT1) and PG_3 (OUT2). The varistors R63 and R69 protect the relays from over-voltage peaks, limiting the nominal operation voltage to 26 Vdc or 20 Vrms for AC signals. The outputs schematic is shown below: Using the outputs These outputs can be used to control small DC motors (as a small water pump for your plants), AC/DC solenoid valves, or resistive loads (i.e. a termoelectric peltier element). If these outputs want to be used to control high power loads (i.e. a pump or a HVAC system) they can be used to drive contactors with 12V DC or AC coils (as the Schneider Electric LC1D12JL for example). Warning!!! The outputs' maximum voltage is 26 Vdc, DO NOT CONNECT DIRECTLY TO MAINS under any circumstance! Here is a snippet showing how to control the ouputs: mbed example: switching outputs 1 2 3 4 5 DigitalOut relay1 ( PG_2 ); relay1 = 1 ; //enable output1 wait ( 5 ); relay1 = 0 ; //disable output1 Display \u00b6 The display is a Vishay OLED-128O032D-SPP3N00000 , a monochrome 0.9 inches graphic display OLED with a resolution of 128x32 pixels. The display is interfaced to the MCU through the SPI4 bus plus a Data/#command and reset control lines. Memory card interface \u00b6 The Micro MMC/SD card socket is interfaced to the MCU through the SDIO bus. The interface is configured to use the 4-bit mode. The schematic is shown below: SWD debug connector \u00b6 As an option to using the ST-Link interface to debug and program the target MCU, the Cortex-M\u2122 10-pin connector present in the front (SWD) can be used. Debug probes like Segger's J-Link\u00ae can be attached to this connector if preferred. The D8 diode array protects the MCU from ESD. Using the SWD connector Please note that, as the SWD lines are directly shared with the ST-Link interface, if the external debugger is used, the ST-Link application shouldn't be initialized or both debuggers will compete for the SWD lines. In general, it's sufficient to not initialize the ST-Link software on the host side (OpenOCD or ST-Util). In case this situation arises, just re-connect the USB cable to fix it.","title":"Schematics"},{"location":"development-boards/sensorio/schematics/#circuit-schematics","text":"The full SensorIO design Schematics can be found here , and as a quick reference, some of the relevant sections are detailed below:","title":"Circuit Schematics"},{"location":"development-boards/sensorio/schematics/#power-supply","text":"Power input The primary power source during development is the USB Micro B connector. The figure below shows the connections for USB connector (P1) and ESD protection diodes (D1). The ferrite L2 helps to reduce noise coming from the USB shielding. The USB data lines are routed to the STM32F103 (ST-Link probe) . The VBUS rail is connected through the AP22802A load switch, which provides an over-load current protection: when the current reaches 2A, limits the current to 1A until the short-circuit state is resolved: Alternative 5V input If the device needs to be installed in a permanent setup, it is also possible to provide 5V power through any of the MikroBUS sockets' +5V pins. Please note that, in case these pins are used to power the board, the AP22802A protection will be bypassed, therefore care must be taken to avoid damages caused by short circuits. To convert the 5V from to the 3.3V that most of the sub-circuits need, the board uses the NCP6324B from On-Semiconductor (U2). The NCP6324B is a 3MHz, 2A synchronous buck-converter with high efficiency and low ripple. The feedback resistors R2 and R3 set the output voltage close to 3.3V. The red LED (LD3) is turned on when the VCC_3V3 power bus is active.","title":"Power supply"},{"location":"development-boards/sensorio/schematics/#st-link","text":"The board integrates the ST-Link/V2-1 from STMicroelectronics . This debugger probe is based on the STM32F103 Cortex\u00ae-M3 MCU, running at 72 MHz. This MCU interfaces directly to the USB connector. It uses a ST-Micro proprietary protocol to transfer the SWD/JTAG protocol data, control the Reset/Run/Stop states of the target MCU and converts a Virtual Comm Port into the physical UART connected to the target MCU (STLK_TX and STLK_RX lines) which can be used by the application to print logging data or receive commands from the host PC. The NPN transistor (Q1) is used to push the USB_DP line to force a USB re-enumeration after a firmware update. The bi-color LED (LD1) indicates the state of the ST-Link interface: LD1 status indication: Blinking RED : the first USB enumeration with the PC is taking place RED : communication between the PC and ST-LINK/V2 is established (end of enumeration) Blinking GREEN / RED : data being exchanged between the target and the PC GREEN : the last communication has been successful ORANGE : ST-LINK/V2 communication with the target has failed. Please check the tools section for more information on how to flash a binary and connect to a GDB client.","title":"ST-Link"},{"location":"development-boards/sensorio/schematics/#main-mcu","text":"The target MCU uses the STM32F413Z HJ6 version (UFBGA144 packaging version, 1.5MB Flash, 320KB RAM). Please check the board pinouts section and the SensorIO schematics for a full reference of the exposed I/Os.","title":"Main MCU"},{"location":"development-boards/sensorio/schematics/#clocks","text":"The MCU uses 2 external crystals for the reference oscillators: Y4 (16 MHz): used as a precise main clock source (the MCU has a less-precise internal RC-oscillator): Y3 (32.768 kHz) which can be used to mantain a real-time clock or power management:","title":"Clocks"},{"location":"development-boards/sensorio/schematics/#analog-vref","text":"The image below shows the connections for the Analog supply and VREF pins used by the internal 12-bit ADC: The LC filter (L10 and C86) attenuates the \"digital\" noise that can be present in the VCC power rail. VREF+ is wired to the AnalogVCC and decoupled by C87 and C88. With this configuration, the input range for the ADC converter will be [0-3.3V]. Please refer to the expansion interfaces section for more information on using the analog inputs.","title":"Analog VREF"},{"location":"development-boards/sensorio/schematics/#rgb-led","text":"The User Status (LD2) is a RGB LED (a red, a blue and a green LEDs packaged together). Each LED is controlled separately. The 3 control pins are wired to the timer TIM5 CH[1:3] so the brightness can be regulated using PWM (pulse-width modulation). The snippet below shows how to use PWM to controll the brightness of the blue LED: mbed example: dimming the blue LED 1 2 3 PwmOut blueLed ( PF_5 ); //Port F bit #5 blueLed . period ( 1 / 100f ); //Set PWM frequency to 100Hz (1/100 seconds) blueLed . write ( 0.2f ); //Set Duty Cycle to 20%","title":"RGB LED"},{"location":"development-boards/sensorio/schematics/#push-buttons","text":"The board has 2 push-buttons: The MCU Reset (located next to the OLED display): A user-programmable button (S1) , wired to PC_13: The snippet below shows how configure the button to trigger an interrupt on press: mbed example: button interrupt 1 2 3 4 5 6 7 8 9 10 11 12 13 InterruptIn button ( PC_13 ); DigitalOut greenLed ( PF_4 ); void pinInt (){ greenLed = ! greenLed ; //flip the green LED on each button press } int main (){ button . fall ( & pinInt ); // attach the pinInt() function to the falling edge while ( 1 ){ // wait around, interrupts will interrupt this! printf ( \".\" ); wait ( 1 ); } } Tip: debouncing To detect a button press, remember that the mechanical action usually indroduces some signal bouncing. It's reasonable to add a delay of at least 20ms before taking any action (software debouncing).","title":"Push-buttons"},{"location":"development-boards/sensorio/schematics/#wi-fi","text":"The capture below shows the TI CC3210 Network Processor SoC and it's associated power supply and oscillator components: The CC3120 is powered by the main 3.3V rail, and integrates 3 internal DC/DC converters to generate the voltages needed for the operation of each SoC section. The main oscillator uses an external 40 MHz crystal (Y2) and a 32.768 kHz crystal (Y1) is used for power management and real-time bookkeping. An external SPI flash memory (MX25R1635FM1IL0, 16Mbit) is used to store the network stack and credentials.","title":"Wi-Fi"},{"location":"development-boards/sensorio/schematics/#mcu-interface","text":"The interfacing with the target MCU is done through the SPI bus (signals shown below). This interface contains also a \"factory restore\" pin, which can be used by the target application to restore the factory image. Factory restore In order to restore the original flash image, the CC_FACTORY_RESTORE line should to be hold in low state for minimum 8 seconds after the CC_nRESET is released.","title":"MCU interface"},{"location":"development-boards/sensorio/schematics/#flash-programming-interface","text":"The CC3210 exposes an extra UART which can be used to (re)program the external flash memory. These signals (along with the nHIB line) are exposed on testpoints on the back of the board. For more information on how to use this interface, refer to the SRU469C application note from TI.","title":"Flash programming interface"},{"location":"development-boards/sensorio/schematics/#rf-section","text":"The capture below shows the CC3120 RF 50\u03a9 interface. A bandpass filter centered on 2.45 GHz helps to remove unwanted noise entering the SoC. The LC-network formed by L4 and C11 performs the impedance matching from the PCB antenna to the 50 \u03a9 characteristic impedance required by the SoC. The capture below shows the return loss seen by the CC3210 RF pin. The VSWR is approximately 1.16:1 (-22 dB at the center of the WiFi band). In case that the board will be installed in a metallic box, or the WiFi range needs to be increased with a directional antenna, the circuit provides the option to use an external antenna connected to the u-Fl connector. Using an external antenna In order to route the RF signal to the u-Fl connector instead of the PCB antenna, the 0 \u03a9 resistor R5 needs to be unsoldered and installed in the R4 location. The small J1 connector is used for testing purposes, the matching test probe MXHQ87WA3000 from Murata Electronics can be used for such purposes. When the probe is connected, the connector switches off the output side.","title":"RF section"},{"location":"development-boards/sensorio/schematics/#solid-state-relays","text":"The outputs OUT1 and OUT2 , are driven by the opto-isolated \"solid-state relay\" TLP241A from Toshiba Semiconductor . These devices consist of a MOSFET transistor optically coupled (electrically isolated) to an infrared light emitting diode. They are housed in a 4-pin DIP package. TLP241A output characteristics: ON-state current: 2 A max. continuous, 6 A pulsed (t=100 mseg, duty=10%) ON-state resistance: 150 m\u03a9 (continuous) Isolation voltage: 5,000 Vrms Maximum DC voltage: 26 V (limited by the varistor) Maximum AC voltage: 20 Vrms (limited by the varistor) The outputs are mapped to PG_2 (OUT1) and PG_3 (OUT2). The varistors R63 and R69 protect the relays from over-voltage peaks, limiting the nominal operation voltage to 26 Vdc or 20 Vrms for AC signals. The outputs schematic is shown below: Using the outputs These outputs can be used to control small DC motors (as a small water pump for your plants), AC/DC solenoid valves, or resistive loads (i.e. a termoelectric peltier element). If these outputs want to be used to control high power loads (i.e. a pump or a HVAC system) they can be used to drive contactors with 12V DC or AC coils (as the Schneider Electric LC1D12JL for example). Warning!!! The outputs' maximum voltage is 26 Vdc, DO NOT CONNECT DIRECTLY TO MAINS under any circumstance! Here is a snippet showing how to control the ouputs: mbed example: switching outputs 1 2 3 4 5 DigitalOut relay1 ( PG_2 ); relay1 = 1 ; //enable output1 wait ( 5 ); relay1 = 0 ; //disable output1","title":"Solid State Relays"},{"location":"development-boards/sensorio/schematics/#display","text":"The display is a Vishay OLED-128O032D-SPP3N00000 , a monochrome 0.9 inches graphic display OLED with a resolution of 128x32 pixels. The display is interfaced to the MCU through the SPI4 bus plus a Data/#command and reset control lines.","title":"Display"},{"location":"development-boards/sensorio/schematics/#memory-card-interface","text":"The Micro MMC/SD card socket is interfaced to the MCU through the SDIO bus. The interface is configured to use the 4-bit mode. The schematic is shown below:","title":"Memory card interface"},{"location":"development-boards/sensorio/schematics/#swd-debug-connector","text":"As an option to using the ST-Link interface to debug and program the target MCU, the Cortex-M\u2122 10-pin connector present in the front (SWD) can be used. Debug probes like Segger's J-Link\u00ae can be attached to this connector if preferred. The D8 diode array protects the MCU from ESD. Using the SWD connector Please note that, as the SWD lines are directly shared with the ST-Link interface, if the external debugger is used, the ST-Link application shouldn't be initialized or both debuggers will compete for the SWD lines. In general, it's sufficient to not initialize the ST-Link software on the host side (OpenOCD or ST-Util). In case this situation arises, just re-connect the USB cable to fix it.","title":"SWD debug connector"},{"location":"development-boards/sensorio/sensors/","text":"Onboard Sensors \u00b6 SensorIO integrates 3 sensor modules which can be used to measure 6 different physical variables: Bosch Sensortec BME680 \u00b6 The BME680 is a digital 4-in-1 low power gas, pressure, temperature & humidity sensor module based on proven sensing principles. It's is housed in an extremely compact metal-lid LGA package with a footprint of 3.0 \u00d7 3.0 mm2 with a maximum height of 1.00 mm. The gas sensor within the BME680 can detect a broad range of gases to measure indoor air quality for personal well being. Gases that can be detected by the BME680 include: Volatile Organic Compounds (VOC) from paints (such as formaldehyde), lacquers, paint strippers, cleaning supplies, furnishings, office equipment, glues, adhesives and alcohol. The module can be interfaced by SPI or I2C buses. In this case, the module is configured to use the I2C bus with the slave address 0x76 Temperature readings Please note that, while the temperature sensor integrated on the BME680 has been optimized for very low noise and high resolution, it's primarily used for temperature compensation of the gas. Therefore, the measured temperature reflects the internal module temperature, which is higher than the ambient temperature since the module uses a very small heater for the gas measurement operation. Ambient temperature can be estimated with certain accuracy with the proper compensation and calibration. Bosch Sensortec BMA253 \u00b6 The BMA253 is a triaxial, low-g acceleration sensor with digital output for consumer applications. It allows measurements of acceleration in three perpendicular axes. An evaluation circuitry (ASIC) converts the output of a micromechanical acceleration-sensing structure (MEMS) that works according to the differential capacitance principle. The sensor is interfaced via the I2C bus, and its slave address is 0x18 . The two interrupt lines (ACCEL_INT1 and ACCEL_INT2) can be configured independently for various motion triggers and asynchronous data readout. LiteOn LTR-303ALS \u00b6 The LTR-303ALS is a light sensor with a spectral response close to the human eye, which makes it useful for indoor luminosity control applications. This sensor converts light intensity to a digital output signal and it provides a linear response over a wide dynamic range from 0.01 lux to 64k lux and is well suited to applications under high ambient brightness. To increase the usable dynamic range, is has six configurable gain settings (1X, 2X, 4X, 8X, 48X and 96X). The sensor is also interfaced through the I2C bus and its slave address is 0x29 . The sensor integrates two photodiodes (CH0 and CH1) which responses are combined to calculate the final luminosity value. This process is performed by the driver on the MCU. The image below shows the normalized response of both channels: IRQ The sensor supports an interrupt feature that removes the need to poll the sensor for a reading which improves system efficiency.","title":"Sensors"},{"location":"development-boards/sensorio/sensors/#onboard-sensors","text":"SensorIO integrates 3 sensor modules which can be used to measure 6 different physical variables:","title":"Onboard Sensors"},{"location":"development-boards/sensorio/sensors/#bosch-sensortec-bme680","text":"The BME680 is a digital 4-in-1 low power gas, pressure, temperature & humidity sensor module based on proven sensing principles. It's is housed in an extremely compact metal-lid LGA package with a footprint of 3.0 \u00d7 3.0 mm2 with a maximum height of 1.00 mm. The gas sensor within the BME680 can detect a broad range of gases to measure indoor air quality for personal well being. Gases that can be detected by the BME680 include: Volatile Organic Compounds (VOC) from paints (such as formaldehyde), lacquers, paint strippers, cleaning supplies, furnishings, office equipment, glues, adhesives and alcohol. The module can be interfaced by SPI or I2C buses. In this case, the module is configured to use the I2C bus with the slave address 0x76 Temperature readings Please note that, while the temperature sensor integrated on the BME680 has been optimized for very low noise and high resolution, it's primarily used for temperature compensation of the gas. Therefore, the measured temperature reflects the internal module temperature, which is higher than the ambient temperature since the module uses a very small heater for the gas measurement operation. Ambient temperature can be estimated with certain accuracy with the proper compensation and calibration.","title":"Bosch Sensortec BME680"},{"location":"development-boards/sensorio/sensors/#bosch-sensortec-bma253","text":"The BMA253 is a triaxial, low-g acceleration sensor with digital output for consumer applications. It allows measurements of acceleration in three perpendicular axes. An evaluation circuitry (ASIC) converts the output of a micromechanical acceleration-sensing structure (MEMS) that works according to the differential capacitance principle. The sensor is interfaced via the I2C bus, and its slave address is 0x18 . The two interrupt lines (ACCEL_INT1 and ACCEL_INT2) can be configured independently for various motion triggers and asynchronous data readout.","title":"Bosch Sensortec BMA253"},{"location":"development-boards/sensorio/sensors/#liteon-ltr-303als","text":"The LTR-303ALS is a light sensor with a spectral response close to the human eye, which makes it useful for indoor luminosity control applications. This sensor converts light intensity to a digital output signal and it provides a linear response over a wide dynamic range from 0.01 lux to 64k lux and is well suited to applications under high ambient brightness. To increase the usable dynamic range, is has six configurable gain settings (1X, 2X, 4X, 8X, 48X and 96X). The sensor is also interfaced through the I2C bus and its slave address is 0x29 . The sensor integrates two photodiodes (CH0 and CH1) which responses are combined to calculate the final luminosity value. This process is performed by the driver on the MCU. The image below shows the normalized response of both channels: IRQ The sensor supports an interrupt feature that removes the need to poll the sensor for a reading which improves system efficiency.","title":"LiteOn LTR-303ALS"},{"location":"development-boards/sensorio/tools/","text":"Tools \u00b6 SensorIO board is equipped with STM32F413ZH MCU so it can work with many different RTOSs or even bare metal. This guide (and other examples in this documentation) will concentrate on Mbed OS and command line tooling, which can be easily integrated into any IDE. Mbed CLI \u00b6 Software requirements \u00b6 Python 2.7.11 or 3.6.0 . Other python versions might work, but mbed-cli is tested with those two. Compiler: Mbed OS supports several toolchains, both free and paid (ARM Compiler, IAR, GNU Arm, and more), but all examples in this documentation are based and tested with GNU Arm Embedded Toolchain . Installation \u00b6 Create a virtualenv for mbed-cli : With Python 2.7.11: 1 virtualenv -p python2.7 mbed with Python 3.6.0: 1 virtualenv -p python3.6 mbed Activate virtual environment on macOS/Linux: 1 source mbed/bin/activate on Windows: 1 mbed\\Scripts\\activate Install mbed-cli : 1 pip install mbed-cli pip installs a release version of mbed-cli , you can choose however to install a development version - instructions are here . GNU Arm Embedded Toolchain \u00b6 GNU Arm Embedded Toolchain can be downloaded directly from ARM . Mbed OS requires 6-2017-q2-update , however SensorIO firmware is also tested with 7-2018-q2-update version. For installation instructions please refer to readme file in compiler package for your operating system. OpenOCD \u00b6 OpenOCD is an open source debugging tool that supports numerous debugger interfaces and microcontrollers. Base installation instructions are available on Getting OpenOCD web page. SensorIO comes with an onboard ST-Link V2 debugger, which is working with OpenOCD, however this functionality has to be enabled during OpenOCD build. If a binary provided for you operating system is not able to work with SensorIO, it is possible to compile OpenOCD from source - here are official instructions . SensorIO is tested with custom binary built from source and following configuration: 1 ./configure --enable-ftdi --enable-ti-icdi --enable-stlink --enable-cmsis-dap --enable-jlink --enable-openjtag --disable-verbose-usb-comms --disable-verbose-usb-io Segger JLink \u00b6 SensorIO provides a 10 pin JTAG/SWD header that can be used to connect external debuggers. Segger JLink probes work well with SensorIO and Segger software can be downloaded from their website .","title":"Tools"},{"location":"development-boards/sensorio/tools/#tools","text":"SensorIO board is equipped with STM32F413ZH MCU so it can work with many different RTOSs or even bare metal. This guide (and other examples in this documentation) will concentrate on Mbed OS and command line tooling, which can be easily integrated into any IDE.","title":"Tools"},{"location":"development-boards/sensorio/tools/#mbed-cli","text":"","title":"Mbed CLI"},{"location":"development-boards/sensorio/tools/#software-requirements","text":"Python 2.7.11 or 3.6.0 . Other python versions might work, but mbed-cli is tested with those two. Compiler: Mbed OS supports several toolchains, both free and paid (ARM Compiler, IAR, GNU Arm, and more), but all examples in this documentation are based and tested with GNU Arm Embedded Toolchain .","title":"Software requirements"},{"location":"development-boards/sensorio/tools/#installation","text":"Create a virtualenv for mbed-cli : With Python 2.7.11: 1 virtualenv -p python2.7 mbed with Python 3.6.0: 1 virtualenv -p python3.6 mbed Activate virtual environment on macOS/Linux: 1 source mbed/bin/activate on Windows: 1 mbed\\Scripts\\activate Install mbed-cli : 1 pip install mbed-cli pip installs a release version of mbed-cli , you can choose however to install a development version - instructions are here .","title":"Installation"},{"location":"development-boards/sensorio/tools/#gnu-arm-embedded-toolchain","text":"GNU Arm Embedded Toolchain can be downloaded directly from ARM . Mbed OS requires 6-2017-q2-update , however SensorIO firmware is also tested with 7-2018-q2-update version. For installation instructions please refer to readme file in compiler package for your operating system.","title":"GNU Arm Embedded Toolchain"},{"location":"development-boards/sensorio/tools/#openocd","text":"OpenOCD is an open source debugging tool that supports numerous debugger interfaces and microcontrollers. Base installation instructions are available on Getting OpenOCD web page. SensorIO comes with an onboard ST-Link V2 debugger, which is working with OpenOCD, however this functionality has to be enabled during OpenOCD build. If a binary provided for you operating system is not able to work with SensorIO, it is possible to compile OpenOCD from source - here are official instructions . SensorIO is tested with custom binary built from source and following configuration: 1 ./configure --enable-ftdi --enable-ti-icdi --enable-stlink --enable-cmsis-dap --enable-jlink --enable-openjtag --disable-verbose-usb-comms --disable-verbose-usb-io","title":"OpenOCD"},{"location":"development-boards/sensorio/tools/#segger-jlink","text":"SensorIO provides a 10 pin JTAG/SWD header that can be used to connect external debuggers. Segger JLink probes work well with SensorIO and Segger software can be downloaded from their website .","title":"Segger JLink"},{"location":"educational/raspberry/overview/","text":"PROGRAMMING LEARNING-PACKAGE FOR RASPBERRY PI\u00ae \u00b6 This documentation describes the learning programming package from Makerfactory. This is a HAT for the Raspberry Pi for people who want to learn programming. The manual in German is very detailed. Board \u00b6 The product is a board for the Raspberry Pi, which is placed on top of it: these boards for the Raspberry Pi are called \"HAT\". All components are connected to the 40-pin header. This allows to use any Raspberry Pi which has this 40-pin connector. This HAT serves as the basis for various programming examples and is intended for teenagers or adults to playfully learn programming. The functioning of the product is explained in detail in the operating manual by means of numerous examples. Python 3 is used for programming which is already preinstalled at Raspbian. The following picture shows the Hat mounted on a Raspberry Pi. Peripheral components \u00b6 The learning package comes with a bunch of peripheral components. The usage of all of these components is described in detail in the manual. The following table lists the components which could be used for own projects, too: Board with spacers 4 traffic lights LED array with eight LEDs 5 * 7 dot matrix display Seven segment display Keypad Miniature buzzer Two blue lights Servo motor Switch Push button Piezo speaker GPIO of Raspberry Pi \u00b6 The package learns how to program all the components of the board in python. All components are connected to the GPIOs of the Raspberry Pi. The following picture shows the GPIOs of the Raspberry Pi. Programming examples \u00b6 There are 88 files in total of explaining how to program all the components. Here the first example for the traffic light called \"Ampel_1.pi\" where all declarations are explained before starting: Raspberry Pi Python Ampel_1 Example There is one example project for Python which can be downloaded: Ampel_1.py ( download here ) Manual \u00b6 There is an extract of the manual available here. The complete manual is delivered when buying the project. Example There is one extract of the manual which can be downloaded: Manual ( download here )","title":"Overview"},{"location":"educational/raspberry/overview/#programming-learning-package-for-raspberry-pi","text":"This documentation describes the learning programming package from Makerfactory. This is a HAT for the Raspberry Pi for people who want to learn programming. The manual in German is very detailed.","title":"PROGRAMMING LEARNING-PACKAGE FOR RASPBERRY PI\u00ae"},{"location":"educational/raspberry/overview/#board","text":"The product is a board for the Raspberry Pi, which is placed on top of it: these boards for the Raspberry Pi are called \"HAT\". All components are connected to the 40-pin header. This allows to use any Raspberry Pi which has this 40-pin connector. This HAT serves as the basis for various programming examples and is intended for teenagers or adults to playfully learn programming. The functioning of the product is explained in detail in the operating manual by means of numerous examples. Python 3 is used for programming which is already preinstalled at Raspbian. The following picture shows the Hat mounted on a Raspberry Pi.","title":"Board"},{"location":"educational/raspberry/overview/#peripheral-components","text":"The learning package comes with a bunch of peripheral components. The usage of all of these components is described in detail in the manual. The following table lists the components which could be used for own projects, too: Board with spacers 4 traffic lights LED array with eight LEDs 5 * 7 dot matrix display Seven segment display Keypad Miniature buzzer Two blue lights Servo motor Switch Push button Piezo speaker","title":"Peripheral components"},{"location":"educational/raspberry/overview/#gpio-of-raspberry-pi","text":"The package learns how to program all the components of the board in python. All components are connected to the GPIOs of the Raspberry Pi. The following picture shows the GPIOs of the Raspberry Pi.","title":"GPIO of Raspberry Pi"},{"location":"educational/raspberry/overview/#programming-examples","text":"There are 88 files in total of explaining how to program all the components. Here the first example for the traffic light called \"Ampel_1.pi\" where all declarations are explained before starting: Raspberry Pi Python Ampel_1 Example There is one example project for Python which can be downloaded: Ampel_1.py ( download here )","title":"Programming examples"},{"location":"educational/raspberry/overview/#manual","text":"There is an extract of the manual available here. The complete manual is delivered when buying the project. Example There is one extract of the manual which can be downloaded: Manual ( download here )","title":"Manual"},{"location":"educational-robotics/robobug-hexapod/","text":"Hexapod RoboBug Platform \u00b6","title":"Hexapod RoboBug Platform"},{"location":"educational-robotics/robobug-hexapod/#hexapod-robobug-platform","text":"","title":"Hexapod RoboBug Platform"},{"location":"educational-robotics/robobug-hexapod/FAQ/","text":"FAQ \u00b6 Error compiling the examples If there are problems compiling the firmware: The provided firmware as well as the examples were developed with Arduino version 1.8.3. Alternatively, you can download it from Arduino . Sound output too low Check the setting of the \"Vol.\" trimmer. Build a small \"speaker box\" into the robot board speaker. This increases the volume and improves the sound considerably. There is no communication with SPI devices and the user board Set the Chip Select (CS) pin of the user board to \"High\" and check your connection at the ISP_U connector and of the used SPI component is supplied with power. const int chipSelect = 8; pinMode(chipSelect, OUTPUT); digitalWrite(chipSelect, HIGH); The Gamepad does not connect or show any reaction Check the batteries in the transmitter Is the reciever correctly connected to the robot board? Is the \"motion firmware\" installed on the robot board? Disonnect the power supply of the robot board, switch on the Gamepad and then re-establish the connection to the power supply of the Hexapod (plug in the battery). Is the Gamepad PS2 compatible? Jumper J7 must not be plugged in. The robot does not react to the gamepad Check the batteries in the transmitter Is the reciever correctly connected to the robot board? Is the \"motion firmware\" installed on the robot board? Disonnect the power supply of the robot board, switch on the Gamepad and then re-establish the connection to the power supply of the Hexapod (plug in the battery). Is the Gamepad PS2 compatible? Jumper J7 removed? The robot is not running cleanly Have the legs been calibrated? Are the batteries sufficient strong and charged? Is the robot too heavy? Have the servos been set to the middle position before installation? Are the legs slipping on the ground? Are all screws tightened? Does the machanics wobble? Is the machanics too stiff? Where can I find the circuit diagram? The circuit diagram can be found in the \"Schematic\" folder in the download bundle or can be downloaded from Conrad . The robot carries out the reset after switching on or getting up Make sure that the battery is fully charged. Is the battery connection cable too thin (< 1.5 mm\u00b2) or longer than 20 cm? Is the battery plug soldered on cleanly? If the battery is too small, it cannot supply the necessary operating current for the servos. Is/are there any servo(s) blocked? Does the machanics mave too sluggishly?","title":"FAQ"},{"location":"educational-robotics/robobug-hexapod/FAQ/#faq","text":"Error compiling the examples If there are problems compiling the firmware: The provided firmware as well as the examples were developed with Arduino version 1.8.3. Alternatively, you can download it from Arduino . Sound output too low Check the setting of the \"Vol.\" trimmer. Build a small \"speaker box\" into the robot board speaker. This increases the volume and improves the sound considerably. There is no communication with SPI devices and the user board Set the Chip Select (CS) pin of the user board to \"High\" and check your connection at the ISP_U connector and of the used SPI component is supplied with power. const int chipSelect = 8; pinMode(chipSelect, OUTPUT); digitalWrite(chipSelect, HIGH); The Gamepad does not connect or show any reaction Check the batteries in the transmitter Is the reciever correctly connected to the robot board? Is the \"motion firmware\" installed on the robot board? Disonnect the power supply of the robot board, switch on the Gamepad and then re-establish the connection to the power supply of the Hexapod (plug in the battery). Is the Gamepad PS2 compatible? Jumper J7 must not be plugged in. The robot does not react to the gamepad Check the batteries in the transmitter Is the reciever correctly connected to the robot board? Is the \"motion firmware\" installed on the robot board? Disonnect the power supply of the robot board, switch on the Gamepad and then re-establish the connection to the power supply of the Hexapod (plug in the battery). Is the Gamepad PS2 compatible? Jumper J7 removed? The robot is not running cleanly Have the legs been calibrated? Are the batteries sufficient strong and charged? Is the robot too heavy? Have the servos been set to the middle position before installation? Are the legs slipping on the ground? Are all screws tightened? Does the machanics wobble? Is the machanics too stiff? Where can I find the circuit diagram? The circuit diagram can be found in the \"Schematic\" folder in the download bundle or can be downloaded from Conrad . The robot carries out the reset after switching on or getting up Make sure that the battery is fully charged. Is the battery connection cable too thin (< 1.5 mm\u00b2) or longer than 20 cm? Is the battery plug soldered on cleanly? If the battery is too small, it cannot supply the necessary operating current for the servos. Is/are there any servo(s) blocked? Does the machanics mave too sluggishly?","title":"FAQ"},{"location":"educational-robotics/robobug-hexapod/Overview_of_the_connections_and_components/","text":"Overview of the connections and components \u00b6 Figure 79 Lay down the robot board as shown in the illustration to get an overview of the connector options. \u2192 You can also find the circuit diagram for the board at Conrad on the product website. The Hexapod robot board has the following connectors and components: BAT XT30 connector for connecting the battery that powers the board. Operating voltage 4.5 to 10 V/DC (\"+\" = positive pole; \"GND\" = negative pole). Depending on the servos used, a NiMH battery with 5 cells (nominal voltage 6.0 V) and a capacity of at least 2000 mAh should be used as power supply. PRG-M USB connection for programming the locomotion controller. TX-LED Indicates the transmission line when a programme is transmitted to the locomotion controller (fast flashing during transmission). Signals the receiving line when a programme is transferred to the locomotion controller (fast flashing during transfer). AKKU & GND The battery voltage can be tapped at these pins (\"BAT\" = positive pole, \"GND\" = negative pole). !!! Caution !!! The pins are not protected against short circuits! Work carefully here and do not cause a short circuit! This can lead to the destruction of the pins and the Hexapod Robot Board! This connection is available for proper extensions and experiments J6 Here stabilised 5 V/DC/1000 mA at the pins \"VCC\" and \"GND\" are available. This connector is used for proper extensions and experiments (\"VCC\" = positive pole, \"GND\" = negative pole). OUT1 This is a digital output of the locomotion controller. It can be switched to HIGH (+5 V/DC) or LOW (0 V/DC) by a command from the user board. The maximum current carrying capacity is 20 mA. This connection is available for proper extensions and experiments. IN1 This is a digital input of the locomotion controller. It can read a digital state via a command from the user board. A logical 1 is detected between 3.5 and 5 V/DC; a logical 0 at a voltage lower than 3.3 V/DC. The maximum input voltage of 5 V/DC must not be exceeded! This connection is available for proper extensions and experiments. IR The infrared receiver \"IR\" can either be connected with the jumper \"J8\" with the locomotion controller (jumper position \"IR-M\") or with the user board (jumper position \"IR-U\"). The receiver makes it possible to receive a 38 kHz infrared signal, e.g., from a universal remote control or a self-made IR transmitter. LIVE-LED The blue \"LIVE-LED\" indicates the status of the locomotion controller. If the locomotion controller is active, this LED flashes in different states. USER-LED The red \"USER LED\" indicates that the PS2-compatible gamepad is activated, and the control commands are now ignored by the user board. 3.3V & GND Stabilised 3.3 V/DC/400 mA are available at these pins. This connector is available for proper extensions and experiments (\"3.3V\" = positive pole, \"GND\" = negative pole). 5V & GND Stabilised 5 V/DC/1000 mA are available at these pins. This connector is available for proper extensions and experiments (\"5V\" = positive pole, \"GND\" = negative pole). 3.3V Pwr-LED The red LED indicates that the 3.3 V voltage/power supply is working. It lights up when a power supply is connected to the BAT connector. 5V PWR-LED The red LED indicates that the 5 V voltage/power supply is working. It lights up when a power supply is connected to the BAT connector. J7 The jumper \"J7\" deactivates the evaluation of the PS2-compatible gamepad in the locomotion controller firmware (the robot can then no longer be controlled via the gamepad). The gamepad control commands can then only be read out via the user board! ISP-M ISP connector (\"in-system programming\") of the Locomotion controller. Via this connector the locomotion controller can be programmed via an ISP programming device. It is also possible to use this connector to integrate your own components with SPI interface. PS2-1 - PS2-3 A PS2-compatible gamepad, available as an accessory, can be connected to these pins. With this controller the robot can be controlled manually, similar to a remote controlled car. J2 & J3 The two sockets are connected to the I2C-BUS connector of the Locomotion controller and can be used for proper extensions. The connectors are compatible with the \"SEEED-GROVE\" components. J4 & J5 The two sockets are connected to the I2C-BUS connector of the user board and can be used for proper extensions. The connectors are compatible with the \"SEEED-GROVE\" components. RESET-M The button triggers a hardware reset of the Locomotion controller when pressed. S0 - S17 The \"leg servos\" of the Hexapod are connected to these connections. The pin headers are always arranged in blocks, which are assigned to the respective leg. The connections for \"Coxa - Hip\", \"Femur - Thigh\" and \"Tibia - Shin\" are counted from the respective label (S...). The pins are compatible with the most common servos. Make sure the polarity is correct. The polarity is marked on the board with \"SIG\" for the signal line, \"BAT+\" for the positive pole and \"GND\" for the negative pole. SA0 - SA5 The analogue inputs SA0 to SA5 can be used for proper extensions in the locomotion firmware. In the \"Motion Firmware\" these can also be queried by the user board via a function. SJ1 The PCB jumper \"SJ1\" connects the audio amplifier with the locomotion controller. In most practical cases, this connection remains in place. If necessary, you can carefully cut the jumper with a small wallpaper knife. With a soldering iron and some solder you can re-establish the connection. Loadspeaker The loudspeaker is used to output the signal tones and is connected to the audio amplifier. The signal tones can be generated by the locomotion controller and also by the user board. Vol. The trimmer \"Vol.\" is used to adjust the volume of the signal tones of the locomotion controller and the user board. If you turn the trimmer in the direction of the buttons, the volume is increased; in the opposite direction it becomes quieter. In practice, a small watchmaker's screwdriver has been used to adjust the small trimmer. Be careful not to damage the trimmer when adjusting it! The basic setting is the middle position of the trimmer. T1 & T2 The buttons \"T1\" and \"T2\" can be used with the user board. Please take a look at the software examples. SJ6 & SJ7 The PCB jumpers \"SJ6\" and \"SJ7\" connect the outputs of the buttons \"T1\" and \"T2\" with a 22 kOhm pull-up resistor, so that no pull-up resistors have to be activated in the user board program. In most practical cases, this connection remains in place. If necessary, you can carefully cut the jumpers with a small wallpaper knife. With a soldering iron and some solder you can re-establish the connection. RESET-U The \"RESET-U\" button resets the user board. SJ2 The PCB jumper \"SJ2\" connects the button \"T2\" with the NodeMCU user board. The used pin of the NodeMCU is the analogue input and can be disconnected from the push-button \"T2\" by this jumper if used otherwise. Normally this connection remains in place. If necessary, you can cut the jumper carefully with a small wallpaper knife. With a soldering iron and some solder you can re-establish the connection. SU1 - SU3 The connectors SU1, SU2 and SU3 are connected to the user board slots and can be used for proper applications. They have the same polarity as the servo connectors of the leg servos. Please take a look at the software examples. \u00b5SD The card slot for a MicroSD card is connected to the Arduino-UNO compatible user board slot and can be used for own applications. Please take a look at the software examples. ISP-U ISP port (\"In-System Programming\") of the Arduino UNO compatible user board slot. This port is used to programme the user board using an ISP programmer. It is also possible to use this connector to integrate your own components with SPI interface. \u2192The Locomotion-Controller is located under the loudspeaker.","title":"Overview of the connections and components"},{"location":"educational-robotics/robobug-hexapod/Overview_of_the_connections_and_components/#overview-of-the-connections-and-components","text":"Figure 79 Lay down the robot board as shown in the illustration to get an overview of the connector options. \u2192 You can also find the circuit diagram for the board at Conrad on the product website. The Hexapod robot board has the following connectors and components: BAT XT30 connector for connecting the battery that powers the board. Operating voltage 4.5 to 10 V/DC (\"+\" = positive pole; \"GND\" = negative pole). Depending on the servos used, a NiMH battery with 5 cells (nominal voltage 6.0 V) and a capacity of at least 2000 mAh should be used as power supply. PRG-M USB connection for programming the locomotion controller. TX-LED Indicates the transmission line when a programme is transmitted to the locomotion controller (fast flashing during transmission). Signals the receiving line when a programme is transferred to the locomotion controller (fast flashing during transfer). AKKU & GND The battery voltage can be tapped at these pins (\"BAT\" = positive pole, \"GND\" = negative pole). !!! Caution !!! The pins are not protected against short circuits! Work carefully here and do not cause a short circuit! This can lead to the destruction of the pins and the Hexapod Robot Board! This connection is available for proper extensions and experiments J6 Here stabilised 5 V/DC/1000 mA at the pins \"VCC\" and \"GND\" are available. This connector is used for proper extensions and experiments (\"VCC\" = positive pole, \"GND\" = negative pole). OUT1 This is a digital output of the locomotion controller. It can be switched to HIGH (+5 V/DC) or LOW (0 V/DC) by a command from the user board. The maximum current carrying capacity is 20 mA. This connection is available for proper extensions and experiments. IN1 This is a digital input of the locomotion controller. It can read a digital state via a command from the user board. A logical 1 is detected between 3.5 and 5 V/DC; a logical 0 at a voltage lower than 3.3 V/DC. The maximum input voltage of 5 V/DC must not be exceeded! This connection is available for proper extensions and experiments. IR The infrared receiver \"IR\" can either be connected with the jumper \"J8\" with the locomotion controller (jumper position \"IR-M\") or with the user board (jumper position \"IR-U\"). The receiver makes it possible to receive a 38 kHz infrared signal, e.g., from a universal remote control or a self-made IR transmitter. LIVE-LED The blue \"LIVE-LED\" indicates the status of the locomotion controller. If the locomotion controller is active, this LED flashes in different states. USER-LED The red \"USER LED\" indicates that the PS2-compatible gamepad is activated, and the control commands are now ignored by the user board. 3.3V & GND Stabilised 3.3 V/DC/400 mA are available at these pins. This connector is available for proper extensions and experiments (\"3.3V\" = positive pole, \"GND\" = negative pole). 5V & GND Stabilised 5 V/DC/1000 mA are available at these pins. This connector is available for proper extensions and experiments (\"5V\" = positive pole, \"GND\" = negative pole). 3.3V Pwr-LED The red LED indicates that the 3.3 V voltage/power supply is working. It lights up when a power supply is connected to the BAT connector. 5V PWR-LED The red LED indicates that the 5 V voltage/power supply is working. It lights up when a power supply is connected to the BAT connector. J7 The jumper \"J7\" deactivates the evaluation of the PS2-compatible gamepad in the locomotion controller firmware (the robot can then no longer be controlled via the gamepad). The gamepad control commands can then only be read out via the user board! ISP-M ISP connector (\"in-system programming\") of the Locomotion controller. Via this connector the locomotion controller can be programmed via an ISP programming device. It is also possible to use this connector to integrate your own components with SPI interface. PS2-1 - PS2-3 A PS2-compatible gamepad, available as an accessory, can be connected to these pins. With this controller the robot can be controlled manually, similar to a remote controlled car. J2 & J3 The two sockets are connected to the I2C-BUS connector of the Locomotion controller and can be used for proper extensions. The connectors are compatible with the \"SEEED-GROVE\" components. J4 & J5 The two sockets are connected to the I2C-BUS connector of the user board and can be used for proper extensions. The connectors are compatible with the \"SEEED-GROVE\" components. RESET-M The button triggers a hardware reset of the Locomotion controller when pressed. S0 - S17 The \"leg servos\" of the Hexapod are connected to these connections. The pin headers are always arranged in blocks, which are assigned to the respective leg. The connections for \"Coxa - Hip\", \"Femur - Thigh\" and \"Tibia - Shin\" are counted from the respective label (S...). The pins are compatible with the most common servos. Make sure the polarity is correct. The polarity is marked on the board with \"SIG\" for the signal line, \"BAT+\" for the positive pole and \"GND\" for the negative pole. SA0 - SA5 The analogue inputs SA0 to SA5 can be used for proper extensions in the locomotion firmware. In the \"Motion Firmware\" these can also be queried by the user board via a function. SJ1 The PCB jumper \"SJ1\" connects the audio amplifier with the locomotion controller. In most practical cases, this connection remains in place. If necessary, you can carefully cut the jumper with a small wallpaper knife. With a soldering iron and some solder you can re-establish the connection. Loadspeaker The loudspeaker is used to output the signal tones and is connected to the audio amplifier. The signal tones can be generated by the locomotion controller and also by the user board. Vol. The trimmer \"Vol.\" is used to adjust the volume of the signal tones of the locomotion controller and the user board. If you turn the trimmer in the direction of the buttons, the volume is increased; in the opposite direction it becomes quieter. In practice, a small watchmaker's screwdriver has been used to adjust the small trimmer. Be careful not to damage the trimmer when adjusting it! The basic setting is the middle position of the trimmer. T1 & T2 The buttons \"T1\" and \"T2\" can be used with the user board. Please take a look at the software examples. SJ6 & SJ7 The PCB jumpers \"SJ6\" and \"SJ7\" connect the outputs of the buttons \"T1\" and \"T2\" with a 22 kOhm pull-up resistor, so that no pull-up resistors have to be activated in the user board program. In most practical cases, this connection remains in place. If necessary, you can carefully cut the jumpers with a small wallpaper knife. With a soldering iron and some solder you can re-establish the connection. RESET-U The \"RESET-U\" button resets the user board. SJ2 The PCB jumper \"SJ2\" connects the button \"T2\" with the NodeMCU user board. The used pin of the NodeMCU is the analogue input and can be disconnected from the push-button \"T2\" by this jumper if used otherwise. Normally this connection remains in place. If necessary, you can cut the jumper carefully with a small wallpaper knife. With a soldering iron and some solder you can re-establish the connection. SU1 - SU3 The connectors SU1, SU2 and SU3 are connected to the user board slots and can be used for proper applications. They have the same polarity as the servo connectors of the leg servos. Please take a look at the software examples. \u00b5SD The card slot for a MicroSD card is connected to the Arduino-UNO compatible user board slot and can be used for own applications. Please take a look at the software examples. ISP-U ISP port (\"In-System Programming\") of the Arduino UNO compatible user board slot. This port is used to programme the user board using an ISP programmer. It is also possible to use this connector to integrate your own components with SPI interface. \u2192The Locomotion-Controller is located under the loudspeaker.","title":"Overview of the connections and components"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/","text":"Assembling the mechanical parts \u00b6 The following illustrations illustrate the mechanical assembly. Caution When tightening the plastic screws, make sure that they are not screwed too tightly into the plastic and that the plastic holders are not damaged! If you remove a screw from a plastic part and then screw it in again, first turn the screw anticlockwise until you notice that the screw \"engages\". At this point the screw is \"engaged\" in the existing thread. The screw can then be easily screwed into the thread that has already been created during the first screwing in. If the self-tapping plastic screw is screwed in without using this method, a new thread may occur. This weakens the material and the tensile strength as well as the hold are no longer guaranteed. Mounting servos \u00b6 Mount the servos as shown in the following illustrations. You will need 3 pairs of left and 3 pairs of right legs. Most aluminium parts have a slightly rounded side due to the manufacturing process (punching process). You can use the parts in both directions during assembly. The nicer side should point forward in the direction of travel. The rounded side of the top and bottom plates should point in the same direction (top or bottom). Requiered tool: 1x PH2 Cross Screwdriver The screws are packed in plastic bags in the kit. Figure 19 shows the type of screws used for servo mounting. A total of 6x legs must be assembled (3 left and 3 right). Figure 19 Figure 20 shows a leg of the Robobug. The leg elements are called \"Coxa\", \"Femur\" and \"Tibia\". Figure 20 Place the servo in the plastic U-angle and the aluminium leg thereon (pay attention to the left and right leg and the round edge). The servo cable is pushed through the oval opening in the U-angle. Screw the leg together with four plastic screws. When screwing the parts together, align them so that they are centred in the U-angle, the aluminium legs lie against the servo and ensure that nothing is strained or warped. If necessary, loosen the screws a little to relax the mechanics and then carefully tighten the screws crosswise. Figure 21 The Coxa servo and femur servo holder must be mounted 6 times (3 left and 3 right). First insert a servo into the holder and screw it on. Only then is the second servo plugged in and screwed in. The servo cable of the Coxa servo is inserted through the round opening at the top and the servo cable for the femur servo is inserted through the large oval opening as with the U-angle mounting. Screw the servos together with four plastic screws. When screwing the servos together, align them so that they are centred in the plastic holder and are not tensed. If necessary, loosen the screws a little to release the mechanical tension and then carefully tighten the screws crosswise. Figure 22 Figure 23 Mounting of bearings \u00b6 Required tool: 10 mm hexagon socket (from a socket wrench set) or comparable tool as a tool for mounting the bearings Push the bearings into the aluminium parts as shown in the following illustrations. Here a hexagon socket wrench or a comparable tool can be helpful. Do not use rough force, this can damage the base plate and the ball bearings! Avoid tilting, with some sensing the position can be pressed in without great resistance. \u2192 Make sure that the edge of the bearing is flush with the aluminium part. If a bearing cannot be pressed in, it may be caused by a protruding burr or too much paint. You can easily rework the bore with a knife (e.g., cutter knife for wallpaper or floors) or with a file. If the bore has become too large, the bearing can be glued to the flange of the bearing with a small drop of glue (e.g., Uhu\u00ae Endfest or comparable). The bearings may come loose during final assembly due to uneven pressing of the cylindrical pins into the plastic holders. This is, however, not too bad, as the pins can easily be pushed back into the intended hole. Sticking should be a last resort. The bearings clamp sufficiently strongly in the holes for the operation of the robot even without glue. Figure 24 \u2192 Figure 24 shows the bottom plate from above! Figure 25 shows how you can press the bearings into the base plate using the femur aluminium parts as a support. The hexagon wrench must press against the edge of the bearing. Masking the aluminium parts with painter tape protects them from scratching. Other parts that can be found in the hobby workshop can also be used as underlay. \u2192 Do not use adhesive tape that cannot be removed without leaving a residue. Figure 25 The femur counter bearing must be assembled a total of 6 times. Figure 26 Figure 27 shows how you can push the bearing into the aluminium part by hand. The bearing should snap into the bore provided with a bold push. Figure 27 Make sure that the edge of the bearing is flush with the aluminium part. Figure 28 Caution These screws (all M2) are now already provided with a screw lock. Required tool: PH1 Phillips screwdriver Small flat nose pliers or wrench for M2 nut (SW4) Screw locking (medium strength) Mounting the servo discs on the upper plate: \u2192 Figure 29 shows the top plate from above! Figure 29 \u2192 Figure 30 shows the top plate from below! Figure 30 The femur servo mount must be mounted a total of 6 times. Figure 31 Figure 32 Mounting the spacer \u00b6 Next, screw together the spacers (30 mm long) for the legs, top and bottom plates as shown in Figure 33. A total of 12 screwed spacers are required. Required tool: 2x SW 5.5mm open-end wrench Then fit a screwed spacer to each femur counter bearing. Insert the threaded side through the counter bearing and fix it with an M3 nut. It is sufficient if the spacers are only tightened by hand. Do not tighten these screws until the assembly is complete. This way you still have the possibility to easily adjust everything during assembly. Figure 33 Figure 34 Do the same with the base plate. \u2192 Figure 35 shows the bottom plate from above! Figure 35 Mounting the servos on the top plate \u00b6 Mount the servos with the M3 screws (M3 x 6 mm, large head diameter) as shown in Figure 36. \u2192For mounting the servos with the servo discs, always use the M3 x 6 mm screws (servo mounting screws) with the larger 6 mm head is used. The M3 x 6 mm screws with the smaller 5 mm head are used for the spacers! Insert the servos into the teeth of the previously mounted servo disks. Proceed carefully so that the servos do not twist during insertion. If it should happen that a servo has rotated from the middle position during assembly, then bring the servo back to the middle position with the aid of the Hexapod Robot Board and the \"ServoCenter\" software. This procedure has already been described in Chapter 12. If, due to the teeth of the servo disk or the general mechanical tolerances, you are not yet able to align the legs too precisely, this is not a problem. Adjust the leg as mechanically as possible, as shown in the illustration. An exact calibration is done after the assembly with the help of the software. \u2192 The servo mounting screws (PH2 (M3 x 6 mm, large head diameter) are not yet equipped with a screw lock! Only when the robot has been completely assembled and calibrated can these screws be removed and secured! Required tool: PH2 Phillips screwdriver Figure 36 Figure 36 illustrates the Hexapod body viewed from \"above\". The two front and the two rear legs are installed in such a way that they point outwards at an angle of 45\u00b0 without twisting the centre position of the servo (centre position). You can orient yourself on the cross-paths in the upper plate at an angle of 45\u00b0. The two middle legs (left and right side) are installed straight outwards at an angle of 90\u00b0 to the body. \u2192 Please also refer to Figure 37 on the next page. Figure 37 Mount bottom plate \u00b6 Mounting the bottom plate requires some skill. Place the top plate with its back on the table as shown in Figure 38. Push the cylinder pins of the base plate into the plastic holders of the top plate, starting from the front or rear, all the way round. Do not push the pins completely in the first time, but repeat the working step and press the cylinder pin only a few millimetres into the plastic each time it circulates. This prevents the component from becoming strained! \u2192 Place an underlay, such as a cardboard box, between the component and the table so that you do not scratch the table with the screw heads! The foam from the packaging for instance is very suitable for this purpose. Do not use force. This can damage the servos, the base plate and the ball bearings! You can set the correct distance between the bearing and the plastic holder using a 2.5 mm Hexagon key. The Hexagon key serves as a distance gauge, see Figure 41. Finally, the upper plate is screwed together with spacers. Use the M3 x 6 screws (small head diameter 5 mm) for this purpose. Required tool: PH2 Phillips screwdriver Underlay e.g., cardboard box; \u2192 Figure 38 shows the bottom side of the robot! Figure 38 \u2192 Figure 39 shows the top side of the robot! Figure 39 Figure 40 shows how the dowel pins are only slightly pressed in to fix them in the plastic. Only when all the dowel pins have been fixed in the holes of the plastic holders are they pressed in at a distance (2.5 mm). To achieve the correct distance, place the Hexagon key between the bearing and the plastic holder and press the cylinder pins into the plastic holder with moderate force. If a cylindrical pin has been pressed in too far by mistake, you can correct this with a wide slotted screwdriver by gently levering it out. Make sure, however, that the aluminium parts are not damaged (scratched). After all bearings have been pressed in and adjusted to the correct distance, screw them together with the spacers. Figure 41 shows how to set the correct distance using the 2.5 mm hexagon wrench as the spacer. Figure 40 Figure 41 Mounting the Receiver and Hexapod Robot Board \u00b6 Now the radio receiver for the gamepad is connected to the robot board and mounted. The receiver is fixed to the underside of the robot board with the supplied double-sided adhesive tape. \u2192 The receiver and the connection cable must first be connected to each other. Connect the wide receiver plug to the receiver. When connecting the receiver to the robot board, make sure that the polarity of the connectors is correct. Required tool: Scissors PH2 Phillips screwdriver Open-end wrench SW 5.5 mm Plug the cable into the receiver as shown in Figure 42. The \"POWER\" and \"RX\" labels point upwards in the illustration. Use the same colour sequence as shown in the illustration. Figure 42 Shorten the double-sided adhesive tape to approx. 25 mm using scissors. Then peel off one side of the protective film of the adhesive tape and stick this side onto the robot board. Figure 43 Now peel off the other side of the protective film and affix the receiver. Make sure that the housing side with the two red LEDs locks with the \"thick\" contacts (see arrow in the illustration) of the loudspeaker. If the housing protrudes too far into the contacts of the loudspeaker, the housing will press against the contacts of the loudspeaker when mounting the circuit board. Figure 44 Now connect the cable to the robot board. The colours are combined in the plugs to 3 wires each. From left (MicroSD card holder position) to right (battery plug position): White, grey, purple -> White points to outer edge of board Blue, green, yellow -> Blue points to the outer edge of the board Orange, red brown -> Orange points to the outer edge of the board. \u2192 Figure 45b shows a detail enlargement of Figure 45. Figure 45a Figure 45b Now mount the robot board with the four 15 mm spacers. The threaded side of each spacer is inserted into the top plate and fastened with an M3 nut. \u2192 Do not tighten the M3 nuts too tightly as this will allow you to readjust them easily to mount the PCB without tension. Only when the board has been fixed to the spacers with four screws M3 x 6 mm (small head diameter 5 mm), tighten the M3 nuts. In this way you can align the board cleanly. Figure 46 Figure 47 shows the pin assignment of the receiver (left) and the pin assignment of the robot board (right). Figure 47 Mounting the legs \u00b6 Try to mount the legs the as well as you can. Minor deviations do not play a role and cannot be avoided by the mechanical tolerances and by the coarse teeth of the servo disks. \u2192 The legs will be exactly adjusted later by software! Figure 48 (see also Figure 20) shows the basic configuration of a Hexapod leg. It should be noted that the thigh (femur) is aligned parallel to the ground (\"ground\" in the picture). The pivot point of the shin (\"tibia\") is parallel to the body (\"body\"). When the leg is fully adjusted, there is a 90\u00b0 angle between the femur and the tibia. The arrangement between \"body\" and \"femur\" is parallel in one line. The difference in height does not play a role here. Figure 49 (see also Figure 17) once again shows the pin assignment of the robot board for the leg servos. The following list shows wherein each servo is connected. Basically, the connection sequence \"COXA\", \"FEMUR\", \"TIBA\" always applies; then follows the plug contact \"SAx\", which remains free! Figure 48 Now connect the servos to the board. With the \"ServoCenter\" programme you can always check during assembly whether the leg is still in the basic position. Figure 49 \u2192 After mounting each leg, use the \"ServoCenter\" programme to check whether the leg is in the basic configuration or whether an error has crept in due to turning the servo while mounting! RR (right rear) LR (left rear) S0 = Coxa S9 = Coxa S1 = Femur S10 = Femur S2 = Tibia S11 = Tibia RM (right middle) LM (left middle) S3 = Coxa S12 = Coxa S4 = Femur S13 = Femur S5 = Tibia S14 = Tibia RF (right front) LF (left front) S6 = Coxa S15 = Coxa S7 = Femur S16 = Femur S8 = Tibia S17 = Tibia Coxa = hip Femur = thigh Tibia = leg or shine-bone First mount the thighs (\u201cfemur\u201d) as shown in Figure 50. Screw the thighs to the servos (M3 x 6 mm screws, large head diameter 6 mm). Then assemble the legs \u201ctibia\u201d and fix them with the M3 x 6 screws (large head diameter 6 mm). It is helpful to lift the robot with the help of a cardboard box. If you have a 3D printer, you can also print out the robot stand. The files can be found free of charge at Conrad.com on the respective product website. \u2192 After the robot is completely assembled and adjusted, you should provide the screws, which connect the servo disk with the servo, with a small drop of screw lock. During operation they will loosen quickly and may get lost! Required tool: PH2 Phillips screwdriver Open-end wrench SW 5.5 mm Figure 50 Despite the angled tibia servos, \"femur\" must be parallel to the floor at the end and \"tibia\" parallel to the body. The \"femur\" and \"tibia\" make a 90\u00b0 angle; the servos themselves are still in the middle position! Figure 52 shows the Robobug when all legs are fully assembled and in the home position. Ideally, the red line (Figure 51) would run exactly in the middle of the screw heads. Since the servo disks do not allow this due to the toothing and the mounting tolerance, it may be slightly off the mark with some legs. This is not bad, the exact alignment to the middle will be done later by software. Figure 51 Figure 52 Now mount the counter bearings. \u2192 The U holder has two holes, use the hole facing the cable opening. When pressing in the dowel pins, proceed in the same way as when pressing in the dowel pins of the base plate. The distance between the bearing and the plastic part here is 1.5 mm. You can also use an Hexagon key as a distance gauge here. Then screw the spacer on each leg with a M3 x 6 mm screw (small head diameter 5 mm) as shown in Figure 53. Figure 53 The 1.5 mm hexagon key is placed between the ball bearing and the plastic part and the cylindrical pin is pressed in until it stops. Also, in this case, press the cylindrical pins only alternately (first one side then the other) piece by piece into the plastic so as not to tilt the holder. \u2192 If you hold the robot at an angle, you can hang the Hexagon key over the cylinder pin without it falling down. Figure 55 shows the Robobug with the legs fully assembled and in the basic position. Figure 54 Figure 55 Laying the cables \u00b6 Lay the cables as shown in the illustrations. Use the supplied cable ties for this purpose. After the cable ties have been tightened, cut off the protruding part of the cable tie. A clean cable laying gives the robot a very high-quality appearance! \u2192 As long as you have not finished aligning the cables, you should not tighten the cable ties too tightly. This way you can make small corrections easily. Required tool: Electronic side cutter Figure 56 Figure 57 Figure 58 Figure 59 Figure 60 Figure 61 Figure 62 Installing the battery \u00b6 The battery is mounted edgeways with the supplied Velcro fastener as shown in the illustrations. To do this, shorten the Velcro fastener to approx. 25 cm. Tighten the Velcro so that the battery has a firm grip on the battery plate and cannot slip during operation. Figure 63 Then run the cable through the top plate as shown in Figure 64a. Screw the battery retaining plate to the lower plate. Use the screws M4 x 5 mm for this purpose. Figure 64a In Figure 64b (see also Figure 7) you can see how the battery is plugged into the Robobug. The plug is protected against reverse polarity and cannot therefore be plugged in the wrong way. Figure 64b Mounting the rubber feet \u00b6 Slide the supplied rubber feet onto the ends of the legs. You can also secure the rubber caps with some glue (e.g., Uhu\u00ae All Purpose Glue or similar) so that they are not lost during operation. \u2192 The rubber feet not only secure a good grip on the ground, but also ensure that the aluminium legs do not scratch the ground (floor, table etc.). Figure 65 Setting jumpers \u00b6 Finally, the two jumpers are plugged in. The jumper for the infrared receiver is plugged on \"IR-U\"; the jumper J7 is plugged only on one pin. \u2192 If you connect jumper J7 to both pins, the gamepad will be deactivated! Figure 66","title":"Assembling the mechanical parts"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#assembling-the-mechanical-parts","text":"The following illustrations illustrate the mechanical assembly. Caution When tightening the plastic screws, make sure that they are not screwed too tightly into the plastic and that the plastic holders are not damaged! If you remove a screw from a plastic part and then screw it in again, first turn the screw anticlockwise until you notice that the screw \"engages\". At this point the screw is \"engaged\" in the existing thread. The screw can then be easily screwed into the thread that has already been created during the first screwing in. If the self-tapping plastic screw is screwed in without using this method, a new thread may occur. This weakens the material and the tensile strength as well as the hold are no longer guaranteed.","title":"Assembling the mechanical parts"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#mounting-servos","text":"Mount the servos as shown in the following illustrations. You will need 3 pairs of left and 3 pairs of right legs. Most aluminium parts have a slightly rounded side due to the manufacturing process (punching process). You can use the parts in both directions during assembly. The nicer side should point forward in the direction of travel. The rounded side of the top and bottom plates should point in the same direction (top or bottom). Requiered tool: 1x PH2 Cross Screwdriver The screws are packed in plastic bags in the kit. Figure 19 shows the type of screws used for servo mounting. A total of 6x legs must be assembled (3 left and 3 right). Figure 19 Figure 20 shows a leg of the Robobug. The leg elements are called \"Coxa\", \"Femur\" and \"Tibia\". Figure 20 Place the servo in the plastic U-angle and the aluminium leg thereon (pay attention to the left and right leg and the round edge). The servo cable is pushed through the oval opening in the U-angle. Screw the leg together with four plastic screws. When screwing the parts together, align them so that they are centred in the U-angle, the aluminium legs lie against the servo and ensure that nothing is strained or warped. If necessary, loosen the screws a little to relax the mechanics and then carefully tighten the screws crosswise. Figure 21 The Coxa servo and femur servo holder must be mounted 6 times (3 left and 3 right). First insert a servo into the holder and screw it on. Only then is the second servo plugged in and screwed in. The servo cable of the Coxa servo is inserted through the round opening at the top and the servo cable for the femur servo is inserted through the large oval opening as with the U-angle mounting. Screw the servos together with four plastic screws. When screwing the servos together, align them so that they are centred in the plastic holder and are not tensed. If necessary, loosen the screws a little to release the mechanical tension and then carefully tighten the screws crosswise. Figure 22 Figure 23","title":"Mounting servos"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#mounting-of-bearings","text":"Required tool: 10 mm hexagon socket (from a socket wrench set) or comparable tool as a tool for mounting the bearings Push the bearings into the aluminium parts as shown in the following illustrations. Here a hexagon socket wrench or a comparable tool can be helpful. Do not use rough force, this can damage the base plate and the ball bearings! Avoid tilting, with some sensing the position can be pressed in without great resistance. \u2192 Make sure that the edge of the bearing is flush with the aluminium part. If a bearing cannot be pressed in, it may be caused by a protruding burr or too much paint. You can easily rework the bore with a knife (e.g., cutter knife for wallpaper or floors) or with a file. If the bore has become too large, the bearing can be glued to the flange of the bearing with a small drop of glue (e.g., Uhu\u00ae Endfest or comparable). The bearings may come loose during final assembly due to uneven pressing of the cylindrical pins into the plastic holders. This is, however, not too bad, as the pins can easily be pushed back into the intended hole. Sticking should be a last resort. The bearings clamp sufficiently strongly in the holes for the operation of the robot even without glue. Figure 24 \u2192 Figure 24 shows the bottom plate from above! Figure 25 shows how you can press the bearings into the base plate using the femur aluminium parts as a support. The hexagon wrench must press against the edge of the bearing. Masking the aluminium parts with painter tape protects them from scratching. Other parts that can be found in the hobby workshop can also be used as underlay. \u2192 Do not use adhesive tape that cannot be removed without leaving a residue. Figure 25 The femur counter bearing must be assembled a total of 6 times. Figure 26 Figure 27 shows how you can push the bearing into the aluminium part by hand. The bearing should snap into the bore provided with a bold push. Figure 27 Make sure that the edge of the bearing is flush with the aluminium part. Figure 28 Caution These screws (all M2) are now already provided with a screw lock. Required tool: PH1 Phillips screwdriver Small flat nose pliers or wrench for M2 nut (SW4) Screw locking (medium strength) Mounting the servo discs on the upper plate: \u2192 Figure 29 shows the top plate from above! Figure 29 \u2192 Figure 30 shows the top plate from below! Figure 30 The femur servo mount must be mounted a total of 6 times. Figure 31 Figure 32","title":"Mounting of bearings"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#mounting-the-spacer","text":"Next, screw together the spacers (30 mm long) for the legs, top and bottom plates as shown in Figure 33. A total of 12 screwed spacers are required. Required tool: 2x SW 5.5mm open-end wrench Then fit a screwed spacer to each femur counter bearing. Insert the threaded side through the counter bearing and fix it with an M3 nut. It is sufficient if the spacers are only tightened by hand. Do not tighten these screws until the assembly is complete. This way you still have the possibility to easily adjust everything during assembly. Figure 33 Figure 34 Do the same with the base plate. \u2192 Figure 35 shows the bottom plate from above! Figure 35","title":"Mounting the spacer"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#mounting-the-servos-on-the-top-plate","text":"Mount the servos with the M3 screws (M3 x 6 mm, large head diameter) as shown in Figure 36. \u2192For mounting the servos with the servo discs, always use the M3 x 6 mm screws (servo mounting screws) with the larger 6 mm head is used. The M3 x 6 mm screws with the smaller 5 mm head are used for the spacers! Insert the servos into the teeth of the previously mounted servo disks. Proceed carefully so that the servos do not twist during insertion. If it should happen that a servo has rotated from the middle position during assembly, then bring the servo back to the middle position with the aid of the Hexapod Robot Board and the \"ServoCenter\" software. This procedure has already been described in Chapter 12. If, due to the teeth of the servo disk or the general mechanical tolerances, you are not yet able to align the legs too precisely, this is not a problem. Adjust the leg as mechanically as possible, as shown in the illustration. An exact calibration is done after the assembly with the help of the software. \u2192 The servo mounting screws (PH2 (M3 x 6 mm, large head diameter) are not yet equipped with a screw lock! Only when the robot has been completely assembled and calibrated can these screws be removed and secured! Required tool: PH2 Phillips screwdriver Figure 36 Figure 36 illustrates the Hexapod body viewed from \"above\". The two front and the two rear legs are installed in such a way that they point outwards at an angle of 45\u00b0 without twisting the centre position of the servo (centre position). You can orient yourself on the cross-paths in the upper plate at an angle of 45\u00b0. The two middle legs (left and right side) are installed straight outwards at an angle of 90\u00b0 to the body. \u2192 Please also refer to Figure 37 on the next page. Figure 37","title":"Mounting the servos on the top plate"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#mount-bottom-plate","text":"Mounting the bottom plate requires some skill. Place the top plate with its back on the table as shown in Figure 38. Push the cylinder pins of the base plate into the plastic holders of the top plate, starting from the front or rear, all the way round. Do not push the pins completely in the first time, but repeat the working step and press the cylinder pin only a few millimetres into the plastic each time it circulates. This prevents the component from becoming strained! \u2192 Place an underlay, such as a cardboard box, between the component and the table so that you do not scratch the table with the screw heads! The foam from the packaging for instance is very suitable for this purpose. Do not use force. This can damage the servos, the base plate and the ball bearings! You can set the correct distance between the bearing and the plastic holder using a 2.5 mm Hexagon key. The Hexagon key serves as a distance gauge, see Figure 41. Finally, the upper plate is screwed together with spacers. Use the M3 x 6 screws (small head diameter 5 mm) for this purpose. Required tool: PH2 Phillips screwdriver Underlay e.g., cardboard box; \u2192 Figure 38 shows the bottom side of the robot! Figure 38 \u2192 Figure 39 shows the top side of the robot! Figure 39 Figure 40 shows how the dowel pins are only slightly pressed in to fix them in the plastic. Only when all the dowel pins have been fixed in the holes of the plastic holders are they pressed in at a distance (2.5 mm). To achieve the correct distance, place the Hexagon key between the bearing and the plastic holder and press the cylinder pins into the plastic holder with moderate force. If a cylindrical pin has been pressed in too far by mistake, you can correct this with a wide slotted screwdriver by gently levering it out. Make sure, however, that the aluminium parts are not damaged (scratched). After all bearings have been pressed in and adjusted to the correct distance, screw them together with the spacers. Figure 41 shows how to set the correct distance using the 2.5 mm hexagon wrench as the spacer. Figure 40 Figure 41","title":"Mount bottom plate"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#mounting-the-receiver-and-hexapod-robot-board","text":"Now the radio receiver for the gamepad is connected to the robot board and mounted. The receiver is fixed to the underside of the robot board with the supplied double-sided adhesive tape. \u2192 The receiver and the connection cable must first be connected to each other. Connect the wide receiver plug to the receiver. When connecting the receiver to the robot board, make sure that the polarity of the connectors is correct. Required tool: Scissors PH2 Phillips screwdriver Open-end wrench SW 5.5 mm Plug the cable into the receiver as shown in Figure 42. The \"POWER\" and \"RX\" labels point upwards in the illustration. Use the same colour sequence as shown in the illustration. Figure 42 Shorten the double-sided adhesive tape to approx. 25 mm using scissors. Then peel off one side of the protective film of the adhesive tape and stick this side onto the robot board. Figure 43 Now peel off the other side of the protective film and affix the receiver. Make sure that the housing side with the two red LEDs locks with the \"thick\" contacts (see arrow in the illustration) of the loudspeaker. If the housing protrudes too far into the contacts of the loudspeaker, the housing will press against the contacts of the loudspeaker when mounting the circuit board. Figure 44 Now connect the cable to the robot board. The colours are combined in the plugs to 3 wires each. From left (MicroSD card holder position) to right (battery plug position): White, grey, purple -> White points to outer edge of board Blue, green, yellow -> Blue points to the outer edge of the board Orange, red brown -> Orange points to the outer edge of the board. \u2192 Figure 45b shows a detail enlargement of Figure 45. Figure 45a Figure 45b Now mount the robot board with the four 15 mm spacers. The threaded side of each spacer is inserted into the top plate and fastened with an M3 nut. \u2192 Do not tighten the M3 nuts too tightly as this will allow you to readjust them easily to mount the PCB without tension. Only when the board has been fixed to the spacers with four screws M3 x 6 mm (small head diameter 5 mm), tighten the M3 nuts. In this way you can align the board cleanly. Figure 46 Figure 47 shows the pin assignment of the receiver (left) and the pin assignment of the robot board (right). Figure 47","title":"Mounting the Receiver and Hexapod Robot Board"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#mounting-the-legs","text":"Try to mount the legs the as well as you can. Minor deviations do not play a role and cannot be avoided by the mechanical tolerances and by the coarse teeth of the servo disks. \u2192 The legs will be exactly adjusted later by software! Figure 48 (see also Figure 20) shows the basic configuration of a Hexapod leg. It should be noted that the thigh (femur) is aligned parallel to the ground (\"ground\" in the picture). The pivot point of the shin (\"tibia\") is parallel to the body (\"body\"). When the leg is fully adjusted, there is a 90\u00b0 angle between the femur and the tibia. The arrangement between \"body\" and \"femur\" is parallel in one line. The difference in height does not play a role here. Figure 49 (see also Figure 17) once again shows the pin assignment of the robot board for the leg servos. The following list shows wherein each servo is connected. Basically, the connection sequence \"COXA\", \"FEMUR\", \"TIBA\" always applies; then follows the plug contact \"SAx\", which remains free! Figure 48 Now connect the servos to the board. With the \"ServoCenter\" programme you can always check during assembly whether the leg is still in the basic position. Figure 49 \u2192 After mounting each leg, use the \"ServoCenter\" programme to check whether the leg is in the basic configuration or whether an error has crept in due to turning the servo while mounting! RR (right rear) LR (left rear) S0 = Coxa S9 = Coxa S1 = Femur S10 = Femur S2 = Tibia S11 = Tibia RM (right middle) LM (left middle) S3 = Coxa S12 = Coxa S4 = Femur S13 = Femur S5 = Tibia S14 = Tibia RF (right front) LF (left front) S6 = Coxa S15 = Coxa S7 = Femur S16 = Femur S8 = Tibia S17 = Tibia Coxa = hip Femur = thigh Tibia = leg or shine-bone First mount the thighs (\u201cfemur\u201d) as shown in Figure 50. Screw the thighs to the servos (M3 x 6 mm screws, large head diameter 6 mm). Then assemble the legs \u201ctibia\u201d and fix them with the M3 x 6 screws (large head diameter 6 mm). It is helpful to lift the robot with the help of a cardboard box. If you have a 3D printer, you can also print out the robot stand. The files can be found free of charge at Conrad.com on the respective product website. \u2192 After the robot is completely assembled and adjusted, you should provide the screws, which connect the servo disk with the servo, with a small drop of screw lock. During operation they will loosen quickly and may get lost! Required tool: PH2 Phillips screwdriver Open-end wrench SW 5.5 mm Figure 50 Despite the angled tibia servos, \"femur\" must be parallel to the floor at the end and \"tibia\" parallel to the body. The \"femur\" and \"tibia\" make a 90\u00b0 angle; the servos themselves are still in the middle position! Figure 52 shows the Robobug when all legs are fully assembled and in the home position. Ideally, the red line (Figure 51) would run exactly in the middle of the screw heads. Since the servo disks do not allow this due to the toothing and the mounting tolerance, it may be slightly off the mark with some legs. This is not bad, the exact alignment to the middle will be done later by software. Figure 51 Figure 52 Now mount the counter bearings. \u2192 The U holder has two holes, use the hole facing the cable opening. When pressing in the dowel pins, proceed in the same way as when pressing in the dowel pins of the base plate. The distance between the bearing and the plastic part here is 1.5 mm. You can also use an Hexagon key as a distance gauge here. Then screw the spacer on each leg with a M3 x 6 mm screw (small head diameter 5 mm) as shown in Figure 53. Figure 53 The 1.5 mm hexagon key is placed between the ball bearing and the plastic part and the cylindrical pin is pressed in until it stops. Also, in this case, press the cylindrical pins only alternately (first one side then the other) piece by piece into the plastic so as not to tilt the holder. \u2192 If you hold the robot at an angle, you can hang the Hexagon key over the cylinder pin without it falling down. Figure 55 shows the Robobug with the legs fully assembled and in the basic position. Figure 54 Figure 55","title":"Mounting the legs"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#laying-the-cables","text":"Lay the cables as shown in the illustrations. Use the supplied cable ties for this purpose. After the cable ties have been tightened, cut off the protruding part of the cable tie. A clean cable laying gives the robot a very high-quality appearance! \u2192 As long as you have not finished aligning the cables, you should not tighten the cable ties too tightly. This way you can make small corrections easily. Required tool: Electronic side cutter Figure 56 Figure 57 Figure 58 Figure 59 Figure 60 Figure 61 Figure 62","title":"Laying the cables"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#installing-the-battery","text":"The battery is mounted edgeways with the supplied Velcro fastener as shown in the illustrations. To do this, shorten the Velcro fastener to approx. 25 cm. Tighten the Velcro so that the battery has a firm grip on the battery plate and cannot slip during operation. Figure 63 Then run the cable through the top plate as shown in Figure 64a. Screw the battery retaining plate to the lower plate. Use the screws M4 x 5 mm for this purpose. Figure 64a In Figure 64b (see also Figure 7) you can see how the battery is plugged into the Robobug. The plug is protected against reverse polarity and cannot therefore be plugged in the wrong way. Figure 64b","title":"Installing the battery"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#mounting-the-rubber-feet","text":"Slide the supplied rubber feet onto the ends of the legs. You can also secure the rubber caps with some glue (e.g., Uhu\u00ae All Purpose Glue or similar) so that they are not lost during operation. \u2192 The rubber feet not only secure a good grip on the ground, but also ensure that the aluminium legs do not scratch the ground (floor, table etc.). Figure 65","title":"Mounting the rubber feet"},{"location":"educational-robotics/robobug-hexapod/assembling-the-mechanical-parts/#setting-jumpers","text":"Finally, the two jumpers are plugged in. The jumper for the infrared receiver is plugged on \"IR-U\"; the jumper J7 is plugged only on one pin. \u2192 If you connect jumper J7 to both pins, the gamepad will be deactivated! Figure 66","title":"Setting jumpers"},{"location":"educational-robotics/robobug-hexapod/calibrate-legs/","text":"Calibrate legs \u00b6 To adjust the legs exactly, use the programme \"Terminal\" (if you work with the Windows operating system) or alternatively, the Arduino IDE Terminal. The aim now is to adjust the legs into an exact basic configuration. When assembling the mechanics, you will not be able to bring the legs 100% into the basic configuration due to the teeth of the servo disks and the mechanical tolerances. You can use this tool to compensate for these deviations. Figure 69 shows how the basic configuration should look for each leg. Figure 69 The fictitious red lines show how to align the leg. The thigh \"femur\" must be aligned so that it is parallel to the floor. The tibia is perpendicular to the floor and makes a 90\u00b0 angle at the thigh. If the robot is placed on a flat surface with a mounting aid as shown in the illustration, the distance between the table and the centre of the M3 cross screws can easily be measured with a ruler. The angle can also be easily checked with a ruler by using it as an angle as shown in the illustration. The ruler stands with the short edge on the table and the long side must coincide with the vertical red line. Figure 70 shows a ready mounted leg in the basic position. Ideally, the red line would run exactly in the middle of the screw heads. Since the servo disks do not allow this due to the toothing and the mounting tolerance, it may be slightly off the mark on some legs. You can now correct this with the calibration. \u2192 Use a mounting aid: Our mounting aid is ideal for calibrating the legs. The mounting aid is available as a 3D model for download at www.conrad.com under the product. For printing you need a suitable 3D printer. Alternatively, you can of course also use any other base such as a pot, a sturdy box or similar. It is important that the robot stands stable on it and does not wobble; the legs must not be obstructed in the movement. Figure 70 Calibrating legs with PC If you are using Windows, you can use the \"Terminal\" program. The programme is located in the \"Terminal\" folder. If you are using MAC OS or Linux, you can skip this part and continue with the section \"Leg calibration with the Arduino IDE\". Start the programme with the file \"Terminal.exe\" and perform the calibration. Elevate the robot upwards so that the legs can move freely in the air. A stable box can, for example, serve for the elevation. Connect the Hexapod Robot Board (connector \"PRG-M\") to your computer as already done when installing the firmware. Connect the battery to the Hexapod Robot Board. Start the programme \"Terminal.exe\". Now select the serial port (same port as for programming). To do this, click on \"Select Port\". If more than one device is displayed, simply unplug the motherboard and plug it back into the USB port. The device which then disappeared briefly is the correct one. Select 38400 Baud under \"Baud rate\". Click on \"Connect\". The robot appears in the terminal window, as shown in Figure 71. Click on \"Servo offset mode\" in the upper left corner to enter the calibration mode. The robot will now \"wobble\" with the servo selected for adjustment. By clicking on \"+\" and \"-\" several times, you can adjust the selected servo exactly in small steps. Once you have finished setting the servo, you can click on \"Next\" to set the next servo until you have set all 18 servos. You can also select a specific leg by clicking on the \"Leg RR\", \"Leg RM\", \"Leg RF\", \"Leg LR\", \"Leg LM\" and \"Leg LF\" buttons. Once all servos have been set, click on \"Exit\". The programme now asks whether the settings should be saved. Click on \"Yes\" to save the settings or \"No\" to discard the settings. With \"Clear Terminal\" you can delete the contents of the terminal window. Figure 71 Calibrating legs with the Arduino IDE If you are using a MAC or Linux, you cannot use the \"Terminal\" programme (only suitable for Windows). However, you can still adjust the legs by using another terminal programme of your choice. The easiest way is to use the Arduino Terminal. You can invoke this in the Arduino IDE. The figure shows the Arduino terminal after the terminal has connected to the robot board. Proceed as follows: Connect the Hexapod Robot Board (connector \"PRG-M\") to your computer as already done when installing the firmware. Connect the battery to the Hexapod Robot Board. Start the terminal program. If you are using a terminal other than the Arduino terminal, select the serial port (same port as for programming). Select a baud rate of 38400 baud. No LF and CR or \"No line encoding\" in the Arduino terminal. Connect the terminal to the robot. The robot appears in the terminal window, as shown in Figure 72. Please note: The Arduino terminal connects immediately after opening! Press the \"RESET-M\" button on the Hexapod Robot Board once. This is not necessary when using the Arduino terminal. Figure 72 The following text appears in the terminal window. PS2 Init: 0 Maker Factory Hexapod Monitor O - Enter servo offset mode Send an \"O\" to the robot board by writing \"O\" in the transmission line and then pressing the Enter key. The robot will now \"wiggle\" with the chosen servo in the setting. \u2192 The characters can be written in small or capital letters (\"o\" as well as \"O\" is possible). The following message then appears in the terminal: Serial Cmd Line:o Find Servo Zeros. $-Exit, +- changes, *-change servo 0-5 Chooses a leg, C-Coxa, F-Femur, T-Tibia Servo: RR Coxa(0) The following input options are available: With \"$\" you leave the calibration -> Exit With \"+\" or \"-\" you can precisely adjust the selected servo in small steps. The characters must be sent to the Hexapod Robot Board until the leg is correctly adjusted. Use \"*\" to select the next servo. With a number from 0 to 5 you can select the legs individually. 0 = Leg RR (right rear) 1 = Leg RM (right middle) 2 = Leg RF (right front) 3 = Leg LR (left rear) 4 = Leg LM (left middle) 5 = Leg LF (left front) When all servos are set, send a \"$\" character. The programme will now ask if you want to save the data. Send \"y\" for save or \"n\" to discard the settings. \u2192 You may need to perform this calibration procedure again after some time. The reason for this is that after a certain operating time the servos get a larger gear backlash and the first calibration no longer proves to be ideal. After the Robobug has been assembled and calibrated, you can unscrew the screws M3 x 6 mm (large head diameter 6 mm) and secure them with a screw lock. These are then screwed in again. Also check all other screws for tightness.","title":"Calibrate legs"},{"location":"educational-robotics/robobug-hexapod/calibrate-legs/#calibrate-legs","text":"To adjust the legs exactly, use the programme \"Terminal\" (if you work with the Windows operating system) or alternatively, the Arduino IDE Terminal. The aim now is to adjust the legs into an exact basic configuration. When assembling the mechanics, you will not be able to bring the legs 100% into the basic configuration due to the teeth of the servo disks and the mechanical tolerances. You can use this tool to compensate for these deviations. Figure 69 shows how the basic configuration should look for each leg. Figure 69 The fictitious red lines show how to align the leg. The thigh \"femur\" must be aligned so that it is parallel to the floor. The tibia is perpendicular to the floor and makes a 90\u00b0 angle at the thigh. If the robot is placed on a flat surface with a mounting aid as shown in the illustration, the distance between the table and the centre of the M3 cross screws can easily be measured with a ruler. The angle can also be easily checked with a ruler by using it as an angle as shown in the illustration. The ruler stands with the short edge on the table and the long side must coincide with the vertical red line. Figure 70 shows a ready mounted leg in the basic position. Ideally, the red line would run exactly in the middle of the screw heads. Since the servo disks do not allow this due to the toothing and the mounting tolerance, it may be slightly off the mark on some legs. You can now correct this with the calibration. \u2192 Use a mounting aid: Our mounting aid is ideal for calibrating the legs. The mounting aid is available as a 3D model for download at www.conrad.com under the product. For printing you need a suitable 3D printer. Alternatively, you can of course also use any other base such as a pot, a sturdy box or similar. It is important that the robot stands stable on it and does not wobble; the legs must not be obstructed in the movement. Figure 70 Calibrating legs with PC If you are using Windows, you can use the \"Terminal\" program. The programme is located in the \"Terminal\" folder. If you are using MAC OS or Linux, you can skip this part and continue with the section \"Leg calibration with the Arduino IDE\". Start the programme with the file \"Terminal.exe\" and perform the calibration. Elevate the robot upwards so that the legs can move freely in the air. A stable box can, for example, serve for the elevation. Connect the Hexapod Robot Board (connector \"PRG-M\") to your computer as already done when installing the firmware. Connect the battery to the Hexapod Robot Board. Start the programme \"Terminal.exe\". Now select the serial port (same port as for programming). To do this, click on \"Select Port\". If more than one device is displayed, simply unplug the motherboard and plug it back into the USB port. The device which then disappeared briefly is the correct one. Select 38400 Baud under \"Baud rate\". Click on \"Connect\". The robot appears in the terminal window, as shown in Figure 71. Click on \"Servo offset mode\" in the upper left corner to enter the calibration mode. The robot will now \"wobble\" with the servo selected for adjustment. By clicking on \"+\" and \"-\" several times, you can adjust the selected servo exactly in small steps. Once you have finished setting the servo, you can click on \"Next\" to set the next servo until you have set all 18 servos. You can also select a specific leg by clicking on the \"Leg RR\", \"Leg RM\", \"Leg RF\", \"Leg LR\", \"Leg LM\" and \"Leg LF\" buttons. Once all servos have been set, click on \"Exit\". The programme now asks whether the settings should be saved. Click on \"Yes\" to save the settings or \"No\" to discard the settings. With \"Clear Terminal\" you can delete the contents of the terminal window. Figure 71 Calibrating legs with the Arduino IDE If you are using a MAC or Linux, you cannot use the \"Terminal\" programme (only suitable for Windows). However, you can still adjust the legs by using another terminal programme of your choice. The easiest way is to use the Arduino Terminal. You can invoke this in the Arduino IDE. The figure shows the Arduino terminal after the terminal has connected to the robot board. Proceed as follows: Connect the Hexapod Robot Board (connector \"PRG-M\") to your computer as already done when installing the firmware. Connect the battery to the Hexapod Robot Board. Start the terminal program. If you are using a terminal other than the Arduino terminal, select the serial port (same port as for programming). Select a baud rate of 38400 baud. No LF and CR or \"No line encoding\" in the Arduino terminal. Connect the terminal to the robot. The robot appears in the terminal window, as shown in Figure 72. Please note: The Arduino terminal connects immediately after opening! Press the \"RESET-M\" button on the Hexapod Robot Board once. This is not necessary when using the Arduino terminal. Figure 72 The following text appears in the terminal window. PS2 Init: 0 Maker Factory Hexapod Monitor O - Enter servo offset mode Send an \"O\" to the robot board by writing \"O\" in the transmission line and then pressing the Enter key. The robot will now \"wiggle\" with the chosen servo in the setting. \u2192 The characters can be written in small or capital letters (\"o\" as well as \"O\" is possible). The following message then appears in the terminal: Serial Cmd Line:o Find Servo Zeros. $-Exit, +- changes, *-change servo 0-5 Chooses a leg, C-Coxa, F-Femur, T-Tibia Servo: RR Coxa(0) The following input options are available: With \"$\" you leave the calibration -> Exit With \"+\" or \"-\" you can precisely adjust the selected servo in small steps. The characters must be sent to the Hexapod Robot Board until the leg is correctly adjusted. Use \"*\" to select the next servo. With a number from 0 to 5 you can select the legs individually. 0 = Leg RR (right rear) 1 = Leg RM (right middle) 2 = Leg RF (right front) 3 = Leg LR (left rear) 4 = Leg LM (left middle) 5 = Leg LF (left front) When all servos are set, send a \"$\" character. The programme will now ask if you want to save the data. Send \"y\" for save or \"n\" to discard the settings. \u2192 You may need to perform this calibration procedure again after some time. The reason for this is that after a certain operating time the servos get a larger gear backlash and the first calibration no longer proves to be ideal. After the Robobug has been assembled and calibrated, you can unscrew the screws M3 x 6 mm (large head diameter 6 mm) and secure them with a screw lock. These are then screwed in again. Also check all other screws for tightness.","title":"Calibrate legs"},{"location":"educational-robotics/robobug-hexapod/cleaning/","text":"Cleaning \u00b6 Info The outside of the robot should only be cleaned with a soft, dry cloth or brush. Caution Never use aggressive cleaning agents or chemical solutions as these may damage the surface of circuit board. Protect the circuit board from dirt and humidity.","title":"Cleaning"},{"location":"educational-robotics/robobug-hexapod/cleaning/#cleaning","text":"Info The outside of the robot should only be cleaned with a soft, dry cloth or brush. Caution Never use aggressive cleaning agents or chemical solutions as these may damage the surface of circuit board. Protect the circuit board from dirt and humidity.","title":"Cleaning"},{"location":"educational-robotics/robobug-hexapod/construction_video/","text":"Construction video \u00b6 For better understanding how to assemble the Robobug we have produced a short construction video together with YouTuber \"Kondensatorschaden\" (German Language)","title":"Construction Video"},{"location":"educational-robotics/robobug-hexapod/construction_video/#construction-video","text":"For better understanding how to assemble the Robobug we have produced a short construction video together with YouTuber \"Kondensatorschaden\" (German Language)","title":"Construction video"},{"location":"educational-robotics/robobug-hexapod/controlling-with-the-gamepad/","text":"Controlling with the Gamepad \u00b6 After you have transferred the \"motion firmware\" to the Locomotion controller (see chapter 14), you can control the robot with the gamepad. With the included gamepad, all functions of the Locomotion controller are immediately available to you after commissioning and the robot can be moved similar to a remotecontrolled car without you having to create your own programme beforehand. \u2192 To check the settings comfortably and quickly, it is advantageous to operate the robot with the gamepad. Alternatively, you can also control it directly via a user board. In practice, however, this has turned out to be less convenient for initial commissioning. In addition, you can later intervene in the sequence of your programme with the help of the gamepad when using a user board. It is also possible to read the control commands (joystick values and buttons) from the user board and use them in your own program. Important Make sure that the receiver is connected correctly and that the plugs are not twisted on the pin strips, otherwise the receiver may be damaged! The jumper \"J7\" must not be plugged in, otherwise the gamepad is deactivated (see chapter 13. l). Quick Start: Disconnect the power supply from the Hexapod Robot Board. Switch on the gamepad with the switch (6). The two LEDs (12) \"Green\" and \"Red\" flash. Connect the battery to the Hexapod Robot Board. The LEDs (12) \"Green\" and \"Red\" light up permanently after a few seconds. The transmitter (gamepad) is now connected to the receiver. Press the \"START\" button (15). The robot beeps and the red \"USER-LED\" on the Hexapod Robot Board lights up permanently. Switch on the robot with the key (3). The robot beeps and the blue \"LIVE-LED\" on the Hexapod Robot Board flashes. Let the robot stand up by pressing button (1). Use the thumb joystick (7) to move the robot forwards/backwards and left/right. With the thumb joystick (5) you can turn the robot on the spot. Detailed description of the gamepad functions: Make the robot stand up and sit down (toggle function) System reset Switch the robot on/off after the gamepad has been activated with the key (15) Switch on/off balance mode (toggle function) Right Thumb joystick (turn on the spot, turn in rotate and translate mode and change the height of the robot) LED lights green when the connection to the robot has been established Left thumb joystick (forward/backward, in rotate and translate mode forward/backward and lateral movement). D-Pad up/down adjusts the height of the robot (up = higher, down = lower). D-Pad left/right adjusts the running speed (left = slower, right = faster) Upper key = translate mode (toggle function) Lower key = rotate mode (toggle function) On/off switch Select gait (Tripod-6, Tripod-8, Tripple-12, Tripple-16, Ripple-12, Wave-24). Each time the button is pressed again, the gait is shifted through as described in the list. If the list starts from the beginning (Tripod-6), the Hexapod Robot Board signals this with a different tone sequence. No function Activate gamepad (after this the robot reacts to control commands) Activates double step height (toggle function) 17 Activates double step size (toggle function) \u2192 All buttons with toggle function (renewed pressing, changes the state) makes the robot board beep in different tone sequence. If you press the key for the first time, the Hexapod Robot Board acknowledges this with a beep and when you press it again (original state) with a tone sequence. This makes it easy to find out what state the robot is in. After the tone sequence has sounded, the original state (start state) is always active.","title":"Controlling with the Gamepad"},{"location":"educational-robotics/robobug-hexapod/controlling-with-the-gamepad/#controlling-with-the-gamepad","text":"After you have transferred the \"motion firmware\" to the Locomotion controller (see chapter 14), you can control the robot with the gamepad. With the included gamepad, all functions of the Locomotion controller are immediately available to you after commissioning and the robot can be moved similar to a remotecontrolled car without you having to create your own programme beforehand. \u2192 To check the settings comfortably and quickly, it is advantageous to operate the robot with the gamepad. Alternatively, you can also control it directly via a user board. In practice, however, this has turned out to be less convenient for initial commissioning. In addition, you can later intervene in the sequence of your programme with the help of the gamepad when using a user board. It is also possible to read the control commands (joystick values and buttons) from the user board and use them in your own program. Important Make sure that the receiver is connected correctly and that the plugs are not twisted on the pin strips, otherwise the receiver may be damaged! The jumper \"J7\" must not be plugged in, otherwise the gamepad is deactivated (see chapter 13. l). Quick Start: Disconnect the power supply from the Hexapod Robot Board. Switch on the gamepad with the switch (6). The two LEDs (12) \"Green\" and \"Red\" flash. Connect the battery to the Hexapod Robot Board. The LEDs (12) \"Green\" and \"Red\" light up permanently after a few seconds. The transmitter (gamepad) is now connected to the receiver. Press the \"START\" button (15). The robot beeps and the red \"USER-LED\" on the Hexapod Robot Board lights up permanently. Switch on the robot with the key (3). The robot beeps and the blue \"LIVE-LED\" on the Hexapod Robot Board flashes. Let the robot stand up by pressing button (1). Use the thumb joystick (7) to move the robot forwards/backwards and left/right. With the thumb joystick (5) you can turn the robot on the spot. Detailed description of the gamepad functions: Make the robot stand up and sit down (toggle function) System reset Switch the robot on/off after the gamepad has been activated with the key (15) Switch on/off balance mode (toggle function) Right Thumb joystick (turn on the spot, turn in rotate and translate mode and change the height of the robot) LED lights green when the connection to the robot has been established Left thumb joystick (forward/backward, in rotate and translate mode forward/backward and lateral movement). D-Pad up/down adjusts the height of the robot (up = higher, down = lower). D-Pad left/right adjusts the running speed (left = slower, right = faster) Upper key = translate mode (toggle function) Lower key = rotate mode (toggle function) On/off switch Select gait (Tripod-6, Tripod-8, Tripple-12, Tripple-16, Ripple-12, Wave-24). Each time the button is pressed again, the gait is shifted through as described in the list. If the list starts from the beginning (Tripod-6), the Hexapod Robot Board signals this with a different tone sequence. No function Activate gamepad (after this the robot reacts to control commands) Activates double step height (toggle function) 17 Activates double step size (toggle function) \u2192 All buttons with toggle function (renewed pressing, changes the state) makes the robot board beep in different tone sequence. If you press the key for the first time, the Hexapod Robot Board acknowledges this with a beep and when you press it again (original state) with a tone sequence. This makes it easy to find out what state the robot is in. After the tone sequence has sounded, the original state (start state) is always active.","title":"Controlling with the Gamepad"},{"location":"educational-robotics/robobug-hexapod/declaration_of_conformity/","text":"Declaration of Conformity (DOC) \u00b6 We, Conrad Electronic SE, Klaus-Conrad-Stra\u00dfe 1, D-92240 Hirschau, hereby declare that this product conforms to the 2014/53/EU directive. \u2192 The full text of the EU conformity declaration is available via the following Internet address: www.conrad.com/downloads Select a language by clicking a flag symbol and enter the order number of the product in the search field; then you will be able to download the EU declaration of conformity in PDF format.","title":"Declaration of Conformity (DOC)"},{"location":"educational-robotics/robobug-hexapod/declaration_of_conformity/#declaration-of-conformity-doc","text":"We, Conrad Electronic SE, Klaus-Conrad-Stra\u00dfe 1, D-92240 Hirschau, hereby declare that this product conforms to the 2014/53/EU directive. \u2192 The full text of the EU conformity declaration is available via the following Internet address: www.conrad.com/downloads Select a language by clicking a flag symbol and enter the order number of the product in the search field; then you will be able to download the EU declaration of conformity in PDF format.","title":"Declaration of Conformity (DOC)"},{"location":"educational-robotics/robobug-hexapod/demo_programs/","text":"Demo programs \u00b6 To use the user boards easily and comfortably, use the Maker-Factory Hexapod library. This library was already installed at the beginning of this manual. The provided examples show the use of the user boards and the functionality of the Arduino Hexapod library. When using user boards that are not Arduino compatible (like SBC), look at the file \"Hexapod_Lib.h\". This file shows how the communication between the user board and the locomotion controller works. This will serve you as an example for developing your own function library. To do this, unpack the ZIP file \"\\LibraryDemos\\Maker-Factory-Hexapod-Vx.1.zip\" from the download bundle and look at the source code of the library in an editor such as Notepad or a development environment of your choice. Warning The supplied examples are designed for \"Arduino UNO\" and \"NodeMCU\" boards programmed with the Arduino IDE. Figure 78 The Arduino examples show how to use the library. These can be found in the Arduino IDE under \"Examples\\Maker-Factory-Hexapod-Vx.x...\". Take your time to look at all the examples and test them on your Hexapod. Once you have understood the examples, you can start and create your own programmes with them. Take a closer look at the \"Hexapod_Lib.h\". With some experience you can easily extend it with your own functions. Short description of the provided examples for Locomotion TODO \u00b6 In the folder \"Locomotion\" you find the examples for the Locomotion controller (Arduino MEGA2560). LEDs Small test programm that alternately flashes the two LEDs (Users and Live). Motion-Firmware Firmware of the locomotion controller. ServoCenter This program moves the servos to the middle position. As needed for mechanical assembly of the Hexapod robot. Brief description of the supplied examples for user boards \u00b6 In the folder \"User-Boards\" you will find the examples for Arduino UNO and NodeMCU or compatible boards. Warning Before use, change the Arduino IDE to the correct Arduino board! Also, read the information in the comments to the respective examples! Info The \"Hexapod_Lib.h\" contains all functions that are sent and received from the UserBoard to the Locomotion-Controller. For the advanced developer it is worthwhile to have a look inside or to extend these with proper functions. The functions contain a detailed comment which parameters can be passed. The programme code for receiving the data, sending the data to the UserBoard and evaluating the gamepad can be found in the locomotion firmware in the file \"Data_Input.h\". The \"Hexapod_Lib.h\" can also be downloaded from the product's website. \"CardInfo\" \u00b6 Info This example is intended only for Arduino UNO or compatible boards! With this example you can check the function of the MicroSD card reader. Insert a MicroSD memory card with arbitrary content into the card slot and start the example. The terminal displays the contents of the memory card (file name). All original Arduino SD card examples work. You only have to change the pin for \"CS\" (Chipselect) as in this example. The terminal baud rate is 19200 baud. \"EspMoveAP\" \u00b6 Info This example is intended for NodeMCU boards only The example shows control via an HTTP server using a direct WiFi connection to the NodeMCU board. The programme sets up an access point with which you can connect to a smartphone, for example. The assigned IP address is displayed in the terminal. Type it into your browser. Then the browser loads the web interface to control the robot. You can then control the robot via WiFi by tapping or clicking the buttons. The example can easily be extended by you into other functionalities. The terminal baud rate is 115200 baud. \"EspMoveWiFi\" \u00b6 Info This example is intended for NodeMCU boards only The example shows the control via a web browser using a WiFi connection to the NodeMCU board. The programme establishes a connection to your router and the robot is then accessible within your network. The assigned IP address is displayed in the terminal. Type it into your browser. Then the browser loads the web interface to control the robot. You can then control the robot via WiFi by tapping or clicking the buttons. The example can easily be extended by you into other functionalities. The terminal baud rate is 115200 baud. \"Infrared\" \u00b6 Info This example is intended only for Arduino UNO or compatible boards! The example reads an RC5 infrared code and outputs the values at the terminal. Plug the Jumper J8 in the direction of the label \"IR-U\". The universal remote control can serve as an IR transmitter set to RC5 (many Philips devices work with RC5), which is available for TV and audio equipment in stores. The terminal baud rate is 19200 baud. \"Moving_01\" \u00b6 This example shows how data is sent to the locomotion controller without the Hexapod library. This example is well suited as a basis for using SBC. However, experience in programming is necessary! Have a closer look at the function SendData(). Here you can see how data is sent from the user board to the locomotion controller. The programme does not make an acknowledgement evaluation, but sends the data only to the locomotion controller without evaluating an answer from the locomotion controller. \"Moving_02\" \u00b6 This example is ideal for getting started with the programming of user boards and shows the basic functions to control the Hexapod with the help of the library. \"Moving_03\" \u00b6 This example shows how to use the ROBOT_MOVE() function. \"Moving_04\" \u00b6 This example shows how to use the ROBOT_ROTATE_MODE() and ROBOT_TRANSLATE_MODE() functions. \"Moving_05\" \u00b6 This example shows how to use the ROBOT_SINGLE_LEG() function. \"Moving_06\" \u00b6 This example shows how to interrupt a user programme using the gamepad. In this example, use the terminal to receive the messages from the robot. Set the robot to an elevation so that the legs move in the air without touching the ground. This allows you to observe the output when controlling the robot on the terminal. The terminal baud rate is 115200 baud. \"ReadGamepad\" \u00b6 The example shows how you can read the control data of the gamepad from the locomotion controller. If you plug in the jumper \"J7\", the locomotion controller no longer reacts to the gamepad. It is then possible to use the data only on the user board and to realise your own controls. The terminal baud rate is 115200 baud \"ReadValues_01\" \u00b6 The example shows how you can send and read data between locomotion controller and user board without a library. This example is well suited as a basis for using SBC. However, experience in programming is necessary! The terminal baud rate is 115200 baud. \"ReadValues_02\" \u00b6 This example shows how to read data from the locomotion controller using the library. The terminal baud rate is 115200 baud. \"Servo\" \u00b6 The example shows the use of additional servos which are controlled via the user board. The connectors SU1 to SU3 are used for this purpose. It is also possible to use the connectors SU1 to SU3 for other components such as sensors, buttons, switches, etc. The terminal baud rate is 115200 baud. \"Sound\" \u00b6 The example shows a simple sound output via the loudspeaker. \"Switches\" \u00b6 The example shows how the user buttons T1 and T2 are queried. \"Talkie\" \u00b6 Talkie shows how speech output can be realised with the help of the Talkie library. Talkie is an implementation of the Texas Instruments ICs speech synthesiser on an Arduino board. This IC was very often used in the early 80s. This speech output was often found in expensive clocks, game computers, learning computers and many other devices. The unmistakable sound from the 80's is also available on the Hexapod Robot Board. The examples contain over 1000 prefabricated phrases that can be assembled to sentences. If the voice output is too quiet for you, you can increase the volume at the trimmer \"Vol.\" on the Hexapod Robot Board. In addition, you can build a small \"speaker box\" for the speaker, this increases the volume significantly! A simple small box can do wonders here. \"WriteOUT1\" \u00b6 This example shows how to read and write the IN1 and OUT1 inputs/outputs of the locomotion controller. This gives you an additional input and output to the user board. The pins are directly connected to the locomotion controller and can supply a maximum of 20 mA current. The maximum input voltage for the input is 5 V/DC.","title":"Demo programs"},{"location":"educational-robotics/robobug-hexapod/demo_programs/#demo-programs","text":"To use the user boards easily and comfortably, use the Maker-Factory Hexapod library. This library was already installed at the beginning of this manual. The provided examples show the use of the user boards and the functionality of the Arduino Hexapod library. When using user boards that are not Arduino compatible (like SBC), look at the file \"Hexapod_Lib.h\". This file shows how the communication between the user board and the locomotion controller works. This will serve you as an example for developing your own function library. To do this, unpack the ZIP file \"\\LibraryDemos\\Maker-Factory-Hexapod-Vx.1.zip\" from the download bundle and look at the source code of the library in an editor such as Notepad or a development environment of your choice. Warning The supplied examples are designed for \"Arduino UNO\" and \"NodeMCU\" boards programmed with the Arduino IDE. Figure 78 The Arduino examples show how to use the library. These can be found in the Arduino IDE under \"Examples\\Maker-Factory-Hexapod-Vx.x...\". Take your time to look at all the examples and test them on your Hexapod. Once you have understood the examples, you can start and create your own programmes with them. Take a closer look at the \"Hexapod_Lib.h\". With some experience you can easily extend it with your own functions.","title":"Demo programs"},{"location":"educational-robotics/robobug-hexapod/demo_programs/#short-description-of-the-provided-examples-for-locomotion-todo","text":"In the folder \"Locomotion\" you find the examples for the Locomotion controller (Arduino MEGA2560). LEDs Small test programm that alternately flashes the two LEDs (Users and Live). Motion-Firmware Firmware of the locomotion controller. ServoCenter This program moves the servos to the middle position. As needed for mechanical assembly of the Hexapod robot.","title":"Short description of the provided examples for Locomotion  TODO"},{"location":"educational-robotics/robobug-hexapod/demo_programs/#brief-description-of-the-supplied-examples-for-user-boards","text":"In the folder \"User-Boards\" you will find the examples for Arduino UNO and NodeMCU or compatible boards. Warning Before use, change the Arduino IDE to the correct Arduino board! Also, read the information in the comments to the respective examples! Info The \"Hexapod_Lib.h\" contains all functions that are sent and received from the UserBoard to the Locomotion-Controller. For the advanced developer it is worthwhile to have a look inside or to extend these with proper functions. The functions contain a detailed comment which parameters can be passed. The programme code for receiving the data, sending the data to the UserBoard and evaluating the gamepad can be found in the locomotion firmware in the file \"Data_Input.h\". The \"Hexapod_Lib.h\" can also be downloaded from the product's website.","title":"Brief description of the supplied examples for user boards"},{"location":"educational-robotics/robobug-hexapod/demo_programs/#cardinfo","text":"Info This example is intended only for Arduino UNO or compatible boards! With this example you can check the function of the MicroSD card reader. Insert a MicroSD memory card with arbitrary content into the card slot and start the example. The terminal displays the contents of the memory card (file name). All original Arduino SD card examples work. You only have to change the pin for \"CS\" (Chipselect) as in this example. The terminal baud rate is 19200 baud.","title":"\"CardInfo\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#espmoveap","text":"Info This example is intended for NodeMCU boards only The example shows control via an HTTP server using a direct WiFi connection to the NodeMCU board. The programme sets up an access point with which you can connect to a smartphone, for example. The assigned IP address is displayed in the terminal. Type it into your browser. Then the browser loads the web interface to control the robot. You can then control the robot via WiFi by tapping or clicking the buttons. The example can easily be extended by you into other functionalities. The terminal baud rate is 115200 baud.","title":"\"EspMoveAP\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#espmovewifi","text":"Info This example is intended for NodeMCU boards only The example shows the control via a web browser using a WiFi connection to the NodeMCU board. The programme establishes a connection to your router and the robot is then accessible within your network. The assigned IP address is displayed in the terminal. Type it into your browser. Then the browser loads the web interface to control the robot. You can then control the robot via WiFi by tapping or clicking the buttons. The example can easily be extended by you into other functionalities. The terminal baud rate is 115200 baud.","title":"\"EspMoveWiFi\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#infrared","text":"Info This example is intended only for Arduino UNO or compatible boards! The example reads an RC5 infrared code and outputs the values at the terminal. Plug the Jumper J8 in the direction of the label \"IR-U\". The universal remote control can serve as an IR transmitter set to RC5 (many Philips devices work with RC5), which is available for TV and audio equipment in stores. The terminal baud rate is 19200 baud.","title":"\"Infrared\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#moving_01","text":"This example shows how data is sent to the locomotion controller without the Hexapod library. This example is well suited as a basis for using SBC. However, experience in programming is necessary! Have a closer look at the function SendData(). Here you can see how data is sent from the user board to the locomotion controller. The programme does not make an acknowledgement evaluation, but sends the data only to the locomotion controller without evaluating an answer from the locomotion controller.","title":"\"Moving_01\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#moving_02","text":"This example is ideal for getting started with the programming of user boards and shows the basic functions to control the Hexapod with the help of the library.","title":"\"Moving_02\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#moving_03","text":"This example shows how to use the ROBOT_MOVE() function.","title":"\"Moving_03\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#moving_04","text":"This example shows how to use the ROBOT_ROTATE_MODE() and ROBOT_TRANSLATE_MODE() functions.","title":"\"Moving_04\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#moving_05","text":"This example shows how to use the ROBOT_SINGLE_LEG() function.","title":"\"Moving_05\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#moving_06","text":"This example shows how to interrupt a user programme using the gamepad. In this example, use the terminal to receive the messages from the robot. Set the robot to an elevation so that the legs move in the air without touching the ground. This allows you to observe the output when controlling the robot on the terminal. The terminal baud rate is 115200 baud.","title":"\"Moving_06\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#readgamepad","text":"The example shows how you can read the control data of the gamepad from the locomotion controller. If you plug in the jumper \"J7\", the locomotion controller no longer reacts to the gamepad. It is then possible to use the data only on the user board and to realise your own controls. The terminal baud rate is 115200 baud","title":"\"ReadGamepad\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#readvalues_01","text":"The example shows how you can send and read data between locomotion controller and user board without a library. This example is well suited as a basis for using SBC. However, experience in programming is necessary! The terminal baud rate is 115200 baud.","title":"\"ReadValues_01\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#readvalues_02","text":"This example shows how to read data from the locomotion controller using the library. The terminal baud rate is 115200 baud.","title":"\"ReadValues_02\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#servo","text":"The example shows the use of additional servos which are controlled via the user board. The connectors SU1 to SU3 are used for this purpose. It is also possible to use the connectors SU1 to SU3 for other components such as sensors, buttons, switches, etc. The terminal baud rate is 115200 baud.","title":"\"Servo\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#sound","text":"The example shows a simple sound output via the loudspeaker.","title":"\"Sound\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#switches","text":"The example shows how the user buttons T1 and T2 are queried.","title":"\"Switches\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#talkie","text":"Talkie shows how speech output can be realised with the help of the Talkie library. Talkie is an implementation of the Texas Instruments ICs speech synthesiser on an Arduino board. This IC was very often used in the early 80s. This speech output was often found in expensive clocks, game computers, learning computers and many other devices. The unmistakable sound from the 80's is also available on the Hexapod Robot Board. The examples contain over 1000 prefabricated phrases that can be assembled to sentences. If the voice output is too quiet for you, you can increase the volume at the trimmer \"Vol.\" on the Hexapod Robot Board. In addition, you can build a small \"speaker box\" for the speaker, this increases the volume significantly! A simple small box can do wonders here.","title":"\"Talkie\""},{"location":"educational-robotics/robobug-hexapod/demo_programs/#writeout1","text":"This example shows how to read and write the IN1 and OUT1 inputs/outputs of the locomotion controller. This gives you an additional input and output to the user board. The pins are directly connected to the locomotion controller and can supply a maximum of 20 mA current. The maximum input voltage for the input is 5 V/DC.","title":"\"WriteOUT1\""},{"location":"educational-robotics/robobug-hexapod/explanation_of_symbols/","text":"Explanation of symbols \u00b6 Caution Warning Caution and Warning boxes indicate important instructions in this operating manual which must be adhered to. Info Info boxes indicates information which can be helpful for using the product. \u2192 The arrow symbol indicates specific tips and advice on operation","title":"Explanation of symbols"},{"location":"educational-robotics/robobug-hexapod/explanation_of_symbols/#explanation-of-symbols","text":"Caution Warning Caution and Warning boxes indicate important instructions in this operating manual which must be adhered to. Info Info boxes indicates information which can be helpful for using the product. \u2192 The arrow symbol indicates specific tips and advice on operation","title":"Explanation of symbols"},{"location":"educational-robotics/robobug-hexapod/general_notes/","text":"General notes \u00b6 Take enough time for the assembly. Too much hurry leads often to mistakes which can damage the components or cancel out the time gained by extensive reworking. The workplace should be sufficiently large and clean so that the various components and assemblies can be easily removed and assembled. It is essential that you observe the pictures during assembly. Here the assembly locations and the correct alignment of the components are shown. All mechanical components of the kit are manufactured very precisely. Do not use force during assembly under any circumstances. All parts can be assembled without much effort. If this is not the case, reconsider the assembly step again and read through the corresponding description in this manual again. When tightening the screws, be careful not to tighten them too tightly. This can lead to damage to the plastic parts, loss of warranty/guarantee! The screws are already delivered pre-sorted in small bags. You can already open these before assembly and place them sorted by type on the worktable. This facilitates assembly, as you do not have to search for individual screws. Some screws, nuts and other small parts are included in the scope of delivery in larger quantities than is needed. These serve as a replacement if, for example, a screw or similar is lost during assembly. The Pan & Tilt unit is the head mechanism (see picture 1) and can optionally be printed on a 3D printer. You will find the data for this as a download on the product\u2019s website (as well as all other available downloads). The Locomotion-Controller is located under the loudspeaker. It is responsible for leg control and is programmed via the mini-USB connection. An overview of the board can be found in Chapter 19 in Figure 79.","title":"General notes"},{"location":"educational-robotics/robobug-hexapod/general_notes/#general-notes","text":"Take enough time for the assembly. Too much hurry leads often to mistakes which can damage the components or cancel out the time gained by extensive reworking. The workplace should be sufficiently large and clean so that the various components and assemblies can be easily removed and assembled. It is essential that you observe the pictures during assembly. Here the assembly locations and the correct alignment of the components are shown. All mechanical components of the kit are manufactured very precisely. Do not use force during assembly under any circumstances. All parts can be assembled without much effort. If this is not the case, reconsider the assembly step again and read through the corresponding description in this manual again. When tightening the screws, be careful not to tighten them too tightly. This can lead to damage to the plastic parts, loss of warranty/guarantee! The screws are already delivered pre-sorted in small bags. You can already open these before assembly and place them sorted by type on the worktable. This facilitates assembly, as you do not have to search for individual screws. Some screws, nuts and other small parts are included in the scope of delivery in larger quantities than is needed. These serve as a replacement if, for example, a screw or similar is lost during assembly. The Pan & Tilt unit is the head mechanism (see picture 1) and can optionally be printed on a 3D printer. You will find the data for this as a download on the product\u2019s website (as well as all other available downloads). The Locomotion-Controller is located under the loudspeaker. It is responsible for leg control and is programmed via the mini-USB connection. An overview of the board can be found in Chapter 19 in Figure 79.","title":"General notes"},{"location":"educational-robotics/robobug-hexapod/intended_use/","text":"Intended Use \u00b6 The \"Hexapod Robobug\" complete set is solely designed for training, research and private use in the hobby or model construction area and the operating times associated with it. The product is not a toy and should be kept out of reach of children under 14 years of age. The product is aimed at advanced users who already have experience with Arduino and the programming language C/C ++ and also in electronics as well as in the construction of mechanical kits. The product must not get damp or wet! The electronics are designed for operation at an ambient temperature between 0 \u00b0C and +40 \u00b0C. The electronics are designed for use in a wide range of applications. Observe all the safety instructions in these operating instructions. They contain important information regarding the handling of the product. You are the sole responsible for the safe operation of the Hexapod Robobug complete set! Mechanical components as well as servo motors are subject to natural wear and can wear during long operating times. The servos can be reordered as spare parts. The servo motors have a high cycle stability of up to 100,000 cycles. However, the Robobug is not designed to carry out permanent movements. The motors in the servo require a break of at least 10 minutes after a longer run (about 10 minutes of continuous movement) in order to cool down. This ensures a long service life. If you use the product for other purposes than those described above, the product may be damaged. Moreover, improper use involves risks such as shortcircuits, fire, electric shocks, etc. Please read the operating instructions carefully and do not discard them. Please include these operating instructions when you pass the product on to a third party.","title":"Intended Use"},{"location":"educational-robotics/robobug-hexapod/intended_use/#intended-use","text":"The \"Hexapod Robobug\" complete set is solely designed for training, research and private use in the hobby or model construction area and the operating times associated with it. The product is not a toy and should be kept out of reach of children under 14 years of age. The product is aimed at advanced users who already have experience with Arduino and the programming language C/C ++ and also in electronics as well as in the construction of mechanical kits. The product must not get damp or wet! The electronics are designed for operation at an ambient temperature between 0 \u00b0C and +40 \u00b0C. The electronics are designed for use in a wide range of applications. Observe all the safety instructions in these operating instructions. They contain important information regarding the handling of the product. You are the sole responsible for the safe operation of the Hexapod Robobug complete set! Mechanical components as well as servo motors are subject to natural wear and can wear during long operating times. The servos can be reordered as spare parts. The servo motors have a high cycle stability of up to 100,000 cycles. However, the Robobug is not designed to carry out permanent movements. The motors in the servo require a break of at least 10 minutes after a longer run (about 10 minutes of continuous movement) in order to cool down. This ensures a long service life. If you use the product for other purposes than those described above, the product may be damaged. Moreover, improper use involves risks such as shortcircuits, fire, electric shocks, etc. Please read the operating instructions carefully and do not discard them. Please include these operating instructions when you pass the product on to a third party.","title":"Intended Use"},{"location":"educational-robotics/robobug-hexapod/introduction/","text":"Introduction \u00b6 Dear visitor, thank you for being interested in out product. This product meets the requirements of current European and national guidelines. We kindly request the user to follow the operating instructions to preserve this condition and to ensure safe operation! Info This user manual is part of the product. It contains important information on starting up and handling the device. Bear this in mind if you pass this product to a third party. All names of companies and products are the trademarks of the respective owners. All rights reserved. If there are any technical questions, please contact: Conrad International Conrad United Kingdom","title":"Introduction"},{"location":"educational-robotics/robobug-hexapod/introduction/#introduction","text":"Dear visitor, thank you for being interested in out product. This product meets the requirements of current European and national guidelines. We kindly request the user to follow the operating instructions to preserve this condition and to ensure safe operation! Info This user manual is part of the product. It contains important information on starting up and handling the device. Bear this in mind if you pass this product to a third party. All names of companies and products are the trademarks of the respective owners. All rights reserved. If there are any technical questions, please contact: Conrad International Conrad United Kingdom","title":"Introduction"},{"location":"educational-robotics/robobug-hexapod/package_contents/","text":"Package Contents \u00b6 Hexapod Robobug Mechanical Kit 18x Servos Hexapod Robot Board Gamepad for control Small parts (e.g., jumpers, battery plug XT30) Quick guide Latest Operating Instructions Download the latest operating instructions from Conrad or scan the QR code shown below. Follow the instructions on the website. On the product website you will find all sample programmes, firmware updates and further instructions for extensions.","title":"Package Contents"},{"location":"educational-robotics/robobug-hexapod/package_contents/#package-contents","text":"Hexapod Robobug Mechanical Kit 18x Servos Hexapod Robot Board Gamepad for control Small parts (e.g., jumpers, battery plug XT30) Quick guide Latest Operating Instructions Download the latest operating instructions from Conrad or scan the QR code shown below. Follow the instructions on the website. On the product website you will find all sample programmes, firmware updates and further instructions for extensions.","title":"Package Contents"},{"location":"educational-robotics/robobug-hexapod/pan_tilt_unit/","text":"Pan unit \u00b6 Optionally, an additional servo can be purchased, and the robot can be extended by a pan unit (swivel unit). The complete kit already includes an additional U-holder with accessoires. Sensors or faces, for example. can be mounted on this. Please also have a look at the additional download for the Robobug. In the download area there are various 3D printable files available to expand your robot. The Pan unit is mounted in the same way as the legs are. Figure 81 shows the fully assembled Pan unit on the robot. The servos can then be controllers via a user board, e.g. via the Arduino\u2122 UNO. The servo is connected to one of the pin headers SU1 to SU3. Tilt unit (3D-printable) \u00b6 The 3D models can be printed with a standard FDM 3D printer with a minimum print area of \u200b\u200b60 x 60 x 60 mm and in different combinations for different servos, sensors and head models. The 3D printed part \u201cB1 PanMount\u201d has to be attached to the pan bracket which is already included in the Robobug set. An additional MF-06HEX 6V-Servo drives the pan unit. The Tilt Unit always consists of three parts: 1x PanMount.stl 1x Mount-Servo-xxx (xxx = servo type) 1x Mount-Tilt-xxx-yyy (xxx = name of the application - yyy = servo type) Files \u00b6 The STL-Files can be downloaded here Available components: B1 (Pan Mount) baseFile: PanMount.stl Holder for attaching the tilt unit to the pan unit. B2 (Holder MAKERFACTORY MF-05HEX 6V) ServoFile: Mount Servo MF-05HEX.stl Tilt servo mount for MAKERFACTORY Servo MF-05HEX 6V. B3 (Tilt Unit Maker for Servo MF-05HEX 6V) File: Mount Tilt Maker Short MF-05HEX.stl Tilt unit for MAKERFACTORY Servo MF-05HEX 6V. Short version with universal mounting holes. B4 (Tilt Unit Maker for Servo MF-05HEX 6V) File: Mount-Tilt-Maker-Long-MF-05HEX.stl Tilt unit for MAKERFACTORY Servo MF-05HEX 6V. Long version with universal mounting holes. B5 (JeVois Tilt Unit for servo MF-05HEX 6V) File: Mount-Tilt-JeVois-Camera-MF-05HEX.stl Tilt unit for MAKERFACTORY Servo MF-05HEX 6V. For attaching the JeVois computer vision camera. Link: http://jevois.org Conrad Part Number: 1693282 B6 (Servo Holder HiTec HS81 / 82) File: Mount Servo-HiTec-HS81-82.stl Tilt servo mount for HiTec servo HS81 and HS82. B7 (Servo Holder Reely S3027) File: Mount-Servo-Reely-S3027MG.stl Tilt servo mount for Reely servo S3027. B8 (Tilt Unit Maker for Servo HiTec-HS81 / 82) File: Mount-Tilt-Maker-Short-HiTec-HS81-82.stl Tilt unit for HiTec Servo HS81 and HS82. Short version with universal mounting holes. B9 (Tilt Unit Maker for servo HiTec-HS81 / 82) File: Mount-Tilt-Maker-Long-HiTec-HS81-82.stl Tilt unit for HiTec Servo HS81 and HS82. Long version with universal mounting holes. B10 (JeVois Tilt Unit for servo HiTec-HS81 / 82) File: Mount-Tilt-JeVois-Camera-HiTec-HS81-82.stl Tilt unit for HiTec Servo HS81 and HS82. For attaching the JeVois computer vision camera. Link: http://jevois.org Conrad Part Number: 1693282PixyCam B11 (Tilt Unit for Servo MF-05HEX 6V) File: Mount-Tilt-PixyCam-MF-05HEX.stl Tilt Unit for Maker-Factory Servo MF-05HEX 6V. For attaching the PixyCam computer vision camera. Link: https://pixycam.com PixyCam Conrad Part Number: 1364834PixyCam B12 (Tilt Unit for Servo HiTec-HS81 / 82) File: Mount-Tilt-PixyCam-HiTec-HS81-82.stl Tilt Unit for MAKERFACTORY Servo MF-05HEX 6V. For attaching the PixyCam computer vision camera. Link: https://pixycam.com PixyCam Conrad Part Number: 1364834 B13 (Tilt Unit Pixy2 for Servo HiTec-HS81 / 82) File: Mount-Tilt-Pixy2-HiTec-HS81-82.stl Tilt unit for HiTec Servo HS81 and HS82. For attaching the Pixy2 computer vision camera. Link: https://pixycam.com B14 (Tilt Unit Pixy2 for Servo MF-05HEX 6V) File: Mount-Tilt-Pixy2-MF-05HEX.stl Tilt Unit for Maker-Factory Servo MF-05HEX 6V. For attaching the Pixy2 computer vision camera. Link: https://pixycam.com B15 (Tilt Unit Head for Servo MF-05HEX 6V) File: Mount-Tilt-Ultrasonic-SF04-Mouth-MF-05HEX.stl Head for mounting an HC-SR04 ultrasonic sensor, mouthpiece and a MAKERFACTORY servo MF-05HEX 6V. Ultrasonic sensor: eg Conrad order number 1616245 B16 (Tilt unit head for servo MF-05HEX 6V) File: Mount-Tilt-Ultrasonic-SF04-MF-05HEX.stl Head for mounting an HC-SR04 ultrasonic sensor and a MAKERFACTORY servo MF-05HEX 6V. Without mouth. Ultrasonic sensor: eg Conrad Order number 1616245 B17 (Tilt unit head for servo MF-05HEX 6V) File: Mount-Tilt-Ultrasonic-SF04-Mouth-Nose-MF-05HEX.stl Head for mounting a HC-SR04 ultrasonic sensor, mouth, nose and a MAKERFACTORY servo MF-05HEX 6V. Ultrasonic sensor: eg Conrad Order number 1616245 B18 (Tilt unit head for Servo HiTec-HS81 / 82) File: Mount-Tilt-Ultrasonic-SF04-Mouth-HiTec-HS81-82.stl Head for mounting an HC-SR04 ultrasonic sensor, mouthpiece and a HiTec Servo HS81 or HS82. Ultrasonic sensor: eg Conrad Order number 1616245 B19 (Tilt unit head for Servo HiTec-HS81 / 82) File: Mount-Tilt-Ultrasonic-SF04-HiTec-HS81-82.stl Head for mounting an HC-SR04 ultrasonic sensor and a HiTec Servo HS81 or HS82. Without mouth. Ultrasonic sensor: eg Conrad Order number 1616245 B20 (Tilt unit head for Servo HiTec-HS81 / 82) File: Mount-Tilt-Ultrasonic-SF04-Mouth-Nose-HiTec-HS81-82.stl Head for mounting an HC-SR04 ultrasonic module with mouth and nose. Attached to a HiTec Servo HS81 or HS82. Head for mounting a HC-SR04 ultrasonic sensor, mouth, nose and a HiTec Servo HS81 or HS82. Ultrasonic sensor: eg Conrad Order number 1616245 B21 (accessory) File: Mouth.stl Can be used in combination with the Tilt Unit Head. B22 (accessory) File: Nose-Knop.stl Can be used in combination with the Tilt Unit Head. When printed with transparent filament, a WS2812 LED can be glued behind the nose. Of course, another LED can be used as well. Assembling: \u00b6 Needed mounting material: \u00b6 Servo disks 2x M2x8 2x M2 nut Servo mounting 2x M3x12 2x M3 nut Tilt mounting 1x M3x12 1x M3 nut Pan holder 3x M3x6 3x M3 nut 2x 2.9 x 13mm tapping or plastic screw The RGB LED WS2812 and the ultrasonic sensor HC-SR04 or SR05 can be glued to the mountings and connected to the controller board of the RoboBug. With this unit, you already have a friendly-looking robot with ultrasonic rangefinder, for example to avoid obstacles. The RGB LED could for example display the battery charge level with changing the color from green to red.","title":"Pan & Tilt Unit"},{"location":"educational-robotics/robobug-hexapod/pan_tilt_unit/#pan-unit","text":"Optionally, an additional servo can be purchased, and the robot can be extended by a pan unit (swivel unit). The complete kit already includes an additional U-holder with accessoires. Sensors or faces, for example. can be mounted on this. Please also have a look at the additional download for the Robobug. In the download area there are various 3D printable files available to expand your robot. The Pan unit is mounted in the same way as the legs are. Figure 81 shows the fully assembled Pan unit on the robot. The servos can then be controllers via a user board, e.g. via the Arduino\u2122 UNO. The servo is connected to one of the pin headers SU1 to SU3.","title":"Pan unit"},{"location":"educational-robotics/robobug-hexapod/pan_tilt_unit/#tilt-unit-3d-printable","text":"The 3D models can be printed with a standard FDM 3D printer with a minimum print area of \u200b\u200b60 x 60 x 60 mm and in different combinations for different servos, sensors and head models. The 3D printed part \u201cB1 PanMount\u201d has to be attached to the pan bracket which is already included in the Robobug set. An additional MF-06HEX 6V-Servo drives the pan unit. The Tilt Unit always consists of three parts: 1x PanMount.stl 1x Mount-Servo-xxx (xxx = servo type) 1x Mount-Tilt-xxx-yyy (xxx = name of the application - yyy = servo type)","title":"Tilt unit (3D-printable)"},{"location":"educational-robotics/robobug-hexapod/pan_tilt_unit/#files","text":"The STL-Files can be downloaded here Available components: B1 (Pan Mount) baseFile: PanMount.stl Holder for attaching the tilt unit to the pan unit. B2 (Holder MAKERFACTORY MF-05HEX 6V) ServoFile: Mount Servo MF-05HEX.stl Tilt servo mount for MAKERFACTORY Servo MF-05HEX 6V. B3 (Tilt Unit Maker for Servo MF-05HEX 6V) File: Mount Tilt Maker Short MF-05HEX.stl Tilt unit for MAKERFACTORY Servo MF-05HEX 6V. Short version with universal mounting holes. B4 (Tilt Unit Maker for Servo MF-05HEX 6V) File: Mount-Tilt-Maker-Long-MF-05HEX.stl Tilt unit for MAKERFACTORY Servo MF-05HEX 6V. Long version with universal mounting holes. B5 (JeVois Tilt Unit for servo MF-05HEX 6V) File: Mount-Tilt-JeVois-Camera-MF-05HEX.stl Tilt unit for MAKERFACTORY Servo MF-05HEX 6V. For attaching the JeVois computer vision camera. Link: http://jevois.org Conrad Part Number: 1693282 B6 (Servo Holder HiTec HS81 / 82) File: Mount Servo-HiTec-HS81-82.stl Tilt servo mount for HiTec servo HS81 and HS82. B7 (Servo Holder Reely S3027) File: Mount-Servo-Reely-S3027MG.stl Tilt servo mount for Reely servo S3027. B8 (Tilt Unit Maker for Servo HiTec-HS81 / 82) File: Mount-Tilt-Maker-Short-HiTec-HS81-82.stl Tilt unit for HiTec Servo HS81 and HS82. Short version with universal mounting holes. B9 (Tilt Unit Maker for servo HiTec-HS81 / 82) File: Mount-Tilt-Maker-Long-HiTec-HS81-82.stl Tilt unit for HiTec Servo HS81 and HS82. Long version with universal mounting holes. B10 (JeVois Tilt Unit for servo HiTec-HS81 / 82) File: Mount-Tilt-JeVois-Camera-HiTec-HS81-82.stl Tilt unit for HiTec Servo HS81 and HS82. For attaching the JeVois computer vision camera. Link: http://jevois.org Conrad Part Number: 1693282PixyCam B11 (Tilt Unit for Servo MF-05HEX 6V) File: Mount-Tilt-PixyCam-MF-05HEX.stl Tilt Unit for Maker-Factory Servo MF-05HEX 6V. For attaching the PixyCam computer vision camera. Link: https://pixycam.com PixyCam Conrad Part Number: 1364834PixyCam B12 (Tilt Unit for Servo HiTec-HS81 / 82) File: Mount-Tilt-PixyCam-HiTec-HS81-82.stl Tilt Unit for MAKERFACTORY Servo MF-05HEX 6V. For attaching the PixyCam computer vision camera. Link: https://pixycam.com PixyCam Conrad Part Number: 1364834 B13 (Tilt Unit Pixy2 for Servo HiTec-HS81 / 82) File: Mount-Tilt-Pixy2-HiTec-HS81-82.stl Tilt unit for HiTec Servo HS81 and HS82. For attaching the Pixy2 computer vision camera. Link: https://pixycam.com B14 (Tilt Unit Pixy2 for Servo MF-05HEX 6V) File: Mount-Tilt-Pixy2-MF-05HEX.stl Tilt Unit for Maker-Factory Servo MF-05HEX 6V. For attaching the Pixy2 computer vision camera. Link: https://pixycam.com B15 (Tilt Unit Head for Servo MF-05HEX 6V) File: Mount-Tilt-Ultrasonic-SF04-Mouth-MF-05HEX.stl Head for mounting an HC-SR04 ultrasonic sensor, mouthpiece and a MAKERFACTORY servo MF-05HEX 6V. Ultrasonic sensor: eg Conrad order number 1616245 B16 (Tilt unit head for servo MF-05HEX 6V) File: Mount-Tilt-Ultrasonic-SF04-MF-05HEX.stl Head for mounting an HC-SR04 ultrasonic sensor and a MAKERFACTORY servo MF-05HEX 6V. Without mouth. Ultrasonic sensor: eg Conrad Order number 1616245 B17 (Tilt unit head for servo MF-05HEX 6V) File: Mount-Tilt-Ultrasonic-SF04-Mouth-Nose-MF-05HEX.stl Head for mounting a HC-SR04 ultrasonic sensor, mouth, nose and a MAKERFACTORY servo MF-05HEX 6V. Ultrasonic sensor: eg Conrad Order number 1616245 B18 (Tilt unit head for Servo HiTec-HS81 / 82) File: Mount-Tilt-Ultrasonic-SF04-Mouth-HiTec-HS81-82.stl Head for mounting an HC-SR04 ultrasonic sensor, mouthpiece and a HiTec Servo HS81 or HS82. Ultrasonic sensor: eg Conrad Order number 1616245 B19 (Tilt unit head for Servo HiTec-HS81 / 82) File: Mount-Tilt-Ultrasonic-SF04-HiTec-HS81-82.stl Head for mounting an HC-SR04 ultrasonic sensor and a HiTec Servo HS81 or HS82. Without mouth. Ultrasonic sensor: eg Conrad Order number 1616245 B20 (Tilt unit head for Servo HiTec-HS81 / 82) File: Mount-Tilt-Ultrasonic-SF04-Mouth-Nose-HiTec-HS81-82.stl Head for mounting an HC-SR04 ultrasonic module with mouth and nose. Attached to a HiTec Servo HS81 or HS82. Head for mounting a HC-SR04 ultrasonic sensor, mouth, nose and a HiTec Servo HS81 or HS82. Ultrasonic sensor: eg Conrad Order number 1616245 B21 (accessory) File: Mouth.stl Can be used in combination with the Tilt Unit Head. B22 (accessory) File: Nose-Knop.stl Can be used in combination with the Tilt Unit Head. When printed with transparent filament, a WS2812 LED can be glued behind the nose. Of course, another LED can be used as well.","title":"Files"},{"location":"educational-robotics/robobug-hexapod/pan_tilt_unit/#assembling","text":"","title":"Assembling:"},{"location":"educational-robotics/robobug-hexapod/pan_tilt_unit/#needed-mounting-material","text":"Servo disks 2x M2x8 2x M2 nut Servo mounting 2x M3x12 2x M3 nut Tilt mounting 1x M3x12 1x M3 nut Pan holder 3x M3x6 3x M3 nut 2x 2.9 x 13mm tapping or plastic screw The RGB LED WS2812 and the ultrasonic sensor HC-SR04 or SR05 can be glued to the mountings and connected to the controller board of the RoboBug. With this unit, you already have a friendly-looking robot with ultrasonic rangefinder, for example to avoid obstacles. The RGB LED could for example display the battery charge level with changing the color from green to red.","title":"Needed mounting material:"},{"location":"educational-robotics/robobug-hexapod/pin_assignment_of_the_user_board/","text":"Pin assignment of the user board \u00b6 Locomotion Controller (ATmega2560) \u00b6 Port Arduino S0 PB6 12 S1 PE3 5 S2 PE4 2 S3 PE5 3 S4 PH0 17 S5 PH1 16 S6 PH3 6 S7 PH4 7 S8 PH5 8 S9 PA3 25 S10 PA4 26 S11 PA5 27 S12 PC4 33 S13 PC3 34 S14 PC2 35 S15 PC1 36 S16 PC0 37 S17 PG1 40 SA0 PF0 A0 SA1 PF1 A1 SA2 PF2 A2 SA3 PF4 A4 SA4 PF5 A5 SA5 PF6 A6 PS2_DAT PA6 28 PS2_CMD PC7 30 PS2_SEL PC5 32 PS2_CLK PC6 31 IR PJ0 15 UB-MESS PF3 A3 SOUND PL3 46 Jumper J7 PG5 4 IN1 PA2 24 OUT1 PA1 24 RxD-U PD2/RxD1 Serial1 TxD-U PD3/TxD1 Serial1 LIVE-LED PA0 22 USER-LED PK7 69 Arduino user board \u00b6 Port Arduino T1 ADC2 A2 T2 ADC3 A3 SCK PB5 13 MISO PB4 12 MOSI PB3 11 SS_SD PB0 8 PA PD3 3 IR-DAT PD7 7 SU1 PD6 6 SU2 PD5 5 SU3 PB1 9 RxD_U PD4 4 TxD_U PD2 2 NodeMCU user board \u00b6 Port Arduino T1 10 T2 ADC3 A0 PA D5 GPIO14 SU1 D6 GPIO12 SU2 D7 GPIO13 SU3 D8 GPIO15 RxD_U D3 GPIO0 TxD_U D4 GPIO2","title":"Pin assignment of the user board"},{"location":"educational-robotics/robobug-hexapod/pin_assignment_of_the_user_board/#pin-assignment-of-the-user-board","text":"","title":"Pin assignment of the user board"},{"location":"educational-robotics/robobug-hexapod/pin_assignment_of_the_user_board/#locomotion-controller-atmega2560","text":"Port Arduino S0 PB6 12 S1 PE3 5 S2 PE4 2 S3 PE5 3 S4 PH0 17 S5 PH1 16 S6 PH3 6 S7 PH4 7 S8 PH5 8 S9 PA3 25 S10 PA4 26 S11 PA5 27 S12 PC4 33 S13 PC3 34 S14 PC2 35 S15 PC1 36 S16 PC0 37 S17 PG1 40 SA0 PF0 A0 SA1 PF1 A1 SA2 PF2 A2 SA3 PF4 A4 SA4 PF5 A5 SA5 PF6 A6 PS2_DAT PA6 28 PS2_CMD PC7 30 PS2_SEL PC5 32 PS2_CLK PC6 31 IR PJ0 15 UB-MESS PF3 A3 SOUND PL3 46 Jumper J7 PG5 4 IN1 PA2 24 OUT1 PA1 24 RxD-U PD2/RxD1 Serial1 TxD-U PD3/TxD1 Serial1 LIVE-LED PA0 22 USER-LED PK7 69","title":"Locomotion Controller (ATmega2560)"},{"location":"educational-robotics/robobug-hexapod/pin_assignment_of_the_user_board/#arduino-user-board","text":"Port Arduino T1 ADC2 A2 T2 ADC3 A3 SCK PB5 13 MISO PB4 12 MOSI PB3 11 SS_SD PB0 8 PA PD3 3 IR-DAT PD7 7 SU1 PD6 6 SU2 PD5 5 SU3 PB1 9 RxD_U PD4 4 TxD_U PD2 2","title":"Arduino user board"},{"location":"educational-robotics/robobug-hexapod/pin_assignment_of_the_user_board/#nodemcu-user-board","text":"Port Arduino T1 10 T2 ADC3 A0 PA D5 GPIO14 SU1 D6 GPIO12 SU2 D7 GPIO13 SU3 D8 GPIO15 RxD_U D3 GPIO0 TxD_U D4 GPIO2","title":"NodeMCU user board"},{"location":"educational-robotics/robobug-hexapod/preparatory-work/","text":"Preparatory work \u00b6 \u2192 Before the robot is assembled, some parts are prepared. This makes the actual assembly easier and faster. Application of the screw locking lacquer \u00b6 In the following instructions, some screws should optionally be secured with a screw lock. This pointed out accordingly in the text. We recommend that you only apply the screw lock after the robot has been completely assembled and calibrated. Afterwards the screws to be secured are remlved again and provided with safety laquer. When assembling and calibrating the legs, it might be necessary to loosen them againe for adjustment tasks. Figure 2 Figure 3 The easiest way to apply the screw lock adhesive is to apply a lager drop of the screw lock onto a base (e.g., screw set). With the help of a toothpick or a small screwdriver, the screw lock can be proportionally applied to the thread. Do not use too much screw lock, a small drop is sufficient. Ball bearings and cylindrical pins \u00b6 The leg servos are additionally stabilised by ball bearings with pressed-in cylindrical pins. This significantly reduces the mechanical load on the servos and significantly increases the service life of the servos. The ball bearings are supplied pre-assembled. If a pin is pushed out of the ball bearing during assembly, it can be pushed back again. If the pin is no longer firmly seated in the ball bearing, you can solve the problem with a small trick. Notch the pin at the point where it sits in the ball bearing with a side cutter, see picture 4. Figure 4 Then push the pin back into the ball bearing (if necessary, carefully knock it in with a small hammer). Figure 5 shows the ball bearing with the cylindrical pin. Figure 5 \u2192 Brown marks on the ball bearing are not rust! They represent grease and glue, which are used with the assembly of the two components in the manufacturing. You can remove these residues simply with alcohol (spirit). Power Supply \u00b6 In assembling the Robobug you will need the battery for the power supply, in order to be able to move the leg servos in the middle position, to align the legs and later to install the firmware, which is responsible for running the robot in the next work steps. For all this work, the Robobug needs a power supply. The right power supply is crucial for the safe and trouble-free operation of the Robobug. The Robobug is designed for a NiMH battery with 5 cells and a capacity between 3500 - 5000 mAh. We recommend using the optionally available rechargeable battery. This can be used directly with the Robobug without soldering. Prepare your own battery The \"Hexapod Robobug\" complete set comes with a type XT30 battery plug. This is soldered to the battery selected by you. The cable length between battery and plug must not exceed 20 cm! For the connection cable, we recommend using a highly flexible silicone cable with a cross-section of between 2 and 2.5 mm\u00b2. Pay attention to the polarity (plus/+ and minus/-), and that no short circuit is caused by soldering. In the event of a short-circuit, rechargeable batteries can emit a lot of current, which can lead to burns and fire damage as well as to dangerous injuries. An explosion of the battery is also possible! The ready-made battery is provided with a battery shrink tube. This way the battery looks clean at the end of the soldering work and indicates that there is no danger of a short circuit. In figure 7 you can see how the battery is plugged into the Robobug. The plug is protected against reverse polarity and cannot therefore be plugged in the wrong way. Caution In the event of a short-circuit, rechargeable batteries can emit a lot of current, which can lead to burns and fire damage as well as to dangerous injuries. An explosion of the battery is also possible! The ready-made battery is provided with a battery shrink tube. This way the battery looks clean at the end of the soldering work and indicates that there is no danger of a short circuit. In figure 7 you can see how the battery is plugged into the Robobug. The plug is protected against reverse polarity and cannot therefore be plugged in the wrong way. Figure 6 Figure 7 Installation of the software and firmware \u00b6 The software packages, firmware and tools required for the \"Hexapod Robobug\" are available online as a download package. This package is updated and extended regularly. Please check occasionally whether a new version or useful extensions are available. Open your web browser and navigate either via our shop website to the product page of the \"Hexapod Robobug\" complete set, or visit our download centre . directly. Here you can download the package \"001664151-up-01-en-DOWNLOAD_BUNDLE_Vx_x\" (x_x is the version of the package). The highest version number corresponds to the latest version! Unpack the downloaded ZIP file on your hard disk. Here is a short explanation of the included folders: \u00b6 \"Arduino\" Here is a text file with the download link for the software Arduino\u2122 IDE included. This is needed, for example, to install the firmware without an updater. \"Datasheets\" Data sheets and sketches \"Driver\" Driver for the FTDI USB chip \"Library demos\" Contains the Arduino library, demo's and the Locomotion firmware as a ZIP file. Will be installed in the Arduino IDE. \"Schematic\" Schematic of the Hexapod Robot Board as PDF file \"Terminal\" Calibration software for setting the Hexapod","title":"Preparatory work"},{"location":"educational-robotics/robobug-hexapod/preparatory-work/#preparatory-work","text":"\u2192 Before the robot is assembled, some parts are prepared. This makes the actual assembly easier and faster.","title":"Preparatory work"},{"location":"educational-robotics/robobug-hexapod/preparatory-work/#application-of-the-screw-locking-lacquer","text":"In the following instructions, some screws should optionally be secured with a screw lock. This pointed out accordingly in the text. We recommend that you only apply the screw lock after the robot has been completely assembled and calibrated. Afterwards the screws to be secured are remlved again and provided with safety laquer. When assembling and calibrating the legs, it might be necessary to loosen them againe for adjustment tasks. Figure 2 Figure 3 The easiest way to apply the screw lock adhesive is to apply a lager drop of the screw lock onto a base (e.g., screw set). With the help of a toothpick or a small screwdriver, the screw lock can be proportionally applied to the thread. Do not use too much screw lock, a small drop is sufficient.","title":"Application of the screw locking lacquer"},{"location":"educational-robotics/robobug-hexapod/preparatory-work/#ball-bearings-and-cylindrical-pins","text":"The leg servos are additionally stabilised by ball bearings with pressed-in cylindrical pins. This significantly reduces the mechanical load on the servos and significantly increases the service life of the servos. The ball bearings are supplied pre-assembled. If a pin is pushed out of the ball bearing during assembly, it can be pushed back again. If the pin is no longer firmly seated in the ball bearing, you can solve the problem with a small trick. Notch the pin at the point where it sits in the ball bearing with a side cutter, see picture 4. Figure 4 Then push the pin back into the ball bearing (if necessary, carefully knock it in with a small hammer). Figure 5 shows the ball bearing with the cylindrical pin. Figure 5 \u2192 Brown marks on the ball bearing are not rust! They represent grease and glue, which are used with the assembly of the two components in the manufacturing. You can remove these residues simply with alcohol (spirit).","title":"Ball bearings and cylindrical pins"},{"location":"educational-robotics/robobug-hexapod/preparatory-work/#power-supply","text":"In assembling the Robobug you will need the battery for the power supply, in order to be able to move the leg servos in the middle position, to align the legs and later to install the firmware, which is responsible for running the robot in the next work steps. For all this work, the Robobug needs a power supply. The right power supply is crucial for the safe and trouble-free operation of the Robobug. The Robobug is designed for a NiMH battery with 5 cells and a capacity between 3500 - 5000 mAh. We recommend using the optionally available rechargeable battery. This can be used directly with the Robobug without soldering. Prepare your own battery The \"Hexapod Robobug\" complete set comes with a type XT30 battery plug. This is soldered to the battery selected by you. The cable length between battery and plug must not exceed 20 cm! For the connection cable, we recommend using a highly flexible silicone cable with a cross-section of between 2 and 2.5 mm\u00b2. Pay attention to the polarity (plus/+ and minus/-), and that no short circuit is caused by soldering. In the event of a short-circuit, rechargeable batteries can emit a lot of current, which can lead to burns and fire damage as well as to dangerous injuries. An explosion of the battery is also possible! The ready-made battery is provided with a battery shrink tube. This way the battery looks clean at the end of the soldering work and indicates that there is no danger of a short circuit. In figure 7 you can see how the battery is plugged into the Robobug. The plug is protected against reverse polarity and cannot therefore be plugged in the wrong way. Caution In the event of a short-circuit, rechargeable batteries can emit a lot of current, which can lead to burns and fire damage as well as to dangerous injuries. An explosion of the battery is also possible! The ready-made battery is provided with a battery shrink tube. This way the battery looks clean at the end of the soldering work and indicates that there is no danger of a short circuit. In figure 7 you can see how the battery is plugged into the Robobug. The plug is protected against reverse polarity and cannot therefore be plugged in the wrong way. Figure 6 Figure 7","title":"Power Supply"},{"location":"educational-robotics/robobug-hexapod/preparatory-work/#installation-of-the-software-and-firmware","text":"The software packages, firmware and tools required for the \"Hexapod Robobug\" are available online as a download package. This package is updated and extended regularly. Please check occasionally whether a new version or useful extensions are available. Open your web browser and navigate either via our shop website to the product page of the \"Hexapod Robobug\" complete set, or visit our download centre . directly. Here you can download the package \"001664151-up-01-en-DOWNLOAD_BUNDLE_Vx_x\" (x_x is the version of the package). The highest version number corresponds to the latest version! Unpack the downloaded ZIP file on your hard disk.","title":"Installation of the software and firmware"},{"location":"educational-robotics/robobug-hexapod/preparatory-work/#here-is-a-short-explanation-of-the-included-folders","text":"\"Arduino\" Here is a text file with the download link for the software Arduino\u2122 IDE included. This is needed, for example, to install the firmware without an updater. \"Datasheets\" Data sheets and sketches \"Driver\" Driver for the FTDI USB chip \"Library demos\" Contains the Arduino library, demo's and the Locomotion firmware as a ZIP file. Will be installed in the Arduino IDE. \"Schematic\" Schematic of the Hexapod Robot Board as PDF file \"Terminal\" Calibration software for setting the Hexapod","title":"Here is a short explanation of the included folders:"},{"location":"educational-robotics/robobug-hexapod/preparing-the-leg-servos/","text":"Preparing the leg servos \u00b6 Before you install the leg servos, you must move them to the centre position. This means moving the servos to the mechanical middle position using the Hexapod Robot Board and the \"ServoCenter\" program. This is the starting position for assembly. First unpack all 18 servos; then straighten all connecting cables. Pin assignment: Labelling in Figure 15 Function Imprints on PCB P Control pulse SIG + Positive pole/+ BAT - Negative pole/- GND Figure 15 To set the leg servos, transfer the \"ServoCenter\" programme (located in the \"Locomotion\" directory) to the Hexapod Robot Board. The programme automatically moves the servos from \"S0\" to \"S17\" to the middle position. Connect the servos to the pin headers as shown in the figure (pay attention to the polarity!). All servo connections (S0 to S17) of the robot board are controlled with a pulse width of 1500 \u03bcs. At this point you do not have to connect all 18 servos to the Hexapod Robot Board at the same time. In practice, it has proven to be much easier and faster to use only one connection (e.g., S0) and then move one servo after the other to the middle position. The brown wire of the servo cable points to the edge of the board. The board is also labelled SIG (pulse), BAT+ (+), GND (-). \u2192 The battery must be connected for this procedure! Figure 16 Figure 17 Figure 17 shows the pin headers to which the servos are connected. \u2192 The pin strips labelled SA0 to SA5 do not carry a control signal. This connection remains unassigned and can later be used for proper extensions such as leg contact sensors. The joint details are given anatomically in Latin and have the following meaning: Coxa = hip Femur = thigh Tiba = leg The connections are also indicated in Figure 17 with the leg name as an abbreviation: RR = Right rear leg (\"Right Rear\") RM = Right Middle leg (\"Right Middle\") RF = Right front leg (\"Right Front\") LR = Left rear leg (\"Left Rear\") LM = Left middle leg (\"Left Middle\") LF = Left front leg (\"Left Front\") \u2192 Leave the programme on the Hexapod Robot Board until the robot is completely assembled. If you accidentally twist a servo mechanically during assembly, you can plug it in again and align it. If the servo is turned from the middle position during installation, this has a negative effect on the running characteristics. This can also damage the servo and the mechanics. Disconnect the robot board from the power supply in case you won't be using it for a long time to avoid accidental short circuits Functional description of a servo Servos have electronics, a motor and a potentiometer. The potentiometer picks up the mechanical position of the servo and forwards it to the servo electronics. The electronics in the servo compares the given position (nominal value, in our case the pulse width given by the locomotion controller) with the pulse width of the servo electronics (set via the potentiometer, actual value). If there is a difference between the two pulse widths, the servo electronics regulates the motor to the target position. The graphic illustrates the pulse/pause ratio required to control a servo. In this case, the pulse has a length of 1.5 ms = 1500 \u03bcs, which corresponds to the centre position of the servo. A servo receives as control signal a positive pulse with a pulse width between 500 \u03bcs (0.5 ms) and 2500 \u03bcs (2.5 ms). The total period duration of the control signal is 20 ms. When the servo is in the middle position, the pulse width is 1500 \u03bcs (1.5 ms). If the pulse width is less than 1.5 ms, the servo rotates in one direction. If the pulse width is greater than 1.5 ms, it rotates in the other direction. The angle of rotation is proportional to the pulse width, i.e. the longer or shorter the pulse, the more or less the servo rotates in the corresponding direction. Figure 18","title":"Preparing the leg servos"},{"location":"educational-robotics/robobug-hexapod/preparing-the-leg-servos/#preparing-the-leg-servos","text":"Before you install the leg servos, you must move them to the centre position. This means moving the servos to the mechanical middle position using the Hexapod Robot Board and the \"ServoCenter\" program. This is the starting position for assembly. First unpack all 18 servos; then straighten all connecting cables. Pin assignment: Labelling in Figure 15 Function Imprints on PCB P Control pulse SIG + Positive pole/+ BAT - Negative pole/- GND Figure 15 To set the leg servos, transfer the \"ServoCenter\" programme (located in the \"Locomotion\" directory) to the Hexapod Robot Board. The programme automatically moves the servos from \"S0\" to \"S17\" to the middle position. Connect the servos to the pin headers as shown in the figure (pay attention to the polarity!). All servo connections (S0 to S17) of the robot board are controlled with a pulse width of 1500 \u03bcs. At this point you do not have to connect all 18 servos to the Hexapod Robot Board at the same time. In practice, it has proven to be much easier and faster to use only one connection (e.g., S0) and then move one servo after the other to the middle position. The brown wire of the servo cable points to the edge of the board. The board is also labelled SIG (pulse), BAT+ (+), GND (-). \u2192 The battery must be connected for this procedure! Figure 16 Figure 17 Figure 17 shows the pin headers to which the servos are connected. \u2192 The pin strips labelled SA0 to SA5 do not carry a control signal. This connection remains unassigned and can later be used for proper extensions such as leg contact sensors. The joint details are given anatomically in Latin and have the following meaning: Coxa = hip Femur = thigh Tiba = leg The connections are also indicated in Figure 17 with the leg name as an abbreviation: RR = Right rear leg (\"Right Rear\") RM = Right Middle leg (\"Right Middle\") RF = Right front leg (\"Right Front\") LR = Left rear leg (\"Left Rear\") LM = Left middle leg (\"Left Middle\") LF = Left front leg (\"Left Front\") \u2192 Leave the programme on the Hexapod Robot Board until the robot is completely assembled. If you accidentally twist a servo mechanically during assembly, you can plug it in again and align it. If the servo is turned from the middle position during installation, this has a negative effect on the running characteristics. This can also damage the servo and the mechanics. Disconnect the robot board from the power supply in case you won't be using it for a long time to avoid accidental short circuits Functional description of a servo Servos have electronics, a motor and a potentiometer. The potentiometer picks up the mechanical position of the servo and forwards it to the servo electronics. The electronics in the servo compares the given position (nominal value, in our case the pulse width given by the locomotion controller) with the pulse width of the servo electronics (set via the potentiometer, actual value). If there is a difference between the two pulse widths, the servo electronics regulates the motor to the target position. The graphic illustrates the pulse/pause ratio required to control a servo. In this case, the pulse has a length of 1.5 ms = 1500 \u03bcs, which corresponds to the centre position of the servo. A servo receives as control signal a positive pulse with a pulse width between 500 \u03bcs (0.5 ms) and 2500 \u03bcs (2.5 ms). The total period duration of the control signal is 20 ms. When the servo is in the middle position, the pulse width is 1500 \u03bcs (1.5 ms). If the pulse width is less than 1.5 ms, the servo rotates in one direction. If the pulse width is greater than 1.5 ms, it rotates in the other direction. The angle of rotation is proportional to the pulse width, i.e. the longer or shorter the pulse, the more or less the servo rotates in the corresponding direction. Figure 18","title":"Preparing the leg servos"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/","text":"Avoid obstacles with an ultrasonic sensor \u00b6 Requirements: \u00b6 Fully assembled Pan & Tilt Unit Arduino UNO (or similar) Ultrasonic Sensor Module (eg 1616245) RGB-LED WS2812 Schematic: \u00b6 Figure S1 RGB-LED WS2812 \u00b6 DIN \u2192 9 DOUT \u2192 empty VSS(VCC): \u2192 5V VDD(GND): \u2192 GND HC-SR04 \u00b6 Trig \u2192 A0 Echo \u2192 A1 VCC \u2192 5V GND \u2192 GND Funcions: \u00b6 Description: \u00b6 The demo shows how the MAKERFACTORY Robobug can start walking automatically and avoid obstacles with help of an ultrasonic sensor HC-SR04. Plug in: \u00b6 After plugging in the power supply, the Robobug gives a melody and waits for the start signal. Start: \u00b6 Press the button T1 on the locomotion controller board. The Robobug gets up on its feet and starts walking in a straight direction. Measuring: \u00b6 The head turns frequently from left to right, so the ultrasonic sensor continuously measures the distance to all obstacles in a range of 60\u00b0 (30\u00b0 left and 30\u00b0 right) and the RGB LED blinks in blue and green. Detect obstacle with distance < 60cm: \u00b6 The RGB LED turns red and the Robobug turns around until there is no other obstacle nearer than 90cm. Detect obstacle with distance < 30cm: \u00b6 The RGB LED turns red and the Robobug walks backwards (=escape behavior). After that, it turns around until there is no other obstacle nearer than 90cm. Parameters: \u00b6 PARAMETER Description Default SERVO_TILT_PIN Servo Tilt Pin SU1 SERVO_PAN_PIN Servo Pan Pin SU2 WS2812_PIN RGB-LED-Pin SU3 (PIN 9) SR04_TRG_PIN Ultrasonic Trigger Pin A0 SR04_ECHO_PIN Ultrasonic Echo Pin A1 PAN_CENTER Lower value \u21d2 head goes left 100 TILT_CENTER Lower value \u21d2 head goes up 95 PAN_SCANDEG Scan Degree (Degrees from center) 30 COLLISION_THRESH Threshold for obstacles to turn 60 COLLISION_THRESH_FREE Threshold for obstacles to escape 30 BASIC_DELAY Basic delay to move backwards 1500 MIN_RND_DELAY Min random delay to move backw. 500 MAX_RND_DELAY Max random delay to move backw. 2000 MOVE_SPEED Basic movement speed 20 Code: \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 /****************************************************************** Created with PROGRAMINO IDE for Arduino Project : MAKERFACTORY Ultrasonic Demo (Snoopy Logic) Author : UlliS Description : The demo shows how the MAKERFACTORY can avoid obstacles with the Pan & Tilt unit and an ultrasonic sensor HC-SR04. Userboard is ARDUINO UNO --------------------------- - IR Daten 7 - SU1 6 Pan - SU2 5 Tilt - SU3 9 +/- WS2812 - A0 US Trigger - A1 US Echo - A4 free - A5 free - 10 free ******************************************************************/ #include <Adafruit_NeoPixel.h> // https://github.com/adafruit/Adafruit_NeoPixel #ifdef __AVR__ #include <avr/power.h> #endif #include <Servo.h> // Arduino #define ARDUINO #include <Hexapod_Lib.h> /****************************************************************************** WS2812 RGB-LED ******************************************************************************/ // WS2812/13 (Neopixel) smart RGB LED #define WS2812_PIN SU3 // Parameter 1 = number of pixels in strip // Parameter 2 = Arduino pin number (most are valid) // Parameter 3 = pixel type flags, add together as needed: // NEO_KHZ800 800 KHz bitstream (most NeoPixel products w/WS2812 LEDs) // NEO_KHZ400 400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers) // NEO_GRB Pixels are wired for GRB bitstream (most NeoPixel products) // NEO_RGB Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2) // NEO_RGBW Pixels are wired for RGBW bitstream (NeoPixel RGBW products) Adafruit_NeoPixel pixel = Adafruit_NeoPixel ( 1 , WS2812_PIN , NEO_GRB + NEO_KHZ800 ); /****************************************************************************** HC-SR04 ULTRASONIC SENSOR ******************************************************************************/ // pins for ultrasonic sensor #define SR04_TRG_PIN A0 #define SR04_ECHO_PIN A1 /****************************************************************************** SERVO PAN & TILT ******************************************************************************/ // declare your servo as an object #define SERVO_PAN_PIN SU2 #define SERVO_TILT_PIN SU1 Servo servo_pan ; Servo servo_tilt ; #define PAN_CENTER 100 // lower value scanner more left #define TILT_CENTER 95 // lower value scanner more up #define PAN_SCANDEG 30 #define PAN_LEFTMAX (PAN_CENTER - PAN_SCANDEG) #define PAN_RIGHTMAX (PAN_CENTER + PAN_SCANDEG) #define COLLISION_THRESH 60 // threshold for obstacles (in cm) #define COLLISION_THRESH_FREE 30 // threshold for obstacles + cm #define BASIC_DELAY 1500 #define MIN_RND_DELAY 500 #define MAX_RND_DELAY 2000 #define MOVE_SPEED 20 int pos = 0 ; /****************************************************************************** SETUP ******************************************************************************/ void setup () { // WS2812 RGB-LED pixel . begin (); // this initializes the NeoPixel library. WS2812_SET_RGB ( 255 , 255 , 255 ); // high-Z for the audio output pinMode ( PA_PIN , INPUT ); digitalWrite ( PA_PIN , LOW ); // switches T1 and T2 pinMode ( T1 , INPUT ); pinMode ( T2 , INPUT ); // HC-SR04 pinMode ( SR04_TRG_PIN , OUTPUT ); pinMode ( SR04_ECHO_PIN , INPUT ); // open serial communications and wait for port to open: Serial . begin ( SERIAL_STD_BAUD ); while ( ! Serial ); // set the data rate for the SoftwareSerial port (User-Board to Locomotion-Controller) SERIAL_CMD . begin ( SERIAL_CMD_BAUD ); // reset the Locomotion-Controller ROBOT_RESET (); delay ( 250 ); ROBOT_RESET (); delay ( 150 ); ROBOT_RESET (); // wait for Boot-Up delay ( 1500 ); ROBOT_INIT (); // pan & tilt servos servo_pan . attach ( SERVO_PAN_PIN ); servo_tilt . attach ( SERVO_TILT_PIN ); servo_pan . write ( PAN_CENTER ); servo_tilt . write ( TILT_CENTER ); // rnd init randomSeed ( analogRead ( 0 )); // RBG LED for ( int i = 0 ; i < 765 ; i ++ ) { WS2812_ColorSweep ( i ); delay ( 5 ); } WS2812_SET_RGB ( 0 , 255 , 0 ); // green // print a hello world over the USB connection Serial . println ( \"> Hello here is the MAKERFACTORY Robobug\" ); } /****************************************************************************** MAIN LOOP ******************************************************************************/ void loop () { // start demo if ( ! digitalRead ( T1 )) { delay ( 50 ); if ( ! digitalRead ( T1 )) { MSound ( 1 , 100 , 1000 ); move_init (); // turn center to left (soft start up) for ( pos = PAN_CENTER ; pos >= PAN_LEFTMAX ; pos -= 1 ) { // in steps of 1 degree servo_pan . write ( pos ); delay ( 20 ); } while ( 1 ) { // forward move_fwd ( 100 ); // scanner turn to full right for ( pos = PAN_LEFTMAX ; pos <= PAN_RIGHTMAX ; pos += 1 ) { WS2812_SET_RGB ( 0 , 0 , 255 ); // blue while ( SR04_DISTANCE () < COLLISION_THRESH ) { WS2812_SET_RGB ( 255 , 0 , 0 ); // red if ( pos <= PAN_CENTER ) // obstacle left { // turn right while ( SR04_DISTANCE () < COLLISION_THRESH + COLLISION_THRESH_FREE ) { checktonear (); // check min. distance turn_right ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); // rnd delay for better escape behavior } // forward move_fwd ( 100 ); } else if ( pos > PAN_CENTER ) // obstacle right { // turn left while ( SR04_DISTANCE () < COLLISION_THRESH + COLLISION_THRESH_FREE ) { checktonear (); // check min. distance turn_left ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); // rnd delay for better escape behavior } // forward move_fwd ( 100 ); } } // sweep servo servo_pan . write ( pos ); } // forward move_fwd ( 100 ); // scanner turn to full left for ( pos = PAN_RIGHTMAX ; pos >= PAN_LEFTMAX ; pos -= 1 ) { WS2812_SET_RGB ( 0 , 255 , 0 ); // green while ( SR04_DISTANCE () < COLLISION_THRESH ) { WS2812_SET_RGB ( 255 , 0 , 0 ); // red if ( pos <= PAN_CENTER ) // obstacle left { // turn right while ( SR04_DISTANCE () < COLLISION_THRESH + COLLISION_THRESH_FREE ) { checktonear (); // check min. distance turn_right ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); // rnd delay for better escape behavior } // forward move_fwd ( 100 ); } else if ( pos > PAN_CENTER ) // obstacle right { // turn left while ( SR04_DISTANCE () < COLLISION_THRESH + COLLISION_THRESH_FREE ) { checktonear (); // check min. distance turn_left ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); // rnd delay for better escape behavior } // forward move_fwd ( 100 ); } } // sweep servo servo_pan . write ( pos ); } } } } } /****************************************************************************** MOVE ******************************************************************************/ void move_init () { // basic robot movement parameter ROBOT_PWR_ON (); delay ( 1000 ); ROBOT_SPEED ( MOVE_SPEED ); ROBOT_HEIGHT ( 35 ); } void checktonear () { // min. distance, too close to the obstacle if ( SR04_DISTANCE () < COLLISION_THRESH_FREE ) // backward, to near { move_bwd ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); } } void move_fwd ( int t ) { // [lateral],[move],[turn] // move = 0 -> max speed forward //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right SendData ( CMD_REG_WALK , 128 , 0 , 128 , 0 ); delay ( t ); } void move_bwd ( int t ) { // [lateral],[move],[turn] // move = 255 -> max speed backward //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right SendData ( CMD_REG_WALK , 128 , 255 , 128 , 0 ); delay ( t ); } void turn_left ( int t ) { // [lateral],[move],[turn] // turn = 0 -> max speed left //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right ROBOT_TRANSLATE_MODE ( 128 , 128 , 60 , 128 ); SendData ( CMD_REG_WALK , 128 , 128 , 25 , 0 ); delay ( t ); ROBOT_TRANSLATE_MODE ( 128 , 128 , 128 , 128 ); } void turn_right ( int t ) { // [lateral],[move],[turn] // turn = 255 -> max speed right //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right ROBOT_TRANSLATE_MODE ( 128 , 128 , 60 , 128 ); SendData ( CMD_REG_WALK , 128 , 128 , 230 , 0 ); delay ( t ); ROBOT_TRANSLATE_MODE ( 128 , 128 , 128 , 128 ); } void stop_move ( int t ) { // [lateral],[move],[turn] // all = 128 -> stop //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right SendData ( CMD_REG_WALK , 128 , 128 , 128 , 0 ); delay ( t ); } /****************************************************************************** HC-SR04 FUNCTIONS ******************************************************************************/ int SR04_DISTANCE () { long duration = 0 ; int distance = 0 ; // AVG value (2 samples) for ( int i = 0 ; i < 2 ; i ++ ) { // Clears the trigPin digitalWrite ( SR04_TRG_PIN , LOW ); delayMicroseconds ( 2 ); // Sets the trigPin on HIGH state for 10 micro seconds digitalWrite ( SR04_TRG_PIN , HIGH ); delayMicroseconds ( 10 ); digitalWrite ( SR04_TRG_PIN , LOW ); // Reads the echoPin, returns the sound wave travel time in microseconds duration = pulseIn ( SR04_ECHO_PIN , HIGH ); // Calculating the avg distance distance += duration * 0.034 / 2 ; delay ( 5 ); } return round ( distance / 2 ); // cm } /****************************************************************************** WS2812 RGB-LED FUNCTIONS ******************************************************************************/ void WS2812_ColorSweep ( int i ) { // WS2812 color change // Farbwerte mit Vorbesetzung, begonnen wird mit rot static int red = 255 ; static int green = 0 ; static int blue = 0 ; if ( i < 255 ) // Phase 1: von rot nach gr\u00fcn { red -- ; // red down green ++ ; // green up blue = 0 ; // blue low } else if ( i < 510 ) // Phase 2: von gr\u00fcn nach blau { red = 0 ; // red low green -- ; // green down blue ++ ; // blue up } else if ( i < 766 ) // Phase 3: von blau nach rot { red ++ ; // red up green = 0 ; // green low blue -- ; // blue down } pixel . setPixelColor ( 0 , pixel . Color ( red , green , blue )); pixel . show (); } void WS2812_SET_RGB ( byte r , byte g , byte b ) { // WS2812 color change pixel . setPixelColor ( 0 , pixel . Color ( r , g , b )); pixel . show (); } Download .ino","title":"Avoid obstacles with an ultrasonic sensor"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#avoid-obstacles-with-an-ultrasonic-sensor","text":"","title":"Avoid obstacles with an ultrasonic sensor"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#requirements","text":"Fully assembled Pan & Tilt Unit Arduino UNO (or similar) Ultrasonic Sensor Module (eg 1616245) RGB-LED WS2812","title":"Requirements:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#schematic","text":"Figure S1","title":"Schematic:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#rgb-led-ws2812","text":"DIN \u2192 9 DOUT \u2192 empty VSS(VCC): \u2192 5V VDD(GND): \u2192 GND","title":"RGB-LED WS2812"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#hc-sr04","text":"Trig \u2192 A0 Echo \u2192 A1 VCC \u2192 5V GND \u2192 GND","title":"HC-SR04"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#funcions","text":"","title":"Funcions:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#description","text":"The demo shows how the MAKERFACTORY Robobug can start walking automatically and avoid obstacles with help of an ultrasonic sensor HC-SR04.","title":"Description:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#plug-in","text":"After plugging in the power supply, the Robobug gives a melody and waits for the start signal.","title":"Plug in:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#start","text":"Press the button T1 on the locomotion controller board. The Robobug gets up on its feet and starts walking in a straight direction.","title":"Start:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#measuring","text":"The head turns frequently from left to right, so the ultrasonic sensor continuously measures the distance to all obstacles in a range of 60\u00b0 (30\u00b0 left and 30\u00b0 right) and the RGB LED blinks in blue and green.","title":"Measuring:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#detect-obstacle-with-distance-60cm","text":"The RGB LED turns red and the Robobug turns around until there is no other obstacle nearer than 90cm.","title":"Detect obstacle with distance &lt; 60cm:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#detect-obstacle-with-distance-30cm","text":"The RGB LED turns red and the Robobug walks backwards (=escape behavior). After that, it turns around until there is no other obstacle nearer than 90cm.","title":"Detect obstacle with distance &lt; 30cm:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#parameters","text":"PARAMETER Description Default SERVO_TILT_PIN Servo Tilt Pin SU1 SERVO_PAN_PIN Servo Pan Pin SU2 WS2812_PIN RGB-LED-Pin SU3 (PIN 9) SR04_TRG_PIN Ultrasonic Trigger Pin A0 SR04_ECHO_PIN Ultrasonic Echo Pin A1 PAN_CENTER Lower value \u21d2 head goes left 100 TILT_CENTER Lower value \u21d2 head goes up 95 PAN_SCANDEG Scan Degree (Degrees from center) 30 COLLISION_THRESH Threshold for obstacles to turn 60 COLLISION_THRESH_FREE Threshold for obstacles to escape 30 BASIC_DELAY Basic delay to move backwards 1500 MIN_RND_DELAY Min random delay to move backw. 500 MAX_RND_DELAY Max random delay to move backw. 2000 MOVE_SPEED Basic movement speed 20","title":"Parameters:"},{"location":"educational-robotics/robobug-hexapod/project_us_demo/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 /****************************************************************** Created with PROGRAMINO IDE for Arduino Project : MAKERFACTORY Ultrasonic Demo (Snoopy Logic) Author : UlliS Description : The demo shows how the MAKERFACTORY can avoid obstacles with the Pan & Tilt unit and an ultrasonic sensor HC-SR04. Userboard is ARDUINO UNO --------------------------- - IR Daten 7 - SU1 6 Pan - SU2 5 Tilt - SU3 9 +/- WS2812 - A0 US Trigger - A1 US Echo - A4 free - A5 free - 10 free ******************************************************************/ #include <Adafruit_NeoPixel.h> // https://github.com/adafruit/Adafruit_NeoPixel #ifdef __AVR__ #include <avr/power.h> #endif #include <Servo.h> // Arduino #define ARDUINO #include <Hexapod_Lib.h> /****************************************************************************** WS2812 RGB-LED ******************************************************************************/ // WS2812/13 (Neopixel) smart RGB LED #define WS2812_PIN SU3 // Parameter 1 = number of pixels in strip // Parameter 2 = Arduino pin number (most are valid) // Parameter 3 = pixel type flags, add together as needed: // NEO_KHZ800 800 KHz bitstream (most NeoPixel products w/WS2812 LEDs) // NEO_KHZ400 400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers) // NEO_GRB Pixels are wired for GRB bitstream (most NeoPixel products) // NEO_RGB Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2) // NEO_RGBW Pixels are wired for RGBW bitstream (NeoPixel RGBW products) Adafruit_NeoPixel pixel = Adafruit_NeoPixel ( 1 , WS2812_PIN , NEO_GRB + NEO_KHZ800 ); /****************************************************************************** HC-SR04 ULTRASONIC SENSOR ******************************************************************************/ // pins for ultrasonic sensor #define SR04_TRG_PIN A0 #define SR04_ECHO_PIN A1 /****************************************************************************** SERVO PAN & TILT ******************************************************************************/ // declare your servo as an object #define SERVO_PAN_PIN SU2 #define SERVO_TILT_PIN SU1 Servo servo_pan ; Servo servo_tilt ; #define PAN_CENTER 100 // lower value scanner more left #define TILT_CENTER 95 // lower value scanner more up #define PAN_SCANDEG 30 #define PAN_LEFTMAX (PAN_CENTER - PAN_SCANDEG) #define PAN_RIGHTMAX (PAN_CENTER + PAN_SCANDEG) #define COLLISION_THRESH 60 // threshold for obstacles (in cm) #define COLLISION_THRESH_FREE 30 // threshold for obstacles + cm #define BASIC_DELAY 1500 #define MIN_RND_DELAY 500 #define MAX_RND_DELAY 2000 #define MOVE_SPEED 20 int pos = 0 ; /****************************************************************************** SETUP ******************************************************************************/ void setup () { // WS2812 RGB-LED pixel . begin (); // this initializes the NeoPixel library. WS2812_SET_RGB ( 255 , 255 , 255 ); // high-Z for the audio output pinMode ( PA_PIN , INPUT ); digitalWrite ( PA_PIN , LOW ); // switches T1 and T2 pinMode ( T1 , INPUT ); pinMode ( T2 , INPUT ); // HC-SR04 pinMode ( SR04_TRG_PIN , OUTPUT ); pinMode ( SR04_ECHO_PIN , INPUT ); // open serial communications and wait for port to open: Serial . begin ( SERIAL_STD_BAUD ); while ( ! Serial ); // set the data rate for the SoftwareSerial port (User-Board to Locomotion-Controller) SERIAL_CMD . begin ( SERIAL_CMD_BAUD ); // reset the Locomotion-Controller ROBOT_RESET (); delay ( 250 ); ROBOT_RESET (); delay ( 150 ); ROBOT_RESET (); // wait for Boot-Up delay ( 1500 ); ROBOT_INIT (); // pan & tilt servos servo_pan . attach ( SERVO_PAN_PIN ); servo_tilt . attach ( SERVO_TILT_PIN ); servo_pan . write ( PAN_CENTER ); servo_tilt . write ( TILT_CENTER ); // rnd init randomSeed ( analogRead ( 0 )); // RBG LED for ( int i = 0 ; i < 765 ; i ++ ) { WS2812_ColorSweep ( i ); delay ( 5 ); } WS2812_SET_RGB ( 0 , 255 , 0 ); // green // print a hello world over the USB connection Serial . println ( \"> Hello here is the MAKERFACTORY Robobug\" ); } /****************************************************************************** MAIN LOOP ******************************************************************************/ void loop () { // start demo if ( ! digitalRead ( T1 )) { delay ( 50 ); if ( ! digitalRead ( T1 )) { MSound ( 1 , 100 , 1000 ); move_init (); // turn center to left (soft start up) for ( pos = PAN_CENTER ; pos >= PAN_LEFTMAX ; pos -= 1 ) { // in steps of 1 degree servo_pan . write ( pos ); delay ( 20 ); } while ( 1 ) { // forward move_fwd ( 100 ); // scanner turn to full right for ( pos = PAN_LEFTMAX ; pos <= PAN_RIGHTMAX ; pos += 1 ) { WS2812_SET_RGB ( 0 , 0 , 255 ); // blue while ( SR04_DISTANCE () < COLLISION_THRESH ) { WS2812_SET_RGB ( 255 , 0 , 0 ); // red if ( pos <= PAN_CENTER ) // obstacle left { // turn right while ( SR04_DISTANCE () < COLLISION_THRESH + COLLISION_THRESH_FREE ) { checktonear (); // check min. distance turn_right ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); // rnd delay for better escape behavior } // forward move_fwd ( 100 ); } else if ( pos > PAN_CENTER ) // obstacle right { // turn left while ( SR04_DISTANCE () < COLLISION_THRESH + COLLISION_THRESH_FREE ) { checktonear (); // check min. distance turn_left ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); // rnd delay for better escape behavior } // forward move_fwd ( 100 ); } } // sweep servo servo_pan . write ( pos ); } // forward move_fwd ( 100 ); // scanner turn to full left for ( pos = PAN_RIGHTMAX ; pos >= PAN_LEFTMAX ; pos -= 1 ) { WS2812_SET_RGB ( 0 , 255 , 0 ); // green while ( SR04_DISTANCE () < COLLISION_THRESH ) { WS2812_SET_RGB ( 255 , 0 , 0 ); // red if ( pos <= PAN_CENTER ) // obstacle left { // turn right while ( SR04_DISTANCE () < COLLISION_THRESH + COLLISION_THRESH_FREE ) { checktonear (); // check min. distance turn_right ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); // rnd delay for better escape behavior } // forward move_fwd ( 100 ); } else if ( pos > PAN_CENTER ) // obstacle right { // turn left while ( SR04_DISTANCE () < COLLISION_THRESH + COLLISION_THRESH_FREE ) { checktonear (); // check min. distance turn_left ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); // rnd delay for better escape behavior } // forward move_fwd ( 100 ); } } // sweep servo servo_pan . write ( pos ); } } } } } /****************************************************************************** MOVE ******************************************************************************/ void move_init () { // basic robot movement parameter ROBOT_PWR_ON (); delay ( 1000 ); ROBOT_SPEED ( MOVE_SPEED ); ROBOT_HEIGHT ( 35 ); } void checktonear () { // min. distance, too close to the obstacle if ( SR04_DISTANCE () < COLLISION_THRESH_FREE ) // backward, to near { move_bwd ( BASIC_DELAY + random ( MIN_RND_DELAY , MAX_RND_DELAY )); } } void move_fwd ( int t ) { // [lateral],[move],[turn] // move = 0 -> max speed forward //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right SendData ( CMD_REG_WALK , 128 , 0 , 128 , 0 ); delay ( t ); } void move_bwd ( int t ) { // [lateral],[move],[turn] // move = 255 -> max speed backward //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right SendData ( CMD_REG_WALK , 128 , 255 , 128 , 0 ); delay ( t ); } void turn_left ( int t ) { // [lateral],[move],[turn] // turn = 0 -> max speed left //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right ROBOT_TRANSLATE_MODE ( 128 , 128 , 60 , 128 ); SendData ( CMD_REG_WALK , 128 , 128 , 25 , 0 ); delay ( t ); ROBOT_TRANSLATE_MODE ( 128 , 128 , 128 , 128 ); } void turn_right ( int t ) { // [lateral],[move],[turn] // turn = 255 -> max speed right //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right ROBOT_TRANSLATE_MODE ( 128 , 128 , 60 , 128 ); SendData ( CMD_REG_WALK , 128 , 128 , 230 , 0 ); delay ( t ); ROBOT_TRANSLATE_MODE ( 128 , 128 , 128 , 128 ); } void stop_move ( int t ) { // [lateral],[move],[turn] // all = 128 -> stop //----------------------- // lateral [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right //----------------------- // move [0 to 255] //----------------------- // 128 = stop // 0 = full speed forward // 255 = full speed backward //----------------------- // turn [0 to 255] //----------------------- // 128 = stop // 0 = full speed left // 255 = full speed right SendData ( CMD_REG_WALK , 128 , 128 , 128 , 0 ); delay ( t ); } /****************************************************************************** HC-SR04 FUNCTIONS ******************************************************************************/ int SR04_DISTANCE () { long duration = 0 ; int distance = 0 ; // AVG value (2 samples) for ( int i = 0 ; i < 2 ; i ++ ) { // Clears the trigPin digitalWrite ( SR04_TRG_PIN , LOW ); delayMicroseconds ( 2 ); // Sets the trigPin on HIGH state for 10 micro seconds digitalWrite ( SR04_TRG_PIN , HIGH ); delayMicroseconds ( 10 ); digitalWrite ( SR04_TRG_PIN , LOW ); // Reads the echoPin, returns the sound wave travel time in microseconds duration = pulseIn ( SR04_ECHO_PIN , HIGH ); // Calculating the avg distance distance += duration * 0.034 / 2 ; delay ( 5 ); } return round ( distance / 2 ); // cm } /****************************************************************************** WS2812 RGB-LED FUNCTIONS ******************************************************************************/ void WS2812_ColorSweep ( int i ) { // WS2812 color change // Farbwerte mit Vorbesetzung, begonnen wird mit rot static int red = 255 ; static int green = 0 ; static int blue = 0 ; if ( i < 255 ) // Phase 1: von rot nach gr\u00fcn { red -- ; // red down green ++ ; // green up blue = 0 ; // blue low } else if ( i < 510 ) // Phase 2: von gr\u00fcn nach blau { red = 0 ; // red low green -- ; // green down blue ++ ; // blue up } else if ( i < 766 ) // Phase 3: von blau nach rot { red ++ ; // red up green = 0 ; // green low blue -- ; // blue down } pixel . setPixelColor ( 0 , pixel . Color ( red , green , blue )); pixel . show (); } void WS2812_SET_RGB ( byte r , byte g , byte b ) { // WS2812 color change pixel . setPixelColor ( 0 , pixel . Color ( r , g , b )); pixel . show (); } Download .ino","title":"Code:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/","text":"Follow objects with an ultrasonic sensor \u00b6 Requirements: \u00b6 Fully assembled Pan & Tilt Unit Arduino UNO (or similar) Ultrasonic Sensor Module (eg 1616245) RGB-LED WS2812 Schematic: \u00b6 Figure S1 RGB-LED WS2812 \u00b6 DIN \u2192 9 DOUT \u2192 empty VSS(VCC): \u2192 5V VDD(GND): \u2192 GND HC-SR04 \u00b6 Trig \u2192 A0 Echo \u2192 A1 VCC \u2192 5V GND \u2192 GND Functions: \u00b6 Description: \u00b6 The demo shows how the MAKERFACTORY Robobug can follow obstacles (eg your hand) with help of an ultrasonic sensor HC-SR04. Plug in: \u00b6 After plugging in the power supply, the Robobug gives a melody and waits for the start signal. Start: \u00b6 Press the button T1 on the locomotion controller board. The Robobug gets up on its and starts measuring Measuring: \u00b6 The Robobug tries to keep the distance of any obstacle between 10 and 20 cm. If the obstacle moves closer to the Robobug\u2019s head, the RGB-LED turns red and the roboter moves backwards. If the obstacle moves away, the LED turns blue and the robobug will follow the obstacle until the distance is less than 20 cm again. And if the nearest obstacle\u2019s distance is higher than 60cm, the Robobug stops walking. Parameters: \u00b6 PARAMETER Description Default SERVO_TILT_PIN Servo Tilt Pin SU1 SERVO_PAN_PIN Servo Pan Pin SU2 WS2812_PIN RGB-LED-Pin SU3 (PIN 9) SR04_TRG_PIN Ultrasonic Trigger Pin A0 SR04_ECHO_PIN Ultrasonic Echo Pin A1 DIST_MIN Minimum Distance in cm 10 DIST_MAX Maximum Distance in cm 20 DIST_STOP Max Distance for STOP 60 Code: \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 /****************************************************************** Created with PROGRAMINO IDE for Arduino Project : MAKERFACTORY Ultrasonic Demo Author : UlliS Description : The demo shows how the MAKERFACTORY can follow a obstacles in front of the robot with the Pan & Tilt unit and an ultrasonic sensor HC-SR04. Userboard is ARDUINO UNO --------------------------- - IR Daten 7 - SU1 6 Pan - SU2 5 Tilt - SU3 9 +/- WS2812 - A0 US Trigger - A1 US Echo - A4 free - A5 free - 10 free ******************************************************************/ #include <Adafruit_NeoPixel.h> // https://github.com/adafruit/Adafruit_NeoPixel #ifdef __AVR__ #include <avr/power.h> #endif #include <Servo.h> // Arduino #define ARDUINO #include <Hexapod_Lib.h> /****************************************************************************** WS2812 RGB-LED ******************************************************************************/ // WS2812/13 (Neopixel) smart RGB LED #define WS2812_PIN SU3 // Parameter 1 = number of pixels in strip // Parameter 2 = Arduino pin number (most are valid) // Parameter 3 = pixel type flags, add together as needed: // NEO_KHZ800 800 KHz bitstream (most NeoPixel products w/WS2812 LEDs) // NEO_KHZ400 400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers) // NEO_GRB Pixels are wired for GRB bitstream (most NeoPixel products) // NEO_RGB Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2) // NEO_RGBW Pixels are wired for RGBW bitstream (NeoPixel RGBW products) Adafruit_NeoPixel pixel = Adafruit_NeoPixel ( 1 , WS2812_PIN , NEO_GRB + NEO_KHZ800 ); /****************************************************************************** HC-SR04 ULTRASONIC SENSOR ******************************************************************************/ // pins for ultrasonic sensor #define SR04_TRG_PIN A0 #define SR04_ECHO_PIN A1 /****************************************************************************** SERVO PAN & TILT ******************************************************************************/ // declare your servo as an object #define SERVO_PAN_PIN SU2 #define SERVO_TILT_PIN SU1 Servo servo_pan ; Servo servo_tilt ; #define PAN_CENTER 100 // lower value scanner more left #define TILT_CENTER 95 // lower value scanner more up #define DIST_MIN 10 #define DIST_MAX 20 #define DIST_STOP 60 /****************************************************************************** SETUP ******************************************************************************/ void setup () { // WS2812 RGB-LED pixel . begin (); // this initializes the NeoPixel library. WS2812_SET_RGB ( 255 , 255 , 255 ); // high-Z for the audio output pinMode ( PA_PIN , INPUT ); digitalWrite ( PA_PIN , LOW ); // switches T1 and T2 pinMode ( T1 , INPUT ); pinMode ( T2 , INPUT ); // HC-SR04 pinMode ( SR04_TRG_PIN , OUTPUT ); pinMode ( SR04_ECHO_PIN , INPUT ); // open serial communications and wait for port to open: Serial . begin ( SERIAL_STD_BAUD ); while ( ! Serial ); // set the data rate for the SoftwareSerial port (User-Board to Locomotion-Controller) SERIAL_CMD . begin ( SERIAL_CMD_BAUD ); // reset the Locomotion-Controller ROBOT_RESET (); delay ( 250 ); ROBOT_RESET (); delay ( 150 ); ROBOT_RESET (); // wait for Boot-Up delay ( 1500 ); ROBOT_INIT (); // pan & tilt servos servo_pan . attach ( SERVO_PAN_PIN ); servo_tilt . attach ( SERVO_TILT_PIN ); servo_pan . write ( PAN_CENTER ); servo_tilt . write ( TILT_CENTER ); // rnd init randomSeed ( analogRead ( 0 )); // RBG LED for ( int i = 0 ; i < 765 ; i ++ ) { WS2812_ColorSweep ( i ); delay ( 2 ); } WS2812_SET_RGB ( 0 , 255 , 0 ); // green // print a hello world over the USB connection Serial . println ( \"> Hello here is the MAKERFACTORY Robobug\" ); } /****************************************************************************** MAIN LOOP ******************************************************************************/ void loop () { // start demo if ( ! digitalRead ( T1 )) { delay ( 50 ); if ( ! digitalRead ( T1 )) { MSound ( 1 , 100 , 1000 ); // basic robot movement parameter ROBOT_PWR_ON (); delay ( 1000 ); ROBOT_SPEED ( 30 ); ROBOT_HEIGHT ( 40 ); while ( 1 ) { int dist = SR04_DISTANCE (); if ( dist < DIST_MIN ) { WS2812_SET_RGB ( 255 , 0 , 0 ); // red ROBOT_WALK_BWD (); } else if ( dist > DIST_MAX && dist < DIST_STOP ) { WS2812_SET_RGB ( 0 , 0 , 255 ); // blue ROBOT_WALK_FWD (); } else if ( dist < DIST_MAX && dist > DIST_MIN ) { WS2812_SET_RGB ( 0 , 255 , 0 ); // green ROBOT_STOP (); } else ROBOT_STOP (); delay ( 500 ); } } } } /****************************************************************************** HC-SR04 FUNCTIONS ******************************************************************************/ int SR04_DISTANCE () { long duration = 0 ; int distance = 0 ; // AVG value (2 samples) for ( int i = 0 ; i < 2 ; i ++ ) { // Clears the trigPin digitalWrite ( SR04_TRG_PIN , LOW ); delayMicroseconds ( 2 ); // Sets the trigPin on HIGH state for 10 micro seconds digitalWrite ( SR04_TRG_PIN , HIGH ); delayMicroseconds ( 10 ); digitalWrite ( SR04_TRG_PIN , LOW ); // Reads the echoPin, returns the sound wave travel time in microseconds duration = pulseIn ( SR04_ECHO_PIN , HIGH ); // Calculating the avg distance distance += duration * 0.034 / 2 ; delay ( 5 ); } return round ( distance / 2 ); // cm } /****************************************************************************** WS2812 RGB-LED FUNCTIONS ******************************************************************************/ void WS2812_ColorSweep ( int i ) { // WS2812 color change // Farbwerte mit Vorbesetzung, begonnen wird mit rot static int red = 255 ; static int green = 0 ; static int blue = 0 ; if ( i < 255 ) // Phase 1: von rot nach gr\u00fcn { red -- ; // red down green ++ ; // green up blue = 0 ; // blue low } else if ( i < 510 ) // Phase 2: von gr\u00fcn nach blau { red = 0 ; // red low green -- ; // green down blue ++ ; // blue up } else if ( i < 766 ) // Phase 3: von blau nach rot { red ++ ; // red up green = 0 ; // green low blue -- ; // blue down } pixel . setPixelColor ( 0 , pixel . Color ( red , green , blue )); pixel . show (); } void WS2812_SET_RGB ( byte r , byte g , byte b ) { // WS2812 color change pixel . setPixelColor ( 0 , pixel . Color ( r , g , b )); pixel . show (); } Download .ino","title":"Follow objects with an ultrasonic sensor"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#follow-objects-with-an-ultrasonic-sensor","text":"","title":"Follow objects with an ultrasonic sensor"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#requirements","text":"Fully assembled Pan & Tilt Unit Arduino UNO (or similar) Ultrasonic Sensor Module (eg 1616245) RGB-LED WS2812","title":"Requirements:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#schematic","text":"Figure S1","title":"Schematic:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#rgb-led-ws2812","text":"DIN \u2192 9 DOUT \u2192 empty VSS(VCC): \u2192 5V VDD(GND): \u2192 GND","title":"RGB-LED WS2812"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#hc-sr04","text":"Trig \u2192 A0 Echo \u2192 A1 VCC \u2192 5V GND \u2192 GND","title":"HC-SR04"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#functions","text":"","title":"Functions:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#description","text":"The demo shows how the MAKERFACTORY Robobug can follow obstacles (eg your hand) with help of an ultrasonic sensor HC-SR04.","title":"Description:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#plug-in","text":"After plugging in the power supply, the Robobug gives a melody and waits for the start signal.","title":"Plug in:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#start","text":"Press the button T1 on the locomotion controller board. The Robobug gets up on its and starts measuring","title":"Start:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#measuring","text":"The Robobug tries to keep the distance of any obstacle between 10 and 20 cm. If the obstacle moves closer to the Robobug\u2019s head, the RGB-LED turns red and the roboter moves backwards. If the obstacle moves away, the LED turns blue and the robobug will follow the obstacle until the distance is less than 20 cm again. And if the nearest obstacle\u2019s distance is higher than 60cm, the Robobug stops walking.","title":"Measuring:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#parameters","text":"PARAMETER Description Default SERVO_TILT_PIN Servo Tilt Pin SU1 SERVO_PAN_PIN Servo Pan Pin SU2 WS2812_PIN RGB-LED-Pin SU3 (PIN 9) SR04_TRG_PIN Ultrasonic Trigger Pin A0 SR04_ECHO_PIN Ultrasonic Echo Pin A1 DIST_MIN Minimum Distance in cm 10 DIST_MAX Maximum Distance in cm 20 DIST_STOP Max Distance for STOP 60","title":"Parameters:"},{"location":"educational-robotics/robobug-hexapod/project_us_follow/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 /****************************************************************** Created with PROGRAMINO IDE for Arduino Project : MAKERFACTORY Ultrasonic Demo Author : UlliS Description : The demo shows how the MAKERFACTORY can follow a obstacles in front of the robot with the Pan & Tilt unit and an ultrasonic sensor HC-SR04. Userboard is ARDUINO UNO --------------------------- - IR Daten 7 - SU1 6 Pan - SU2 5 Tilt - SU3 9 +/- WS2812 - A0 US Trigger - A1 US Echo - A4 free - A5 free - 10 free ******************************************************************/ #include <Adafruit_NeoPixel.h> // https://github.com/adafruit/Adafruit_NeoPixel #ifdef __AVR__ #include <avr/power.h> #endif #include <Servo.h> // Arduino #define ARDUINO #include <Hexapod_Lib.h> /****************************************************************************** WS2812 RGB-LED ******************************************************************************/ // WS2812/13 (Neopixel) smart RGB LED #define WS2812_PIN SU3 // Parameter 1 = number of pixels in strip // Parameter 2 = Arduino pin number (most are valid) // Parameter 3 = pixel type flags, add together as needed: // NEO_KHZ800 800 KHz bitstream (most NeoPixel products w/WS2812 LEDs) // NEO_KHZ400 400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers) // NEO_GRB Pixels are wired for GRB bitstream (most NeoPixel products) // NEO_RGB Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2) // NEO_RGBW Pixels are wired for RGBW bitstream (NeoPixel RGBW products) Adafruit_NeoPixel pixel = Adafruit_NeoPixel ( 1 , WS2812_PIN , NEO_GRB + NEO_KHZ800 ); /****************************************************************************** HC-SR04 ULTRASONIC SENSOR ******************************************************************************/ // pins for ultrasonic sensor #define SR04_TRG_PIN A0 #define SR04_ECHO_PIN A1 /****************************************************************************** SERVO PAN & TILT ******************************************************************************/ // declare your servo as an object #define SERVO_PAN_PIN SU2 #define SERVO_TILT_PIN SU1 Servo servo_pan ; Servo servo_tilt ; #define PAN_CENTER 100 // lower value scanner more left #define TILT_CENTER 95 // lower value scanner more up #define DIST_MIN 10 #define DIST_MAX 20 #define DIST_STOP 60 /****************************************************************************** SETUP ******************************************************************************/ void setup () { // WS2812 RGB-LED pixel . begin (); // this initializes the NeoPixel library. WS2812_SET_RGB ( 255 , 255 , 255 ); // high-Z for the audio output pinMode ( PA_PIN , INPUT ); digitalWrite ( PA_PIN , LOW ); // switches T1 and T2 pinMode ( T1 , INPUT ); pinMode ( T2 , INPUT ); // HC-SR04 pinMode ( SR04_TRG_PIN , OUTPUT ); pinMode ( SR04_ECHO_PIN , INPUT ); // open serial communications and wait for port to open: Serial . begin ( SERIAL_STD_BAUD ); while ( ! Serial ); // set the data rate for the SoftwareSerial port (User-Board to Locomotion-Controller) SERIAL_CMD . begin ( SERIAL_CMD_BAUD ); // reset the Locomotion-Controller ROBOT_RESET (); delay ( 250 ); ROBOT_RESET (); delay ( 150 ); ROBOT_RESET (); // wait for Boot-Up delay ( 1500 ); ROBOT_INIT (); // pan & tilt servos servo_pan . attach ( SERVO_PAN_PIN ); servo_tilt . attach ( SERVO_TILT_PIN ); servo_pan . write ( PAN_CENTER ); servo_tilt . write ( TILT_CENTER ); // rnd init randomSeed ( analogRead ( 0 )); // RBG LED for ( int i = 0 ; i < 765 ; i ++ ) { WS2812_ColorSweep ( i ); delay ( 2 ); } WS2812_SET_RGB ( 0 , 255 , 0 ); // green // print a hello world over the USB connection Serial . println ( \"> Hello here is the MAKERFACTORY Robobug\" ); } /****************************************************************************** MAIN LOOP ******************************************************************************/ void loop () { // start demo if ( ! digitalRead ( T1 )) { delay ( 50 ); if ( ! digitalRead ( T1 )) { MSound ( 1 , 100 , 1000 ); // basic robot movement parameter ROBOT_PWR_ON (); delay ( 1000 ); ROBOT_SPEED ( 30 ); ROBOT_HEIGHT ( 40 ); while ( 1 ) { int dist = SR04_DISTANCE (); if ( dist < DIST_MIN ) { WS2812_SET_RGB ( 255 , 0 , 0 ); // red ROBOT_WALK_BWD (); } else if ( dist > DIST_MAX && dist < DIST_STOP ) { WS2812_SET_RGB ( 0 , 0 , 255 ); // blue ROBOT_WALK_FWD (); } else if ( dist < DIST_MAX && dist > DIST_MIN ) { WS2812_SET_RGB ( 0 , 255 , 0 ); // green ROBOT_STOP (); } else ROBOT_STOP (); delay ( 500 ); } } } } /****************************************************************************** HC-SR04 FUNCTIONS ******************************************************************************/ int SR04_DISTANCE () { long duration = 0 ; int distance = 0 ; // AVG value (2 samples) for ( int i = 0 ; i < 2 ; i ++ ) { // Clears the trigPin digitalWrite ( SR04_TRG_PIN , LOW ); delayMicroseconds ( 2 ); // Sets the trigPin on HIGH state for 10 micro seconds digitalWrite ( SR04_TRG_PIN , HIGH ); delayMicroseconds ( 10 ); digitalWrite ( SR04_TRG_PIN , LOW ); // Reads the echoPin, returns the sound wave travel time in microseconds duration = pulseIn ( SR04_ECHO_PIN , HIGH ); // Calculating the avg distance distance += duration * 0.034 / 2 ; delay ( 5 ); } return round ( distance / 2 ); // cm } /****************************************************************************** WS2812 RGB-LED FUNCTIONS ******************************************************************************/ void WS2812_ColorSweep ( int i ) { // WS2812 color change // Farbwerte mit Vorbesetzung, begonnen wird mit rot static int red = 255 ; static int green = 0 ; static int blue = 0 ; if ( i < 255 ) // Phase 1: von rot nach gr\u00fcn { red -- ; // red down green ++ ; // green up blue = 0 ; // blue low } else if ( i < 510 ) // Phase 2: von gr\u00fcn nach blau { red = 0 ; // red low green -- ; // green down blue ++ ; // blue up } else if ( i < 766 ) // Phase 3: von blau nach rot { red ++ ; // red up green = 0 ; // green low blue -- ; // blue down } pixel . setPixelColor ( 0 , pixel . Color ( red , green , blue )); pixel . show (); } void WS2812_SET_RGB ( byte r , byte g , byte b ) { // WS2812 color change pixel . setPixelColor ( 0 , pixel . Color ( r , g , b )); pixel . show (); } Download .ino","title":"Code:"},{"location":"educational-robotics/robobug-hexapod/quick-start/","text":"Quick start \u00b6 Product Description \u00b6 A running robot for beginners as well as experienced developers: With the \"Hexapod Robobug\" complete set, consisting of electronics, mechanics and digital high-performance servos, you can build your own Hexapod running robot and enter the exciting world of robotics! The \"Hexapod Robobug\" complete set is the ideal basis for entering the fields of electronics, mechanics and programming: it enables a large number of extensions by using additional user boards such as Arduino, Raspberry Pi or NodeMCU and offers space for many additional components. The robot is designed in such a way that it can be controlled without programming using the controller supplied, similar to an RC model. Thanks to its expandability and flexibility, the robot is perfect for hobby, research, schools, education and training and encourages independent development and expansion. Click here to get to the product page. Info Not included in the delivery: The 3D print data of the Pan & Tilt unit and the required components can be found on the product's website. The product also requires a rechargeable battery and a suitable charger. Figure 1 Features \u00b6 Simple construction Easy programming with Arduino\u2122 (Arduino\u2122 library available) Firmware based on Arduino\u2122 Onboard locomotion controller ATmega2560 for leg control (Arduino\u2122 MEGA compatible) 18x high performance digital servos with metal gear, double ball bearings High-quality aluminium and plastic parts Legs with double ball bearings Control via gamepad (included in delivery) and user board commands Easily accessible connections for your own expansions Serial data connection between user board and locomotion controller Compatible with the following additional boards: Arduino, NodeMCU, SBC (e.g., Raspberry Pi) USB programming interface for Locomotion controller Loudspeaker with amplifier for sound output MicroSD card reader Infrared receiver Freely usable buttons Power management I\u00b2C Seeed Grove connector for extensions Automatic level adjustment for 5 V and 3.3 V user boards Versatile expandability thanks to open architecture and open source software Complete kit to set up the robot (batteries, rechargeable batteries and charger not included)","title":"Quick start"},{"location":"educational-robotics/robobug-hexapod/quick-start/#quick-start","text":"","title":"Quick start"},{"location":"educational-robotics/robobug-hexapod/quick-start/#product-description","text":"A running robot for beginners as well as experienced developers: With the \"Hexapod Robobug\" complete set, consisting of electronics, mechanics and digital high-performance servos, you can build your own Hexapod running robot and enter the exciting world of robotics! The \"Hexapod Robobug\" complete set is the ideal basis for entering the fields of electronics, mechanics and programming: it enables a large number of extensions by using additional user boards such as Arduino, Raspberry Pi or NodeMCU and offers space for many additional components. The robot is designed in such a way that it can be controlled without programming using the controller supplied, similar to an RC model. Thanks to its expandability and flexibility, the robot is perfect for hobby, research, schools, education and training and encourages independent development and expansion. Click here to get to the product page. Info Not included in the delivery: The 3D print data of the Pan & Tilt unit and the required components can be found on the product's website. The product also requires a rechargeable battery and a suitable charger. Figure 1","title":"Product Description"},{"location":"educational-robotics/robobug-hexapod/quick-start/#features","text":"Simple construction Easy programming with Arduino\u2122 (Arduino\u2122 library available) Firmware based on Arduino\u2122 Onboard locomotion controller ATmega2560 for leg control (Arduino\u2122 MEGA compatible) 18x high performance digital servos with metal gear, double ball bearings High-quality aluminium and plastic parts Legs with double ball bearings Control via gamepad (included in delivery) and user board commands Easily accessible connections for your own expansions Serial data connection between user board and locomotion controller Compatible with the following additional boards: Arduino, NodeMCU, SBC (e.g., Raspberry Pi) USB programming interface for Locomotion controller Loudspeaker with amplifier for sound output MicroSD card reader Infrared receiver Freely usable buttons Power management I\u00b2C Seeed Grove connector for extensions Automatic level adjustment for 5 V and 3.3 V user boards Versatile expandability thanks to open architecture and open source software Complete kit to set up the robot (batteries, rechargeable batteries and charger not included)","title":"Features"},{"location":"educational-robotics/robobug-hexapod/required_accessories/","text":"Required accessories \u00b6 NiMH battery; 5 cells, min. 3700 mAh (e.g., Conrad item no. 1784857) Charger (e.g., Conrad item no. 1413029 or 1413030) Adapter cable XT30 (e.g., Conrad item no. 1886426) Batteries (2x AAA/Micro) (e.g., Conrad item no. 658010) Screw locking (e.g., Conrad item no. 826389) Mini-USB cable (e.g., Conrad item no. 1365369) Optional: - Servo for Pan unit * (e.g., Conrad item no. 1762878) - Servo for tilt unit * (e.g., Conrad item no. 1762877) - Arduino UNO (e.g., Conrad item no. 191789) - Screw locking (e.g., Conrad item no. 1613301) \u2192 * The Pan & Tilt unit is the head mechanism (see Figure 1) and can optionally be printed on a 3D printer Required tools and material: - Small side cutter (electronic side cutter) - Scissors - Open-end wrench SW 5.5 mm - Open-end wrench SW 4 mm - Phillips screwdriver PH1 - Phillips screwdriver PH2 - Hexagon socket 6 mm - Hexagon wrench 1.5 mm - Hexagon wrench 2.5 mm - Screw locking (medium strength) e.g., LOCTITE\u00ae 243 (Conrad item no. 1370555) - 90\u00b0 Stop angle or straight edge - Work paper","title":"Required accessories"},{"location":"educational-robotics/robobug-hexapod/required_accessories/#required-accessories","text":"NiMH battery; 5 cells, min. 3700 mAh (e.g., Conrad item no. 1784857) Charger (e.g., Conrad item no. 1413029 or 1413030) Adapter cable XT30 (e.g., Conrad item no. 1886426) Batteries (2x AAA/Micro) (e.g., Conrad item no. 658010) Screw locking (e.g., Conrad item no. 826389) Mini-USB cable (e.g., Conrad item no. 1365369) Optional: - Servo for Pan unit * (e.g., Conrad item no. 1762878) - Servo for tilt unit * (e.g., Conrad item no. 1762877) - Arduino UNO (e.g., Conrad item no. 191789) - Screw locking (e.g., Conrad item no. 1613301) \u2192 * The Pan & Tilt unit is the head mechanism (see Figure 1) and can optionally be printed on a 3D printer Required tools and material: - Small side cutter (electronic side cutter) - Scissors - Open-end wrench SW 5.5 mm - Open-end wrench SW 4 mm - Phillips screwdriver PH1 - Phillips screwdriver PH2 - Hexagon socket 6 mm - Hexagon wrench 1.5 mm - Hexagon wrench 2.5 mm - Screw locking (medium strength) e.g., LOCTITE\u00ae 243 (Conrad item no. 1370555) - 90\u00b0 Stop angle or straight edge - Work paper","title":"Required accessories"},{"location":"educational-robotics/robobug-hexapod/safety_instructions/","text":"Safety Instructions \u00b6 Caution Please read the operating instructions carefully and pay particular attention to the safety instructions. We do not assume liability for any injuries/material damages resulting from failure to observe the safety instructions and the information in these operating instructions regarding the proper use of the product. Furthermore, in such cases, the warranty / guarantee will be null and void. Dear customer, These safety instructions are not only for the protection of the product, but also for your own safety and the safety of other people. Therefore, please read this chapter very carefully before using the product for the first time! The product is aimed at advanced users who already have experience with Arduino and the C/C ++ programming language as well as in electronics and in the construction of mechanical kits. If you do not have sufficient experience, please contact an experienced developer, a local builders club or our support. For safety and approval reasons, unauthorised conversion and/or modification of the product beyond what is described, is not permitted. The product is not a toy. Keep out of the reach of children and pets. Do not carelessly cast aside the packaging material. It may become a dangerous plaything for children. Protect the product from extreme temperatures, direct sunlight, strong vibrations, high humidity, moisture, combustible gases, vapours and solvents. Never expose the product to mechanical stress. When connecting the servos, other components and their connecting cables, ensure that the contacts are secure. Loose or wobbly connectors may cause interference or damage. If soldering is required, be sure to avoid short circuits occur during soldering. Before you perform a soldering operation, all parts must have zero potential. To avoid short circuits, make sure that components or solder contacts do not come into contact with metal parts, when installing the board. Short circuits will ruin the product and void the warranty! If safe operation is no longer possible, take the device out of service and secure it against unintended use. Safe operation is no longer possible, if the product: shows visible damage, no longer functions properly, has been stored under adverse ambient conditions for an extended period of time or has been exposed to considerable strain during transport. Please handle the product with care. The product can be damaged if crushed, struck or dropped, even from a low height. If you have doubts about how the equipment should be operated or how to safely connect it, consult a trained technician. Maintenance, adjustment and repair work should only be carried out by an expert or a specialised workshop. If you have any questions that are not answered in these operating instructions, please contact our technical customer service or other professionals.","title":"Safety Instructions"},{"location":"educational-robotics/robobug-hexapod/safety_instructions/#safety-instructions","text":"Caution Please read the operating instructions carefully and pay particular attention to the safety instructions. We do not assume liability for any injuries/material damages resulting from failure to observe the safety instructions and the information in these operating instructions regarding the proper use of the product. Furthermore, in such cases, the warranty / guarantee will be null and void. Dear customer, These safety instructions are not only for the protection of the product, but also for your own safety and the safety of other people. Therefore, please read this chapter very carefully before using the product for the first time! The product is aimed at advanced users who already have experience with Arduino and the C/C ++ programming language as well as in electronics and in the construction of mechanical kits. If you do not have sufficient experience, please contact an experienced developer, a local builders club or our support. For safety and approval reasons, unauthorised conversion and/or modification of the product beyond what is described, is not permitted. The product is not a toy. Keep out of the reach of children and pets. Do not carelessly cast aside the packaging material. It may become a dangerous plaything for children. Protect the product from extreme temperatures, direct sunlight, strong vibrations, high humidity, moisture, combustible gases, vapours and solvents. Never expose the product to mechanical stress. When connecting the servos, other components and their connecting cables, ensure that the contacts are secure. Loose or wobbly connectors may cause interference or damage. If soldering is required, be sure to avoid short circuits occur during soldering. Before you perform a soldering operation, all parts must have zero potential. To avoid short circuits, make sure that components or solder contacts do not come into contact with metal parts, when installing the board. Short circuits will ruin the product and void the warranty! If safe operation is no longer possible, take the device out of service and secure it against unintended use. Safe operation is no longer possible, if the product: shows visible damage, no longer functions properly, has been stored under adverse ambient conditions for an extended period of time or has been exposed to considerable strain during transport. Please handle the product with care. The product can be damaged if crushed, struck or dropped, even from a low height. If you have doubts about how the equipment should be operated or how to safely connect it, consult a trained technician. Maintenance, adjustment and repair work should only be carried out by an expert or a specialised workshop. If you have any questions that are not answered in these operating instructions, please contact our technical customer service or other professionals.","title":"Safety Instructions"},{"location":"educational-robotics/robobug-hexapod/schematic_system_overview/","text":"Schematic system overview (block diagram) \u00b6 The diagram shows schematically the internal wiring and the interaction of the individual components of the robot board and the servos as an aid for programming. Figure 80","title":"Schematic system overview"},{"location":"educational-robotics/robobug-hexapod/schematic_system_overview/#schematic-system-overview-block-diagram","text":"The diagram shows schematically the internal wiring and the interaction of the individual components of the robot board and the servos as an aid for programming. Figure 80","title":"Schematic system overview (block diagram)"},{"location":"educational-robotics/robobug-hexapod/technical_data/","text":"Technical Data \u00b6 General Information \u00b6 Body lenght 280 mm Body height without PCB 150 mm Body width without PCB 65 mm Coxa lenght 50 mm Femur lenght 75 mm Tibia lenght 115 mm Weight with battery approx. 2.7 kg Servo actuating force at 6 V/DC: 13 kg Number of degrees of freedom DOF (servos) 18 Recommended battery pack 5 cells NiMH, 3700 mAh (connection cable 2.5 mm\u00b2, plug XT30) Control electronics \u00b6 Operating voltage 4.5 - 10 V/DC Current consumption approx. 80 mA Number of servo connections 18 locomotion controllers + 3 user boards Programming Arduino IDE (C/C++) Programming interface USB User board slots 3 I2C connectors Locomotion controller 2 I2C connector User-Board 2 IR receive 1x 338 kHz (only usable in combination with Arduino UNO slor or compatible boards) Audio amplifier with louddspeaker 1 MicroSD card slot (*) 1 (can only be used in conjunction with Arduino UNO slot or compatible boards) Locomotion Controller 1 (Atnel ATmega2560 - Arduino MEGA compatible) Reset button Locomotion controller 1 User board reset button 1 ISP connection Locomotion controller 1 User board ISP controller 1 PS2 compatible gamepad connector 1 Internal power supply 3.3 V/DC and 5 V/DC Current carrying capacity 3.3 V/DC 400 mA Current carrying capacity 5 V/DC 1000 mA Dimensions (L x W xH) 200 x 88 x 23 mm Board weight of circuit board only approx. 100 g Working temperature range 0 \u00b0C to + 40 \u00b0C Gamepad \u00b6 Frequency range 2.402 - 2.521 GHz Transmission power 10 mW Power supply integrated Li-Ion battery, rechargeable via USB","title":"Technical Data"},{"location":"educational-robotics/robobug-hexapod/technical_data/#technical-data","text":"","title":"Technical Data"},{"location":"educational-robotics/robobug-hexapod/technical_data/#general-information","text":"Body lenght 280 mm Body height without PCB 150 mm Body width without PCB 65 mm Coxa lenght 50 mm Femur lenght 75 mm Tibia lenght 115 mm Weight with battery approx. 2.7 kg Servo actuating force at 6 V/DC: 13 kg Number of degrees of freedom DOF (servos) 18 Recommended battery pack 5 cells NiMH, 3700 mAh (connection cable 2.5 mm\u00b2, plug XT30)","title":"General Information"},{"location":"educational-robotics/robobug-hexapod/technical_data/#control-electronics","text":"Operating voltage 4.5 - 10 V/DC Current consumption approx. 80 mA Number of servo connections 18 locomotion controllers + 3 user boards Programming Arduino IDE (C/C++) Programming interface USB User board slots 3 I2C connectors Locomotion controller 2 I2C connector User-Board 2 IR receive 1x 338 kHz (only usable in combination with Arduino UNO slor or compatible boards) Audio amplifier with louddspeaker 1 MicroSD card slot (*) 1 (can only be used in conjunction with Arduino UNO slot or compatible boards) Locomotion Controller 1 (Atnel ATmega2560 - Arduino MEGA compatible) Reset button Locomotion controller 1 User board reset button 1 ISP connection Locomotion controller 1 User board ISP controller 1 PS2 compatible gamepad connector 1 Internal power supply 3.3 V/DC and 5 V/DC Current carrying capacity 3.3 V/DC 400 mA Current carrying capacity 5 V/DC 1000 mA Dimensions (L x W xH) 200 x 88 x 23 mm Board weight of circuit board only approx. 100 g Working temperature range 0 \u00b0C to + 40 \u00b0C","title":"Control electronics"},{"location":"educational-robotics/robobug-hexapod/technical_data/#gamepad","text":"Frequency range 2.402 - 2.521 GHz Transmission power 10 mW Power supply integrated Li-Ion battery, rechargeable via USB","title":"Gamepad"},{"location":"educational-robotics/robobug-hexapod/test-firmware-installation/","text":"Transferring the Firmware \u00b6 On delivery, no firmware is installed on the Hexapod Robot Board. The firmware must first be transferred during initial commissioning. This is done via the Arduino IDE. The following description shows you the procedure for transferring the firmware. In the following chapters you will transfer different programmes to the Hexapod Robot Board. The procedure is identical except for the selection of the respective program. \u2192 When transferring the firmware, the Hexapod Robot Board must be connected to the power supply (battery)! Make sure that the battery is fully charged before transferring the firmware or programmes. Installing the driver \u00b6 Connect the \"PRG-M\" port of the Hexapod Robot Board to a free USB port on your computer. Windows will now attempt to install a new driver. Typically, Windows will automatically download and install the drivers from the Internet, since the driver for the \"FTDI\" USB bridge chip used is available in the Windows driver download (the computer must be connected to the Internet for this to work). If this method does not work, refer to the driver manually during installation. The driver is located in the unpacked download bundle, in the \"Driver\" directory. After installing the driver, check in the device manager whether the driver for the Hexapod Robot Board has been installed and which COM port number has been assigned. Then select them in the Arduino IDE. You can also download the drivers directly from FTDI Chip . Install Arduino IDE \u00b6 You can download the latest version of the Arduino IDE from Arduino . The Arduino IDE is available as \"installer version\" and as \"ZIP archive\". Both versions can be used. With the installer version, you install the Arduino IDE as you would install any other programmes. With the ZIP version, you must unpack the ZIP archive to the desired location on your computer after the download. Then start the programme by double-clicking on the file \"arduino.exe\". \u2192 The current firmware version was developed with Arduino version 1.8.3. If there are problems with newer versions, download an older version of the Arduino IDE from Arduino and transfer the firmware with it. Also familiarize yourself with the board and its connectors. An overview of the board can be found in Chapter 19 Figure 79. Setting up Arduino IDE \u00b6 Start the Arduino IDE and follow the instructions in this manual. Figure 8 Now install the Hexapod library. It can be found in the download bundle under \"\\Library-Demos\\Maker-Factory-Hexapod-V1.1.zip\". Select the menu item \"Sketch\\Include Library\\Add .ZIP Library...\" in the Arduino IDE. \u2192 If you update the library later, you have to delete the old library first, otherwise the Arduino IDE will report an error! Figure 9 After you have installed the library, you will find two folders named \"Locomotion\" and \"User-Boards\" in the menu item \"\\File\\Examples\\Maker-Factory-Hexapod-Vx.x\". The folder \"Locomotion\" contains programmes for the Locomotion controller, which is fixed on the Hexapod Robot Board and is responsible for the operation. The folder \"User-Boards\" contains programmes for the Arduino compatible user boards like Arduino UNO and NodeMCU. Figure 10 Select the microcontroller used under the menu item \"Tools\\Board\\Arduino/Genuino Mega\". The locomotion controller is compatible with the Arduino Mega 2560. Figure 11 Select the COM port under \"Tools\\Port\" that was assigned to the Hexapod Robot Board during driver installation. Figure 12 To test if everything works, transfer the sample programme \"\\User-Board\\Locomotion LEDs\". After successful transmission, the programme causes the blue \"LIVE-LED\" and the red \"USER-LED\" to flash alternately. \u2192To transfer the programmes, the battery must be plugged into the Hexapod Robot Board! After selecting the \"LEDs\" programme (also called Sketch in Arduino) a new Arduino IDE window opens with the \"LEDs\" Sketch. Figure 13 With the \"arrow to the right\" symbol (see picture 14) in the menu you transfer the programme to the Hexapod Robot Board. Alternatively, you can also use the shortcut \"CTRL+U\". Figure 14 This procedure applies to all programmes to be transferred (called sketches in the Arduino IDE) that are intended for the locomotion controller. For the user board samples, you only change the applied user board in use and the \"COM-Port\". \u2192 Please read the respective initial comment in the source code of the examples before transferring. This contains important information about the program! If the transfer does not work, please check your settings for board and connection and also check if the board has been entered and installed correctly in the device manager and if the power supply is connected. Here you can find more information about installing the Arduino IDE from Arduino . Leave the board plugged in for the next step, as you will need to move the leg servos to the centre position in this step.","title":"Test firmware installation"},{"location":"educational-robotics/robobug-hexapod/test-firmware-installation/#transferring-the-firmware","text":"On delivery, no firmware is installed on the Hexapod Robot Board. The firmware must first be transferred during initial commissioning. This is done via the Arduino IDE. The following description shows you the procedure for transferring the firmware. In the following chapters you will transfer different programmes to the Hexapod Robot Board. The procedure is identical except for the selection of the respective program. \u2192 When transferring the firmware, the Hexapod Robot Board must be connected to the power supply (battery)! Make sure that the battery is fully charged before transferring the firmware or programmes.","title":"Transferring the Firmware"},{"location":"educational-robotics/robobug-hexapod/test-firmware-installation/#installing-the-driver","text":"Connect the \"PRG-M\" port of the Hexapod Robot Board to a free USB port on your computer. Windows will now attempt to install a new driver. Typically, Windows will automatically download and install the drivers from the Internet, since the driver for the \"FTDI\" USB bridge chip used is available in the Windows driver download (the computer must be connected to the Internet for this to work). If this method does not work, refer to the driver manually during installation. The driver is located in the unpacked download bundle, in the \"Driver\" directory. After installing the driver, check in the device manager whether the driver for the Hexapod Robot Board has been installed and which COM port number has been assigned. Then select them in the Arduino IDE. You can also download the drivers directly from FTDI Chip .","title":"Installing the driver"},{"location":"educational-robotics/robobug-hexapod/test-firmware-installation/#install-arduino-ide","text":"You can download the latest version of the Arduino IDE from Arduino . The Arduino IDE is available as \"installer version\" and as \"ZIP archive\". Both versions can be used. With the installer version, you install the Arduino IDE as you would install any other programmes. With the ZIP version, you must unpack the ZIP archive to the desired location on your computer after the download. Then start the programme by double-clicking on the file \"arduino.exe\". \u2192 The current firmware version was developed with Arduino version 1.8.3. If there are problems with newer versions, download an older version of the Arduino IDE from Arduino and transfer the firmware with it. Also familiarize yourself with the board and its connectors. An overview of the board can be found in Chapter 19 Figure 79.","title":"Install Arduino IDE"},{"location":"educational-robotics/robobug-hexapod/test-firmware-installation/#setting-up-arduino-ide","text":"Start the Arduino IDE and follow the instructions in this manual. Figure 8 Now install the Hexapod library. It can be found in the download bundle under \"\\Library-Demos\\Maker-Factory-Hexapod-V1.1.zip\". Select the menu item \"Sketch\\Include Library\\Add .ZIP Library...\" in the Arduino IDE. \u2192 If you update the library later, you have to delete the old library first, otherwise the Arduino IDE will report an error! Figure 9 After you have installed the library, you will find two folders named \"Locomotion\" and \"User-Boards\" in the menu item \"\\File\\Examples\\Maker-Factory-Hexapod-Vx.x\". The folder \"Locomotion\" contains programmes for the Locomotion controller, which is fixed on the Hexapod Robot Board and is responsible for the operation. The folder \"User-Boards\" contains programmes for the Arduino compatible user boards like Arduino UNO and NodeMCU. Figure 10 Select the microcontroller used under the menu item \"Tools\\Board\\Arduino/Genuino Mega\". The locomotion controller is compatible with the Arduino Mega 2560. Figure 11 Select the COM port under \"Tools\\Port\" that was assigned to the Hexapod Robot Board during driver installation. Figure 12 To test if everything works, transfer the sample programme \"\\User-Board\\Locomotion LEDs\". After successful transmission, the programme causes the blue \"LIVE-LED\" and the red \"USER-LED\" to flash alternately. \u2192To transfer the programmes, the battery must be plugged into the Hexapod Robot Board! After selecting the \"LEDs\" programme (also called Sketch in Arduino) a new Arduino IDE window opens with the \"LEDs\" Sketch. Figure 13 With the \"arrow to the right\" symbol (see picture 14) in the menu you transfer the programme to the Hexapod Robot Board. Alternatively, you can also use the shortcut \"CTRL+U\". Figure 14 This procedure applies to all programmes to be transferred (called sketches in the Arduino IDE) that are intended for the locomotion controller. For the user board samples, you only change the applied user board in use and the \"COM-Port\". \u2192 Please read the respective initial comment in the source code of the examples before transferring. This contains important information about the program! If the transfer does not work, please check your settings for board and connection and also check if the board has been entered and installed correctly in the device manager and if the power supply is connected. Here you can find more information about installing the Arduino IDE from Arduino . Leave the board plugged in for the next step, as you will need to move the leg servos to the centre position in this step.","title":"Setting up Arduino IDE"},{"location":"educational-robotics/robobug-hexapod/transferring-the-firmware/","text":"Transferring the firmware \u00b6 After you have finished the mechanical assembly of the robot, the \"Locomotion Firmware\" can be installed on the robot board. This is responsible for the running behaviour of the robot. Check the following before transferring and switching on the robot board: Are all servos connected correctly (polarity)? Are all servos mechanically in the middle? Is the Gamepad controller connected? Is the battery sufficiently charged? Is there enough space available for the robot, even in the event of a malfunction? Now connect the battery to the robot board, if not already done. Connect the robot board (connection \"PRG-M\") to your computer as already done. Then select in the Arduino IDE in the Hexapod examples the programme \"Motion Firmware\" (located under \"Locomotion\"). Transfer the programme to the robot board as usual. Figure 67","title":"Transferring the firmware"},{"location":"educational-robotics/robobug-hexapod/transferring-the-firmware/#transferring-the-firmware","text":"After you have finished the mechanical assembly of the robot, the \"Locomotion Firmware\" can be installed on the robot board. This is responsible for the running behaviour of the robot. Check the following before transferring and switching on the robot board: Are all servos connected correctly (polarity)? Are all servos mechanically in the middle? Is the Gamepad controller connected? Is the battery sufficiently charged? Is there enough space available for the robot, even in the event of a malfunction? Now connect the battery to the robot board, if not already done. Connect the robot board (connection \"PRG-M\") to your computer as already done. Then select in the Arduino IDE in the Hexapod examples the programme \"Motion Firmware\" (located under \"Locomotion\"). Transfer the programme to the robot board as usual. Figure 67","title":"Transferring the firmware"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/","text":"Using user boards \u00b6 The robot board can be equipped with different user boards to extend the functionality. Possible user boards are e.g., Arduino UNO, NodeMCU or compatible boards. These can be plugged directly onto the robot board. With the software library described in the next chapter you can send control commands from the user board to the locomotion controller or read values from the locomotion controller. More about this later in the next chapter \"Demo Programmes\". Arduino-UNO \u00b6 The two outer longer pin headers are used for a compatible user board \"Arduino-UNO\". All pins are led out at socket connectors next to it. This allows you to easily access the pins of the board. The pin assignment is printed on the board next to the pin headers and corresponds to that of the board used. Have a look at the software examples. NodeMCU \u00b6 The popular WiFi board with the designation \"NodeMCU\" and the employed ESP8266 WiFi chip can be used on the inner slot as a user board. Also, here all pins are led out on the adjacent socket strips, which makes experimenting easier. Have a look at the software examples. SBC (Single Board Computer) \u00b6 A Raspberry Pi 2 or 3 or any other SBC can be connected to the pin header next to the \"ISP-U\" connection. It is also possible to use radio modules or Bluetooth\u00ae modules as user boards via this connection. This pin header should be regarded universal and represents an interface for proper extensions and developments. Arduino UNO \u00b6 Plug an \"Arduino UNO\" board onto the robot board as shown in Figure 73. Proceed carefully and make sure that the longer pin strips, which are plugged into the sockets of the \"Arduino UNO\" board, are not bent. Also, make sure that all pin header pins are plugged into the sockets of the \"Arduino UNO\" board. It is possible to use almost all Arduino UNO compatible boards. After plugging in the board, you can jump directly to the chapter \"Demo Programmes\". Figure 73 NodeMCU WiFi Board \u00b6 The WiFi board called \"NodeMCU\" and the ESP8266 WiFi chip used can be used as a user board on the inner slot. If you want to extend the robot board with WiFi, you can easily do so with the help of this user board. The examples already include programmes for the NodeMCU board that allow control view from a web browser. Plug a NodeMCU board onto the Hexapod Robot Board as shown in Figure 74. Proceed carefully and make sure that the pin strips are not bent and that all pins are plugged in correctly. After plugging in the board, you can jump directly to the chapter Demo Programs . Figure 74 Caution When buying, make sure that the distance between the pin strips is correct! There are two different versions on the market. One has a Silabs CP2102 as USB chip while the other version has a CH340G. The version with the CH340G has a wider pin spacing and does not fit into the robot board! The NodeMCU board to be used must have a pin strip spacing of 23 mm. Figure 75 Single-Board-Computer (SBCs) and other Boards \u00b6 The robot board offers the possibility to mount an SBC like e.g., a Raspberry Pi \u2154 or compatible via board spacers. SBCs with a different hole spacing can be easily mounted with a self-made adapter board. Here the robot board offers enough space for proper extensions. The pin header shown next to the \"ISP-U\" connection is a universal connection port for SBC or your own extensions. For the wiring between the SBC and the robot board, it is best to use the so-called \"jumpwire\" (socket - socket). Figure 76 Pin description (see inscription below the pins in Figure 76): \u00b6 3.3 V 3.3 V/DC Supply input for the internal level converters of the robot board (Connect 3.3 V from the SBC in this case). If you use a board with a level of 5 V, then connect 5 V instead of 3.3 V (always connect the respective supply voltage; the SBC then supplies the level converters of the robot board with the correct voltage). SCL I\u00b2C clock line (connect SCL of the SBC here, the I\u00b2C bus is then available at sockets J2 and J3) SDA I\u00b2C data cable (here connect SCL of the SBC, the I\u00b2C bus is then available at sockets J2 and J3) GND Ground/GND (negative pole) VCC Output +5 V/DC, 1000 mA from the voltage regulator, here you can connect the supply of the SBC TXDU UART transmission line of the locomotion controller (connect the UART RxD of the SBC here) RXDU UART receiver line of the locomotion controller (connect the UART TxD of the SBC here) SU1 - SU3 These connections lead directly to the pin header SU1, SU2, SU2. These pins can be used freely, e.g., for servos or digital signals. T1 - T2 These pins are connected to the buttons T1 and T2. The buttons are externally equipped with pull-up resistors and provide a high signal when they are not actuated. The pull-up resistors can be deactivated with the board jumpers SJ6 and SJ7. GND Ground/GND (negative pole) Figure 77 shows the robot and a Raspberry Pi 2 mounted on three 25 mm long circuit board spacers. The holes for mounting are already present in the robot board. The connection between the Raspberry Pi and the robot board was made using jumpwire connectors. The cables of the jumpers were placed under the Raspberry Pi to get a clean wiring. Figure 77 \u2192 It's possible that your SBC reacts very sensitively to voltage fluctuations and safe operation is not possible via the battery, which also supplies the leg servos. In this case we recommend to supply the SBC via a small separate power bank. In practice, a battery capacity with a Powerbank of 2000 - 3000 mAh is sufficient to supply the SBC until the Hexapod battery is empty. Sometimes it is also sufficient to support the power supply directly at the SBC with a large capacitor of 2200 \u03bcF (or more). The reason for the unstable operation might come from a battery that is too small with high internal resistance, or from servos with very high current consumption or large current peaks.","title":"Using user boards"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/#using-user-boards","text":"The robot board can be equipped with different user boards to extend the functionality. Possible user boards are e.g., Arduino UNO, NodeMCU or compatible boards. These can be plugged directly onto the robot board. With the software library described in the next chapter you can send control commands from the user board to the locomotion controller or read values from the locomotion controller. More about this later in the next chapter \"Demo Programmes\".","title":"Using user boards"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/#arduino-uno","text":"The two outer longer pin headers are used for a compatible user board \"Arduino-UNO\". All pins are led out at socket connectors next to it. This allows you to easily access the pins of the board. The pin assignment is printed on the board next to the pin headers and corresponds to that of the board used. Have a look at the software examples.","title":"Arduino-UNO"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/#nodemcu","text":"The popular WiFi board with the designation \"NodeMCU\" and the employed ESP8266 WiFi chip can be used on the inner slot as a user board. Also, here all pins are led out on the adjacent socket strips, which makes experimenting easier. Have a look at the software examples.","title":"NodeMCU"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/#sbc-single-board-computer","text":"A Raspberry Pi 2 or 3 or any other SBC can be connected to the pin header next to the \"ISP-U\" connection. It is also possible to use radio modules or Bluetooth\u00ae modules as user boards via this connection. This pin header should be regarded universal and represents an interface for proper extensions and developments.","title":"SBC (Single Board Computer)"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/#arduino-uno_1","text":"Plug an \"Arduino UNO\" board onto the robot board as shown in Figure 73. Proceed carefully and make sure that the longer pin strips, which are plugged into the sockets of the \"Arduino UNO\" board, are not bent. Also, make sure that all pin header pins are plugged into the sockets of the \"Arduino UNO\" board. It is possible to use almost all Arduino UNO compatible boards. After plugging in the board, you can jump directly to the chapter \"Demo Programmes\". Figure 73","title":"Arduino UNO"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/#nodemcu-wifi-board","text":"The WiFi board called \"NodeMCU\" and the ESP8266 WiFi chip used can be used as a user board on the inner slot. If you want to extend the robot board with WiFi, you can easily do so with the help of this user board. The examples already include programmes for the NodeMCU board that allow control view from a web browser. Plug a NodeMCU board onto the Hexapod Robot Board as shown in Figure 74. Proceed carefully and make sure that the pin strips are not bent and that all pins are plugged in correctly. After plugging in the board, you can jump directly to the chapter Demo Programs . Figure 74 Caution When buying, make sure that the distance between the pin strips is correct! There are two different versions on the market. One has a Silabs CP2102 as USB chip while the other version has a CH340G. The version with the CH340G has a wider pin spacing and does not fit into the robot board! The NodeMCU board to be used must have a pin strip spacing of 23 mm. Figure 75","title":"NodeMCU WiFi Board"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/#single-board-computer-sbcs-and-other-boards","text":"The robot board offers the possibility to mount an SBC like e.g., a Raspberry Pi \u2154 or compatible via board spacers. SBCs with a different hole spacing can be easily mounted with a self-made adapter board. Here the robot board offers enough space for proper extensions. The pin header shown next to the \"ISP-U\" connection is a universal connection port for SBC or your own extensions. For the wiring between the SBC and the robot board, it is best to use the so-called \"jumpwire\" (socket - socket). Figure 76","title":"Single-Board-Computer (SBCs) and other Boards"},{"location":"educational-robotics/robobug-hexapod/using_user_boards/#pin-description-see-inscription-below-the-pins-in-figure-76","text":"3.3 V 3.3 V/DC Supply input for the internal level converters of the robot board (Connect 3.3 V from the SBC in this case). If you use a board with a level of 5 V, then connect 5 V instead of 3.3 V (always connect the respective supply voltage; the SBC then supplies the level converters of the robot board with the correct voltage). SCL I\u00b2C clock line (connect SCL of the SBC here, the I\u00b2C bus is then available at sockets J2 and J3) SDA I\u00b2C data cable (here connect SCL of the SBC, the I\u00b2C bus is then available at sockets J2 and J3) GND Ground/GND (negative pole) VCC Output +5 V/DC, 1000 mA from the voltage regulator, here you can connect the supply of the SBC TXDU UART transmission line of the locomotion controller (connect the UART RxD of the SBC here) RXDU UART receiver line of the locomotion controller (connect the UART TxD of the SBC here) SU1 - SU3 These connections lead directly to the pin header SU1, SU2, SU2. These pins can be used freely, e.g., for servos or digital signals. T1 - T2 These pins are connected to the buttons T1 and T2. The buttons are externally equipped with pull-up resistors and provide a high signal when they are not actuated. The pull-up resistors can be deactivated with the board jumpers SJ6 and SJ7. GND Ground/GND (negative pole) Figure 77 shows the robot and a Raspberry Pi 2 mounted on three 25 mm long circuit board spacers. The holes for mounting are already present in the robot board. The connection between the Raspberry Pi and the robot board was made using jumpwire connectors. The cables of the jumpers were placed under the Raspberry Pi to get a clean wiring. Figure 77 \u2192 It's possible that your SBC reacts very sensitively to voltage fluctuations and safe operation is not possible via the battery, which also supplies the leg servos. In this case we recommend to supply the SBC via a small separate power bank. In practice, a battery capacity with a Powerbank of 2000 - 3000 mAh is sufficient to supply the SBC until the Hexapod battery is empty. Sometimes it is also sufficient to support the power supply directly at the SBC with a large capacitor of 2200 \u03bcF (or more). The reason for the unstable operation might come from a battery that is too small with high internal resistance, or from servos with very high current consumption or large current peaks.","title":"Pin description (see inscription below the pins in Figure 76):"},{"location":"images/raspberry/","text":"Here are the pictures","title":"Home"},{"location":"images/tec-egg/","text":"Here are pictures","title":"Home"},{"location":"m5stack/cases/","text":"M5Stack Cases \u00b6 M5Stack Awesome \u00b6 M5Stack-SD-Updater - Customizable menu system for M5Stack - loads apps from the Micro SD card TFT_eSPI - TFT library for the ESP8266 and ESP32 that supports different driver chips M5Widgets - Widgets for the M5Stack M5StackSAM - Simple Applications Menu Arduino Library for M5Stack cfGUI - A simple GUI library for M5Stack (ESP32) GUIslice - A lightweight GUI framework suitable for embedded displays M5ez - The easy way to program on the M5Stack M5Stack MultiApp Advanced - A M5Stack firmware made on PlatformIO M5Stack ESP32 Oscilloscope - A fully functional oscilloscope based on ESP32 M5Stack M5Stack-Avatar - An M5Stack library for rendering avatar faces M5Stack_CrackScreen - Crack your M5Stack!! M5_Shuttle_Run - M5_Shuttle_Run nixietubeM5 - (Fake) Nixie Tube Display on a M5Stack M5Stack_BTCTicker - A small Bitcoin price ticker using an M5Stack (ESP32) and the Coindesk API M5Stack_ETHPrice - Dependence on example Wifi Setting to get ETH Price from Maicoin M5Stack-PacketMonitor - M5Stack ESP32 Packet Monitor M5-FFT - Graphic Equalizer on the M5Stack platform M5Stack_ESP32_radio - Playing mp3 stream out of internet using M5Stack prototype mp3-player-m5stack - MP3 player for M5Stack ArduinoWiFiPhotoBackup - M5STACK Arduino WiFi Photo Backup device M5StackHIDCtrlAltDel - You can send ctrl+alt+del to your PC from M5Stack M5Stack Markdown Web Server - Markdown & icons loaded from an Micro SD card/TF card to run a web page M5Stack-Tetris - Tetris for M5Stack Ported to M5Stack by macsbug - https://macsbug.wordpress.com/ M5Stack_FlappyBird_game - M5Stack FlappyBird Playable M5Stack-SpaceShooter - Space Invaders knock-off for M5Stack M5Stack-Pacman-JoyPSP - Pacman on M5Stack/PSP Joypad, with sounds M5Stack-Thermal-Camera - M5Stack Thermal Camera with AMG8833 thermal sensor M5Stack-3DPrintFiles - Links to files for 3D printing custom case parts for the M5Stack truetype2gfx - Converting fonts from TrueType to Adafruit GFX m5stack-onscreen-keyboard - Full size qwerty keyboard for M5Stack gui for m5stack by micropython - gui for m5stack by micropython M5Stack-Tetris-using-RCWController - Play Tetris on an M5Stack using the RCWController iPhone app to control the action AcornsM5 - Squirrel based OS for the M5Stack, can run apps from SD card M5Stack_TreeView - Tree view menu library M5Stack_LovyanLauncher - M5Stack Launcher by lovyan03 M5Stack_OnScreenKeyboard - full keyboard on M5Stack M5Stack_WebRadio_Avator - WebRadio with Avatar M5Bala_Avatar - Avatar with M5Bala SD_Updater_TestData - testing data for SD Updater M5Stack_Sokoban - Sokoban (Backyard management) with M5Stack Moddable SDK - Javascript SDK TrainDia - Tell me what time leave next train from the neigbor station. M5Stack-MIDI-Module - 8bit NES Synthesizer M5Stack_MMD - 3D rendering by M5Stack M5Stack PC-8801 Emulator! - PC-8801 emulator StickWatch - M5Stick watch m5verifier - to verify for OPENDIME SpaceDefense-m5stack - Shooting game esp32_mmd - Real time rendering animation for MMD m5stack-rfm95 - LoRaWAN node base develop platform m5stack-ble - BLE sample for M5Stack M5StackBLE - BLE sample for M5Stack M5Tube - video player M5Stack-Cam-Viewer - Arduino M5Cam viewer for M5Stack M5Stack_lifegame - Life game m5squeak - m5squeak is a squeak implementation of m5stack microcontroller ESP32-AmigaBoingBall - The famous Amiga Boing Ball Demo on ESP32 ETERNAL_STRIKER - Shooting game for M5Stack Hardware \u00b6 USB Host Shield for M5Stack - USB Host Shield based on MAX3421E Servo Driver Shield for M5Stack - Servo Driver Shield based on PCA9685 Motor Driver Shield for M5Stack - Motor Driver Shield for M5Stack based on L293D MIDI Module for M5Stack - MIDI Module for M5Stack Universal board module for M5Stack - Universal board Module for M5Stack 3GIM adapter board for M5Stack - tabrain 3G communication board adapter for M5Stack M5StackSideBB - Universal board module for M5Stack EEG Sensor\uff08M5STACK-Analog\uff09-PULSE06-M5STACK-A - EEG sensor for M5Stack (Analog output model) EEG Sensor\uff08M5STACK-Serial\uff09-PULSE07-M5STACK-S - EEG sensor for M5Stack (Serial communication model) Use ILI9488 with M5Stack - External Display for M5Stack Production of PROTO MODULE of M5Stack - Proto module for M5Stack USB HOST Module for M5STACK - USB Host module for M5Stack Web site \u00b6 Espressif \u00b6 Espressif ESP32 Datasheet ESP32 tools arduino-esp32 esp-idf esp-idf guide esp-mdf esp-mdf guide esp-adf esp-adf guide esp-iot-solution esp-iot-solution guide knowledge \u00b6 Switch Science Magazine! M5Stack User Group Japan @facebook M5Stack User Group Japan @connpass mgo-tec electronic work Watako-Lab. macsbug Ambient Attic or Garret niconico m-hage niconico M5Stack tag 9 DoF sensor fusion robo8080 applications","title":"Use-Cases"},{"location":"m5stack/cases/#m5stack-cases","text":"","title":"M5Stack Cases"},{"location":"m5stack/cases/#m5stack-awesome","text":"M5Stack-SD-Updater - Customizable menu system for M5Stack - loads apps from the Micro SD card TFT_eSPI - TFT library for the ESP8266 and ESP32 that supports different driver chips M5Widgets - Widgets for the M5Stack M5StackSAM - Simple Applications Menu Arduino Library for M5Stack cfGUI - A simple GUI library for M5Stack (ESP32) GUIslice - A lightweight GUI framework suitable for embedded displays M5ez - The easy way to program on the M5Stack M5Stack MultiApp Advanced - A M5Stack firmware made on PlatformIO M5Stack ESP32 Oscilloscope - A fully functional oscilloscope based on ESP32 M5Stack M5Stack-Avatar - An M5Stack library for rendering avatar faces M5Stack_CrackScreen - Crack your M5Stack!! M5_Shuttle_Run - M5_Shuttle_Run nixietubeM5 - (Fake) Nixie Tube Display on a M5Stack M5Stack_BTCTicker - A small Bitcoin price ticker using an M5Stack (ESP32) and the Coindesk API M5Stack_ETHPrice - Dependence on example Wifi Setting to get ETH Price from Maicoin M5Stack-PacketMonitor - M5Stack ESP32 Packet Monitor M5-FFT - Graphic Equalizer on the M5Stack platform M5Stack_ESP32_radio - Playing mp3 stream out of internet using M5Stack prototype mp3-player-m5stack - MP3 player for M5Stack ArduinoWiFiPhotoBackup - M5STACK Arduino WiFi Photo Backup device M5StackHIDCtrlAltDel - You can send ctrl+alt+del to your PC from M5Stack M5Stack Markdown Web Server - Markdown & icons loaded from an Micro SD card/TF card to run a web page M5Stack-Tetris - Tetris for M5Stack Ported to M5Stack by macsbug - https://macsbug.wordpress.com/ M5Stack_FlappyBird_game - M5Stack FlappyBird Playable M5Stack-SpaceShooter - Space Invaders knock-off for M5Stack M5Stack-Pacman-JoyPSP - Pacman on M5Stack/PSP Joypad, with sounds M5Stack-Thermal-Camera - M5Stack Thermal Camera with AMG8833 thermal sensor M5Stack-3DPrintFiles - Links to files for 3D printing custom case parts for the M5Stack truetype2gfx - Converting fonts from TrueType to Adafruit GFX m5stack-onscreen-keyboard - Full size qwerty keyboard for M5Stack gui for m5stack by micropython - gui for m5stack by micropython M5Stack-Tetris-using-RCWController - Play Tetris on an M5Stack using the RCWController iPhone app to control the action AcornsM5 - Squirrel based OS for the M5Stack, can run apps from SD card M5Stack_TreeView - Tree view menu library M5Stack_LovyanLauncher - M5Stack Launcher by lovyan03 M5Stack_OnScreenKeyboard - full keyboard on M5Stack M5Stack_WebRadio_Avator - WebRadio with Avatar M5Bala_Avatar - Avatar with M5Bala SD_Updater_TestData - testing data for SD Updater M5Stack_Sokoban - Sokoban (Backyard management) with M5Stack Moddable SDK - Javascript SDK TrainDia - Tell me what time leave next train from the neigbor station. M5Stack-MIDI-Module - 8bit NES Synthesizer M5Stack_MMD - 3D rendering by M5Stack M5Stack PC-8801 Emulator! - PC-8801 emulator StickWatch - M5Stick watch m5verifier - to verify for OPENDIME SpaceDefense-m5stack - Shooting game esp32_mmd - Real time rendering animation for MMD m5stack-rfm95 - LoRaWAN node base develop platform m5stack-ble - BLE sample for M5Stack M5StackBLE - BLE sample for M5Stack M5Tube - video player M5Stack-Cam-Viewer - Arduino M5Cam viewer for M5Stack M5Stack_lifegame - Life game m5squeak - m5squeak is a squeak implementation of m5stack microcontroller ESP32-AmigaBoingBall - The famous Amiga Boing Ball Demo on ESP32 ETERNAL_STRIKER - Shooting game for M5Stack","title":"M5Stack Awesome"},{"location":"m5stack/cases/#hardware","text":"USB Host Shield for M5Stack - USB Host Shield based on MAX3421E Servo Driver Shield for M5Stack - Servo Driver Shield based on PCA9685 Motor Driver Shield for M5Stack - Motor Driver Shield for M5Stack based on L293D MIDI Module for M5Stack - MIDI Module for M5Stack Universal board module for M5Stack - Universal board Module for M5Stack 3GIM adapter board for M5Stack - tabrain 3G communication board adapter for M5Stack M5StackSideBB - Universal board module for M5Stack EEG Sensor\uff08M5STACK-Analog\uff09-PULSE06-M5STACK-A - EEG sensor for M5Stack (Analog output model) EEG Sensor\uff08M5STACK-Serial\uff09-PULSE07-M5STACK-S - EEG sensor for M5Stack (Serial communication model) Use ILI9488 with M5Stack - External Display for M5Stack Production of PROTO MODULE of M5Stack - Proto module for M5Stack USB HOST Module for M5STACK - USB Host module for M5Stack","title":"Hardware"},{"location":"m5stack/cases/#web-site","text":"","title":"Web site"},{"location":"m5stack/cases/#espressif","text":"Espressif ESP32 Datasheet ESP32 tools arduino-esp32 esp-idf esp-idf guide esp-mdf esp-mdf guide esp-adf esp-adf guide esp-iot-solution esp-iot-solution guide","title":"Espressif"},{"location":"m5stack/cases/#knowledge","text":"Switch Science Magazine! M5Stack User Group Japan @facebook M5Stack User Group Japan @connpass mgo-tec electronic work Watako-Lab. macsbug Ambient Attic or Garret niconico m-hage niconico M5Stack tag 9 DoF sensor fusion robo8080 applications","title":"knowledge"},{"location":"m5stack/overview/","text":"M5Stack Products \u00b6 M5STACK Core \u00b6 M5Core BASIC M5Core GRAY M5Core FIRE M5STACK Kit \u00b6 M5GO Kit FACES Kit M5STACK Module \u00b6 GPS BATTERY PROTO M5STACK Unit \u00b6 M5Camera M5STACK Base \u00b6 BTC","title":"Overview"},{"location":"m5stack/overview/#m5stack-products","text":"","title":"M5Stack Products"},{"location":"m5stack/overview/#m5stack-core","text":"M5Core BASIC M5Core GRAY M5Core FIRE","title":"M5STACK Core"},{"location":"m5stack/overview/#m5stack-kit","text":"M5GO Kit FACES Kit","title":"M5STACK Kit"},{"location":"m5stack/overview/#m5stack-module","text":"GPS BATTERY PROTO","title":"M5STACK Module"},{"location":"m5stack/overview/#m5stack-unit","text":"M5Camera","title":"M5STACK Unit"},{"location":"m5stack/overview/#m5stack-base","text":"BTC","title":"M5STACK Base"},{"location":"m5stack/api/button/","text":"Button \u00b6 read() \u00b6 Syntax: 1 uint8_t read (); Description: This function returns reading the state of the button directly. 1: pressed, 0: released. Example: 1 2 3 4 5 6 7 8 9 10 11 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . Lcd . setCursor ( 0 , 0 ); M5 . Lcd . print ( \"Button A Status: \" ); M5 . Lcd . println ( M5 . BtnA . read ()); } isPressed() \u00b6 Syntax: 1 uint8_t isPressed (); Description: This function returns the state of the button the last time Button.read() was called. 1: pressed, 0: released. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . update (); // need to call update() M5 . Lcd . setCursor ( 0 , 0 ); if ( M5 . BtnA . isPressed ()) { M5 . Lcd . printf ( \"A button is pressed.\" ); } else { M5 . Lcd . printf ( \"A button is released.\" ); } } wasPressed() \u00b6 Syntax: 1 uint8_t wasPressed (); Description: This function returns 1 only once each time the button is pressed. 1: pressed, 0: released. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . update (); M5 . Lcd . clear (); M5 . Lcd . setCursor ( 0 , 0 ); if ( M5 . BtnA . wasPressed ()) { M5 . Lcd . printf ( \"Button A was pressed.\" ); delay ( 1000 ); } } pressedFor() \u00b6 Syntax: 1 uint8_t pressedFor ( uint32_t ms ); Description: This function returns 1 if button has been pressed for more than specified time. 1: pressed, 0: released. argument description type ms pressing time (ms) uint32_t Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . update (); M5 . Lcd . clear (); M5 . Lcd . setCursor ( 0 , 0 ); if ( M5 . BtnA . pressedFor ( 2000 )) { M5 . Lcd . printf ( \"Button A was pressed for more than 2 seconds.\" ); delay ( 1000 ); } }","title":"Button"},{"location":"m5stack/api/button/#button","text":"","title":"Button"},{"location":"m5stack/api/button/#read","text":"Syntax: 1 uint8_t read (); Description: This function returns reading the state of the button directly. 1: pressed, 0: released. Example: 1 2 3 4 5 6 7 8 9 10 11 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . Lcd . setCursor ( 0 , 0 ); M5 . Lcd . print ( \"Button A Status: \" ); M5 . Lcd . println ( M5 . BtnA . read ()); }","title":"read()"},{"location":"m5stack/api/button/#ispressed","text":"Syntax: 1 uint8_t isPressed (); Description: This function returns the state of the button the last time Button.read() was called. 1: pressed, 0: released. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . update (); // need to call update() M5 . Lcd . setCursor ( 0 , 0 ); if ( M5 . BtnA . isPressed ()) { M5 . Lcd . printf ( \"A button is pressed.\" ); } else { M5 . Lcd . printf ( \"A button is released.\" ); } }","title":"isPressed()"},{"location":"m5stack/api/button/#waspressed","text":"Syntax: 1 uint8_t wasPressed (); Description: This function returns 1 only once each time the button is pressed. 1: pressed, 0: released. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . update (); M5 . Lcd . clear (); M5 . Lcd . setCursor ( 0 , 0 ); if ( M5 . BtnA . wasPressed ()) { M5 . Lcd . printf ( \"Button A was pressed.\" ); delay ( 1000 ); } }","title":"wasPressed()"},{"location":"m5stack/api/button/#pressedfor","text":"Syntax: 1 uint8_t pressedFor ( uint32_t ms ); Description: This function returns 1 if button has been pressed for more than specified time. 1: pressed, 0: released. argument description type ms pressing time (ms) uint32_t Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . update (); M5 . Lcd . clear (); M5 . Lcd . setCursor ( 0 , 0 ); if ( M5 . BtnA . pressedFor ( 2000 )) { M5 . Lcd . printf ( \"Button A was pressed for more than 2 seconds.\" ); delay ( 1000 ); } }","title":"pressedFor()"},{"location":"m5stack/api/lcd/","text":"LCD \u00b6 The screen pixel is 320x240, with the top left corner of the screen as the origin (0,0) fillScreen() \u00b6 Syntax: 1 fillScreen ( uint16_t color ); Function: Fill the entire screen with the specified color. Param Description color the color to be filled Example: 1 2 3 4 5 #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillScreen ( RED ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.fillScreen(lcd.RED) ``` \u2192 setTextColor() \u00b6 Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 setTextColor ( uint16_t color , uint16_t ``` backgroundcolor ); ** Function : Set the foreground color and background color of the displayed text . ** | Param | Description | | --- | --- | | color | the color of text | | backgroundcolor | the background color of text | * If backgroundcolor is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . setTextColor ( RED ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.setTextColor(lcd.RED) lcd.setTextColor(lcd.ORANGE, lcd.DARKCYAN) ``` \u2192 setCursor() \u00b6 Syntax: 1 setCursor ( uint16_t x0 , uint16_t y0 ); Function: Move the cursor to (x0, y0). Example: 1 2 3 4 5 6 #include <M5Stack.h> M5 . begin (); M5 . Lcd . setCursor ( 100 , 100 ); M5 . Lcd . print ( \"Hello\" ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawPixel(22,22,lcd.RED) ``` \u2192 drawPixel() \u00b6 Syntax: 1 drawPixel ( int16_t x , int16_t y , uint16_t color ); Function: Draw a point at position (x, y). Param Description color color value If color is not given, current background color is used Example: 1 2 3 4 5 #include <M5Stack.h> M5 . begin (); M5 . Lcd . drawPixel ( 22 , 22 , RED ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawPixel(22,22,lcd.RED) ``` \u2192 drawLine() \u00b6 Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 drawLine ( int16_t x0 , int16_t y0 , int16_t x1 , int16_t ``` y1 , uint16_t color ); ** Function : Draw the line from point ( x , y ) to point ( x1 , y1 ). ** | Param | Description | | --- | --- | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . drawLine ( 0 , 0 , 12 , 12 , WHITE ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192 drawTriangle() \u00b6 Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 drawTriangle ( int16_t x0 , int16_t y0 , int16_t x1 , ``` int16_t y1 , int16_t x2 , int16_t y2 , uint16_t color ); ** Function : Draw the triangel between points ( x , y ), ( x1 , y1 ) and ( x2 , y2 ). ** | Param | Description | | --- | --- | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . drawTriangle ( 22 , 22 , 69 , 98 , 51 , 22 , RED ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192 fillTriangle() \u00b6 Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fillTriangle ( int16_t x0 , int16_t y0 , int16_t x1 , ``` int16_t y1 , int16_t x2 , int16_t y2 , uint16_t color ); ** Function : Fill the triangel between points ( x , y ), ( x1 , y1 ) and ( x2 , y2 ). ** | Param | Description | | --- | --- | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillTriangle ( 22 , 22 , 69 , 98 , 51 , 22 , RED ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192 drawRect() \u00b6 Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 drawRect ( int16_t x , int16_t y , int16_t w , int16_t h , ``` uint16_t color ); ** Function : Draw the rectangle from the upper left point at ( x , y ) and width and height . ** | Param | Description | | --- | --- | | w | display phisical width in pixels ( display \u2019 s smaller dimension ) | | h | display phisical height in pixels ( display \u2019 s larger dimension ) | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . drawRect ( 180 , 12 , 122 , 10 , BLUE ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192 fillRect() \u00b6 Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fillRect ( int16_t x , int16_t y , int16_t w , int16_t h , ``` uint16_t color ); ** Function : Fill the rectangle from the upper left point at ( x , y ) and width and height . ** | Param | Description | | --- | --- | | w | display phisical width in pixels ( display \u2019 s smaller dimension ) | | h | display phisical height in pixels ( display \u2019 s larger dimension ) | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillRect ( 180 , 12 , 122 , 10 , BLUE ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192 drawRoundRect() \u00b6 Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 drawRoundRect ( int16_t x0 , int16_t y0 , int16_t w , ``` int16_t h , int16_t radius , uint16_t color ); ** Function : Draw the rectangle with rounded corners from the upper left point at ( x , y ) and width and height . Corner radius is given by radius argument . ** | Param | Description | | --- | --- | | w | display phisical width in pixels ( display \u2019 s smaller dimension ) | | h | display phisical height in pixels ( display \u2019 s larger dimension ) | | radius | the radius of circle | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillRoundRect ( 180 , 70 , 122 , 10 , 4 , BLUE ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192 print() \u00b6 Syntax: 1 print (); Function: Start printing text at the current position of the screen. The specified content is printed in the foreground color by default. Example: 1 2 3 4 5 #include <M5Stack.h> M5 . begin (); M5 . Lcd . print ( \"this is a print text function\" ); <!-- ```python MicroPython \u00b6 from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192 Usage \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillScreen ( BLACK ) # set the default background color M5 . Lcd . drawLine ( 0 , 0 , WHITE ); M5 . Lcd . drawTriangle ( 22 , 22 , 69 , 98 , 51 , 22 , RED ); M5 . Lcd . fillTriangle ( 122 , 122 , 169 , 198 , 151 , 182 , RED ); M5 . Lcd . drawRect ( 180 , 12 , 122 , 10 , BLUE ); M5 . Lcd . fillRect ( 180 , 30 , 122 , 10 , BLUE ); M5 . Lcd . drawRoundRect ( 180 , 50 , 122 , 10 , 4 , BLUE ); M5 . Lcd . fillRoundRect ( 180 , 70 , 122 , 10 , 4 , BLUE ); M5 . Lcd . print ( \"this is a print text function\" );","title":"LCD"},{"location":"m5stack/api/lcd/#lcd","text":"The screen pixel is 320x240, with the top left corner of the screen as the origin (0,0)","title":"LCD"},{"location":"m5stack/api/lcd/#fillscreen","text":"Syntax: 1 fillScreen ( uint16_t color ); Function: Fill the entire screen with the specified color. Param Description color the color to be filled Example: 1 2 3 4 5 #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillScreen ( RED ); <!-- ```python","title":"fillScreen()"},{"location":"m5stack/api/lcd/#micropython","text":"from m5stack import * from m5ui import * lcd.fillScreen(lcd.RED) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#settextcolor","text":"Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 setTextColor ( uint16_t color , uint16_t ``` backgroundcolor ); ** Function : Set the foreground color and background color of the displayed text . ** | Param | Description | | --- | --- | | color | the color of text | | backgroundcolor | the background color of text | * If backgroundcolor is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . setTextColor ( RED ); <!-- ```python","title":"setTextColor()"},{"location":"m5stack/api/lcd/#micropython_1","text":"from m5stack import * from m5ui import * lcd.setTextColor(lcd.RED) lcd.setTextColor(lcd.ORANGE, lcd.DARKCYAN) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#setcursor","text":"Syntax: 1 setCursor ( uint16_t x0 , uint16_t y0 ); Function: Move the cursor to (x0, y0). Example: 1 2 3 4 5 6 #include <M5Stack.h> M5 . begin (); M5 . Lcd . setCursor ( 100 , 100 ); M5 . Lcd . print ( \"Hello\" ); <!-- ```python","title":"setCursor()"},{"location":"m5stack/api/lcd/#micropython_2","text":"from m5stack import * from m5ui import * lcd.drawPixel(22,22,lcd.RED) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#drawpixel","text":"Syntax: 1 drawPixel ( int16_t x , int16_t y , uint16_t color ); Function: Draw a point at position (x, y). Param Description color color value If color is not given, current background color is used Example: 1 2 3 4 5 #include <M5Stack.h> M5 . begin (); M5 . Lcd . drawPixel ( 22 , 22 , RED ); <!-- ```python","title":"drawPixel()"},{"location":"m5stack/api/lcd/#micropython_3","text":"from m5stack import * from m5ui import * lcd.drawPixel(22,22,lcd.RED) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#drawline","text":"Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 drawLine ( int16_t x0 , int16_t y0 , int16_t x1 , int16_t ``` y1 , uint16_t color ); ** Function : Draw the line from point ( x , y ) to point ( x1 , y1 ). ** | Param | Description | | --- | --- | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . drawLine ( 0 , 0 , 12 , 12 , WHITE ); <!-- ```python","title":"drawLine()"},{"location":"m5stack/api/lcd/#micropython_4","text":"from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#drawtriangle","text":"Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 drawTriangle ( int16_t x0 , int16_t y0 , int16_t x1 , ``` int16_t y1 , int16_t x2 , int16_t y2 , uint16_t color ); ** Function : Draw the triangel between points ( x , y ), ( x1 , y1 ) and ( x2 , y2 ). ** | Param | Description | | --- | --- | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . drawTriangle ( 22 , 22 , 69 , 98 , 51 , 22 , RED ); <!-- ```python","title":"drawTriangle()"},{"location":"m5stack/api/lcd/#micropython_5","text":"from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#filltriangle","text":"Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fillTriangle ( int16_t x0 , int16_t y0 , int16_t x1 , ``` int16_t y1 , int16_t x2 , int16_t y2 , uint16_t color ); ** Function : Fill the triangel between points ( x , y ), ( x1 , y1 ) and ( x2 , y2 ). ** | Param | Description | | --- | --- | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillTriangle ( 22 , 22 , 69 , 98 , 51 , 22 , RED ); <!-- ```python","title":"fillTriangle()"},{"location":"m5stack/api/lcd/#micropython_6","text":"from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#drawrect","text":"Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 drawRect ( int16_t x , int16_t y , int16_t w , int16_t h , ``` uint16_t color ); ** Function : Draw the rectangle from the upper left point at ( x , y ) and width and height . ** | Param | Description | | --- | --- | | w | display phisical width in pixels ( display \u2019 s smaller dimension ) | | h | display phisical height in pixels ( display \u2019 s larger dimension ) | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . drawRect ( 180 , 12 , 122 , 10 , BLUE ); <!-- ```python","title":"drawRect()"},{"location":"m5stack/api/lcd/#micropython_7","text":"from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#fillrect","text":"Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fillRect ( int16_t x , int16_t y , int16_t w , int16_t h , ``` uint16_t color ); ** Function : Fill the rectangle from the upper left point at ( x , y ) and width and height . ** | Param | Description | | --- | --- | | w | display phisical width in pixels ( display \u2019 s smaller dimension ) | | h | display phisical height in pixels ( display \u2019 s larger dimension ) | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillRect ( 180 , 12 , 122 , 10 , BLUE ); <!-- ```python","title":"fillRect()"},{"location":"m5stack/api/lcd/#micropython_8","text":"from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#drawroundrect","text":"Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 drawRoundRect ( int16_t x0 , int16_t y0 , int16_t w , ``` int16_t h , int16_t radius , uint16_t color ); ** Function : Draw the rectangle with rounded corners from the upper left point at ( x , y ) and width and height . Corner radius is given by radius argument . ** | Param | Description | | --- | --- | | w | display phisical width in pixels ( display \u2019 s smaller dimension ) | | h | display phisical height in pixels ( display \u2019 s larger dimension ) | | radius | the radius of circle | | color | color value | * If color is not given , current background color is used * ** Example : ** ``` arduino #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillRoundRect ( 180 , 70 , 122 , 10 , 4 , BLUE ); <!-- ```python","title":"drawRoundRect()"},{"location":"m5stack/api/lcd/#micropython_9","text":"from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#print","text":"Syntax: 1 print (); Function: Start printing text at the current position of the screen. The specified content is printed in the foreground color by default. Example: 1 2 3 4 5 #include <M5Stack.h> M5 . begin (); M5 . Lcd . print ( \"this is a print text function\" ); <!-- ```python","title":"print()"},{"location":"m5stack/api/lcd/#micropython_10","text":"from m5stack import * from m5ui import * lcd.drawLine(0,0,12,12,lcd.WHITE) ``` \u2192","title":"MicroPython"},{"location":"m5stack/api/lcd/#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 #include <M5Stack.h> M5 . begin (); M5 . Lcd . fillScreen ( BLACK ) # set the default background color M5 . Lcd . drawLine ( 0 , 0 , WHITE ); M5 . Lcd . drawTriangle ( 22 , 22 , 69 , 98 , 51 , 22 , RED ); M5 . Lcd . fillTriangle ( 122 , 122 , 169 , 198 , 151 , 182 , RED ); M5 . Lcd . drawRect ( 180 , 12 , 122 , 10 , BLUE ); M5 . Lcd . fillRect ( 180 , 30 , 122 , 10 , BLUE ); M5 . Lcd . drawRoundRect ( 180 , 50 , 122 , 10 , 4 , BLUE ); M5 . Lcd . fillRoundRect ( 180 , 70 , 122 , 10 , 4 , BLUE ); M5 . Lcd . print ( \"this is a print text function\" );","title":"Usage"},{"location":"m5stack/api/mpu9250/","text":"IMU Sensor MPU9250 \u00b6 IMU The MPU9250 is a multi-chip module that integrates two chips. One chip is the MPU6500, which consists of a 3-axis gyroscope and a 3-axis accelerometer. The other is the AK8963 is a 3-axis magnetometer. initMPU9250() \u00b6 Syntax: 1 void initMPU9250 (); Description: This function initialize MPU6500 chip. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initMPU9250 (); // this line must be after Wire.begin() } void loop () { } initAK8963() \u00b6 Syntax: 1 void initAK8963 ( float * destination ); Description: This function initialize AK8963 chip. Argument Description Type destination for AK8963 Calibration Value float * Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initAK8963 ( IMU . magCalibration ); M5 . Lcd . println ( \"AK8963 initialized for active data mode....\" ); if ( Serial ) { M5 . Lcd . println ( \"Calibration values: \" ); M5 . Lcd . print ( \"X-Axis sensitivity adjustment value \" ); M5 . Lcd . println ( IMU . magCalibration [ 0 ], 2 ); M5 . Lcd . print ( \"Y-Axis sensitivity adjustment value \" ); M5 . Lcd . println ( IMU . magCalibration [ 1 ], 2 ); M5 . Lcd . print ( \"Z-Axis sensitivity adjustment value \" ); M5 . Lcd . println ( IMU . magCalibration [ 2 ], 2 ); } } void loop () { } calibrateMPU9250() \u00b6 Syntax: 1 void calibrateMPU9250 ( float * gyroBias , float * accelBias ); Description: This function calcurate offset values of gyro and accelerometer. Argument Description Type gyroBias gyro offset float * accelBias accel offset float * Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initMPU9250 (); IMU . calibrateMPU9250 ( IMU . gyroBias , IMU . accelBias ); M5 . Lcd . fillScreen ( BLACK ); M5 . Lcd . setTextSize ( 1 ); M5 . Lcd . setCursor ( 0 , 0 ); M5 . Lcd . print ( \"MPU9250 bias\" ); M5 . Lcd . setCursor ( 0 , 16 ); M5 . Lcd . print ( \" x y z \" ); M5 . Lcd . setCursor ( 0 , 32 ); M5 . Lcd . print (( int )( 1000 * IMU . accelBias [ 0 ])); M5 . Lcd . setCursor ( 32 , 32 ); M5 . Lcd . print (( int )( 1000 * IMU . accelBias [ 1 ])); M5 . Lcd . setCursor ( 64 , 32 ); M5 . Lcd . print (( int )( 1000 * IMU . accelBias [ 2 ])); M5 . Lcd . setCursor ( 96 , 32 ); M5 . Lcd . print ( \"mg\" ); M5 . Lcd . setCursor ( 0 , 48 ); M5 . Lcd . print ( IMU . gyroBias [ 0 ], 1 ); M5 . Lcd . setCursor ( 32 , 48 ); M5 . Lcd . print ( IMU . gyroBias [ 1 ], 1 ); M5 . Lcd . setCursor ( 64 , 48 ); M5 . Lcd . print ( IMU . gyroBias [ 2 ], 1 ); M5 . Lcd . setCursor ( 96 , 48 ); M5 . Lcd . print ( \"o/s\" ); } void loop () { } readByte() \u00b6 Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 uint8_t readByte ( uint8_t address , uint8_t subAddress ) ``` ; ** Description : ** This function reads a byte data from specified register of MPU9250 . | Argument | Description | Type | | --- | --- | -- | | address | ( MPU9250 / AK8963 ) I2C address | uint8_t | | subAddress | register address | uint8_t | ** Example : ** ``` arduino #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); uint8_t id = IMU . readByte ( MPU9250_ADDRESS , WHO_AM_I_MPU9250 ); M5 . Lcd . print ( \"MPU9250 I AM 0x\" ); M5 . Lcd . print ( id , HEX ); } void loop () { } readGyroData() \u00b6 Syntax: 1 void readGyroData ( int16_t * destination ); Description: This function reads the value of 3-axis gyro sensor. Argument Description Type destination read gyro values int16_t * Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initMPU9250 (); IMU . calibrateMPU9250 ( IMU . gyroBias , IMU . accelBias ); } void loop () { // If intPin goes high, all data registers have new data // On interrupt, check if data ready interrupt if ( IMU . readByte ( MPU9250_ADDRESS , INT_STATUS ) & 0x01 ) { M5 . Lcd . clear (); M5 . Lcd . setCursor ( 0 , 0 ); IMU . readGyroData ( IMU . gyroCount ); // Read the x/y/z adc values IMU . getGres (); // get Gyro scales saved to \"gRes\" IMU . gx = ( float ) IMU . gyroCount [ 0 ] * IMU . gRes ; IMU . gy = ( float ) IMU . gyroCount [ 1 ] * IMU . gRes ; IMU . gz = ( float ) IMU . gyroCount [ 2 ] * IMU . gRes ; M5 . Lcd . print ( \"X-gyro rate: \" ); M5 . Lcd . print ( IMU . gx , 3 ); M5 . Lcd . println ( \" degrees/sec \" ); M5 . Lcd . print ( \"Y-gyro rate: \" ); M5 . Lcd . print ( IMU . gy , 3 ); M5 . Lcd . println ( \" degrees/sec \" ); M5 . Lcd . print ( \"Z-gyro rate: \" ); M5 . Lcd . print ( IMU . gz , 3 ); M5 . Lcd . println ( \" degrees/sec\" ); } delay ( 500 ); } readAccelData() \u00b6 Syntax: 1 void readAccelData ( int16_t * destination ); Description: This function reads the value of 3-axis accelerate sensor. Argument Description Type destination read accelerate values int16_t * Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initMPU9250 (); IMU . calibrateMPU9250 ( IMU . gyroBias , IMU . accelBias ); } void loop () { // If intPin goes high, all data registers have new data // On interrupt, check if data ready interrupt if ( IMU . readByte ( MPU9250_ADDRESS , INT_STATUS ) & 0x01 ) { M5 . Lcd . clear (); M5 . Lcd . setCursor ( 0 , 0 ); IMU . readAccelData ( IMU . accelCount ); IMU . getAres (); // get accelerometer scales saved to \"aRes\" IMU . ax = ( float ) IMU . accelCount [ 0 ] * IMU . aRes ; // - accelBias[0]; IMU . ay = ( float ) IMU . accelCount [ 1 ] * IMU . aRes ; // - accelBias[1]; IMU . az = ( float ) IMU . accelCount [ 2 ] * IMU . aRes ; // - accelBias[2]; M5 . Lcd . print ( \"X-acceleration: \" ); M5 . Lcd . print ( 1000 * IMU . ax ); M5 . Lcd . println ( \" mg \" ); M5 . Lcd . print ( \"Y-acceleration: \" ); M5 . Lcd . print ( 1000 * IMU . ay ); M5 . Lcd . println ( \" mg \" ); M5 . Lcd . print ( \"Z-acceleration: \" ); M5 . Lcd . print ( 1000 * IMU . az ); M5 . Lcd . println ( \" mg \" ); } delay ( 500 ); }","title":"MPU9250"},{"location":"m5stack/api/mpu9250/#imu-sensor-mpu9250","text":"IMU The MPU9250 is a multi-chip module that integrates two chips. One chip is the MPU6500, which consists of a 3-axis gyroscope and a 3-axis accelerometer. The other is the AK8963 is a 3-axis magnetometer.","title":"IMU Sensor MPU9250"},{"location":"m5stack/api/mpu9250/#initmpu9250","text":"Syntax: 1 void initMPU9250 (); Description: This function initialize MPU6500 chip. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initMPU9250 (); // this line must be after Wire.begin() } void loop () { }","title":"initMPU9250()"},{"location":"m5stack/api/mpu9250/#initak8963","text":"Syntax: 1 void initAK8963 ( float * destination ); Description: This function initialize AK8963 chip. Argument Description Type destination for AK8963 Calibration Value float * Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initAK8963 ( IMU . magCalibration ); M5 . Lcd . println ( \"AK8963 initialized for active data mode....\" ); if ( Serial ) { M5 . Lcd . println ( \"Calibration values: \" ); M5 . Lcd . print ( \"X-Axis sensitivity adjustment value \" ); M5 . Lcd . println ( IMU . magCalibration [ 0 ], 2 ); M5 . Lcd . print ( \"Y-Axis sensitivity adjustment value \" ); M5 . Lcd . println ( IMU . magCalibration [ 1 ], 2 ); M5 . Lcd . print ( \"Z-Axis sensitivity adjustment value \" ); M5 . Lcd . println ( IMU . magCalibration [ 2 ], 2 ); } } void loop () { }","title":"initAK8963()"},{"location":"m5stack/api/mpu9250/#calibratempu9250","text":"Syntax: 1 void calibrateMPU9250 ( float * gyroBias , float * accelBias ); Description: This function calcurate offset values of gyro and accelerometer. Argument Description Type gyroBias gyro offset float * accelBias accel offset float * Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initMPU9250 (); IMU . calibrateMPU9250 ( IMU . gyroBias , IMU . accelBias ); M5 . Lcd . fillScreen ( BLACK ); M5 . Lcd . setTextSize ( 1 ); M5 . Lcd . setCursor ( 0 , 0 ); M5 . Lcd . print ( \"MPU9250 bias\" ); M5 . Lcd . setCursor ( 0 , 16 ); M5 . Lcd . print ( \" x y z \" ); M5 . Lcd . setCursor ( 0 , 32 ); M5 . Lcd . print (( int )( 1000 * IMU . accelBias [ 0 ])); M5 . Lcd . setCursor ( 32 , 32 ); M5 . Lcd . print (( int )( 1000 * IMU . accelBias [ 1 ])); M5 . Lcd . setCursor ( 64 , 32 ); M5 . Lcd . print (( int )( 1000 * IMU . accelBias [ 2 ])); M5 . Lcd . setCursor ( 96 , 32 ); M5 . Lcd . print ( \"mg\" ); M5 . Lcd . setCursor ( 0 , 48 ); M5 . Lcd . print ( IMU . gyroBias [ 0 ], 1 ); M5 . Lcd . setCursor ( 32 , 48 ); M5 . Lcd . print ( IMU . gyroBias [ 1 ], 1 ); M5 . Lcd . setCursor ( 64 , 48 ); M5 . Lcd . print ( IMU . gyroBias [ 2 ], 1 ); M5 . Lcd . setCursor ( 96 , 48 ); M5 . Lcd . print ( \"o/s\" ); } void loop () { }","title":"calibrateMPU9250()"},{"location":"m5stack/api/mpu9250/#readbyte","text":"Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 uint8_t readByte ( uint8_t address , uint8_t subAddress ) ``` ; ** Description : ** This function reads a byte data from specified register of MPU9250 . | Argument | Description | Type | | --- | --- | -- | | address | ( MPU9250 / AK8963 ) I2C address | uint8_t | | subAddress | register address | uint8_t | ** Example : ** ``` arduino #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); uint8_t id = IMU . readByte ( MPU9250_ADDRESS , WHO_AM_I_MPU9250 ); M5 . Lcd . print ( \"MPU9250 I AM 0x\" ); M5 . Lcd . print ( id , HEX ); } void loop () { }","title":"readByte()"},{"location":"m5stack/api/mpu9250/#readgyrodata","text":"Syntax: 1 void readGyroData ( int16_t * destination ); Description: This function reads the value of 3-axis gyro sensor. Argument Description Type destination read gyro values int16_t * Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initMPU9250 (); IMU . calibrateMPU9250 ( IMU . gyroBias , IMU . accelBias ); } void loop () { // If intPin goes high, all data registers have new data // On interrupt, check if data ready interrupt if ( IMU . readByte ( MPU9250_ADDRESS , INT_STATUS ) & 0x01 ) { M5 . Lcd . clear (); M5 . Lcd . setCursor ( 0 , 0 ); IMU . readGyroData ( IMU . gyroCount ); // Read the x/y/z adc values IMU . getGres (); // get Gyro scales saved to \"gRes\" IMU . gx = ( float ) IMU . gyroCount [ 0 ] * IMU . gRes ; IMU . gy = ( float ) IMU . gyroCount [ 1 ] * IMU . gRes ; IMU . gz = ( float ) IMU . gyroCount [ 2 ] * IMU . gRes ; M5 . Lcd . print ( \"X-gyro rate: \" ); M5 . Lcd . print ( IMU . gx , 3 ); M5 . Lcd . println ( \" degrees/sec \" ); M5 . Lcd . print ( \"Y-gyro rate: \" ); M5 . Lcd . print ( IMU . gy , 3 ); M5 . Lcd . println ( \" degrees/sec \" ); M5 . Lcd . print ( \"Z-gyro rate: \" ); M5 . Lcd . print ( IMU . gz , 3 ); M5 . Lcd . println ( \" degrees/sec\" ); } delay ( 500 ); }","title":"readGyroData()"},{"location":"m5stack/api/mpu9250/#readacceldata","text":"Syntax: 1 void readAccelData ( int16_t * destination ); Description: This function reads the value of 3-axis accelerate sensor. Argument Description Type destination read accelerate values int16_t * Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <M5Stack.h> #include \"utility/MPU9250.h\" MPU9250 IMU ; // new a MPU9250 object void setup () { M5 . begin (); Wire . begin (); IMU . initMPU9250 (); IMU . calibrateMPU9250 ( IMU . gyroBias , IMU . accelBias ); } void loop () { // If intPin goes high, all data registers have new data // On interrupt, check if data ready interrupt if ( IMU . readByte ( MPU9250_ADDRESS , INT_STATUS ) & 0x01 ) { M5 . Lcd . clear (); M5 . Lcd . setCursor ( 0 , 0 ); IMU . readAccelData ( IMU . accelCount ); IMU . getAres (); // get accelerometer scales saved to \"aRes\" IMU . ax = ( float ) IMU . accelCount [ 0 ] * IMU . aRes ; // - accelBias[0]; IMU . ay = ( float ) IMU . accelCount [ 1 ] * IMU . aRes ; // - accelBias[1]; IMU . az = ( float ) IMU . accelCount [ 2 ] * IMU . aRes ; // - accelBias[2]; M5 . Lcd . print ( \"X-acceleration: \" ); M5 . Lcd . print ( 1000 * IMU . ax ); M5 . Lcd . println ( \" mg \" ); M5 . Lcd . print ( \"Y-acceleration: \" ); M5 . Lcd . print ( 1000 * IMU . ay ); M5 . Lcd . println ( \" mg \" ); M5 . Lcd . print ( \"Z-acceleration: \" ); M5 . Lcd . print ( 1000 * IMU . az ); M5 . Lcd . println ( \" mg \" ); } delay ( 500 ); }","title":"readAccelData()"},{"location":"m5stack/api/overview/","text":"Arduino API \u00b6 M5Core \u00b6 System Speaker LCD Button IMU sensor(MPU9250) TF card Power","title":"Overview"},{"location":"m5stack/api/overview/#arduino-api","text":"","title":"Arduino API"},{"location":"m5stack/api/overview/#m5core","text":"System Speaker LCD Button IMU sensor(MPU9250) TF card Power","title":"M5Core"},{"location":"m5stack/api/power/","text":"Power \u00b6 setPowerBoostKeepOn() \u00b6 Syntax: 1 bool setPowerBoostKeepOn ( bool en ) Description: This function sets/unsets always boost output mode. Function argument true: Turn on always boost output mode, false: Turn off always boost output mode. Function return value true: Control success, false: Control failure. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool setPowerBoostKeepOn ( bool en ){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); Wire . endTransmission (); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); if ( en ) Wire . write ( data | BOOST_OUT_BIT ); else Wire . write ( data & ( ~ BOOST_OUT_BIT )); Wire . endTransmission (); return true ; } return false ; } setKeepLightLoad() \u00b6 Syntax: 1 bool setKeepLightLoad ( bool en ) Description: This function sets/unsets to disable the automatic shutdown. Function argument true: When the current is too small, IP5306 will not automatically shutdown, false: When the current is too small, IP5306 will automatically shutdown. Function return value true: Control success, false: Control failure. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool setKeepLightLoad ( bool en ) { uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); Wire . endTransmission (); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); if ( ! en ) Wire . write ( data | LIGHT_LOAD_BIT ); else Wire . write ( data & ( ~ LIGHT_LOAD_BIT )); Wire . endTransmission (); return true ; } return false ; } setCharge() \u00b6 Syntax: 1 bool setCharge ( bool en ) Description: This function sets/unsets charge mode. When the battery is fully charged, try set charge enable->disable->enable, It can be recharged. Function argument true: Start charging, false: Stop charging. Function return value true: Control success, false: Control failure. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool setCharge ( bool en ){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); Wire . endTransmission (); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); if ( en ) Wire . write ( data | CHARGE_OUT_BIT ); else Wire . write ( data & ( ~ CHARGE_OUT_BIT )); Wire . endTransmission (); return true ; } return false ; } isChargeFull() \u00b6 Syntax: 1 bool isChargeFull () Description: This function checks if the battery is fully charged. Function argument No argument. Function return value true: Full charged, false: Not full charged. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 bool isChargeFull (){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_READ1 ); Wire . endTransmission ( false ); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); if ( data & ( 1 << CHARGE_FULL_BIT )) return true ; else return false ; } return false ; } canControl() \u00b6 Syntax: 1 bool canControl () Description: This function checks the existence of the battery controller on I2C. Function argument No argument. Function return value true: Battery controller is found, false: Battery controller is not found. Definition: 1 2 3 4 5 6 bool canControl (){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_READ0 ); return ( Wire . endTransmission () == 0 ); } isCharging() \u00b6 Syntax: 1 bool isCharging () Description: This function checks the state of the charging. Function argument No argument. Function return value true: In charging, false: Not in charging. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 bool isCharging (){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_READ0 ); Wire . endTransmission ( false ); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); if ( data & ( 1 << CHARGE_FULL_BIT )) return true ; else return false ; } return false ; } getBatteryLevel() \u00b6 Syntax: 1 bool getBatteryLevel () Description: This function gets the battery level. Function argument No argument. Function return value Battery remaining percentage. (0-100 %) Returns -1 if it can not communicate with the controller. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int8_t getBatteryLevel () { Wire . beginTransmission ( 0x75 ); Wire . write ( 0x78 ); if ( Wire . endTransmission ( false ) == 0 && Wire . requestFrom ( 0x75 , 1 )) { switch ( Wire . read () & 0xF0 ) { case 0xE0 : return 25 ; case 0xC0 : return 50 ; case 0x80 : return 75 ; case 0x00 : return 100 ; default : return 0 ; } } return - 1 ; } setWakeupButton() \u00b6 Syntax: 1 void setWakeupButton ( uint8_t button ) Description: This function sets the port to exit sleep mode. Definition: 1 2 3 void setWakeupButton ( uint8_t button ) { _wakeupPin = button ; } reset() \u00b6 Syntax: 1 void reset () Description: This function resets the CPU. Definition: 1 2 3 void reset () { esp_restart (); } deepSleep() \u00b6 Syntax: 1 void deepSleep () Description: This function shifts to deep sleep mode. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void deepSleep (){ #ifdef M5STACK_FIRE // Keep power keep boost on setPowerBoostKeepOn ( true ); #endif // power off the Lcd M5 . Lcd . setBrightness ( 0 ); M5 . Lcd . sleep (); // ESP32 into deep sleep esp_sleep_enable_ext0_wakeup (( gpio_num_t ) _wakeupPin , LOW ); while ( digitalRead ( _wakeupPin ) == LOW ) { delay ( 10 ); } esp_deep_sleep_start (); }","title":"Power"},{"location":"m5stack/api/power/#power","text":"","title":"Power"},{"location":"m5stack/api/power/#setpowerboostkeepon","text":"Syntax: 1 bool setPowerBoostKeepOn ( bool en ) Description: This function sets/unsets always boost output mode. Function argument true: Turn on always boost output mode, false: Turn off always boost output mode. Function return value true: Control success, false: Control failure. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool setPowerBoostKeepOn ( bool en ){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); Wire . endTransmission (); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); if ( en ) Wire . write ( data | BOOST_OUT_BIT ); else Wire . write ( data & ( ~ BOOST_OUT_BIT )); Wire . endTransmission (); return true ; } return false ; }","title":"setPowerBoostKeepOn()"},{"location":"m5stack/api/power/#setkeeplightload","text":"Syntax: 1 bool setKeepLightLoad ( bool en ) Description: This function sets/unsets to disable the automatic shutdown. Function argument true: When the current is too small, IP5306 will not automatically shutdown, false: When the current is too small, IP5306 will automatically shutdown. Function return value true: Control success, false: Control failure. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool setKeepLightLoad ( bool en ) { uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); Wire . endTransmission (); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); if ( ! en ) Wire . write ( data | LIGHT_LOAD_BIT ); else Wire . write ( data & ( ~ LIGHT_LOAD_BIT )); Wire . endTransmission (); return true ; } return false ; }","title":"setKeepLightLoad()"},{"location":"m5stack/api/power/#setcharge","text":"Syntax: 1 bool setCharge ( bool en ) Description: This function sets/unsets charge mode. When the battery is fully charged, try set charge enable->disable->enable, It can be recharged. Function argument true: Start charging, false: Stop charging. Function return value true: Control success, false: Control failure. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool setCharge ( bool en ){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); Wire . endTransmission (); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_SYS_CTL0 ); if ( en ) Wire . write ( data | CHARGE_OUT_BIT ); else Wire . write ( data & ( ~ CHARGE_OUT_BIT )); Wire . endTransmission (); return true ; } return false ; }","title":"setCharge()"},{"location":"m5stack/api/power/#ischargefull","text":"Syntax: 1 bool isChargeFull () Description: This function checks if the battery is fully charged. Function argument No argument. Function return value true: Full charged, false: Not full charged. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 bool isChargeFull (){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_READ1 ); Wire . endTransmission ( false ); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); if ( data & ( 1 << CHARGE_FULL_BIT )) return true ; else return false ; } return false ; }","title":"isChargeFull()"},{"location":"m5stack/api/power/#cancontrol","text":"Syntax: 1 bool canControl () Description: This function checks the existence of the battery controller on I2C. Function argument No argument. Function return value true: Battery controller is found, false: Battery controller is not found. Definition: 1 2 3 4 5 6 bool canControl (){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_READ0 ); return ( Wire . endTransmission () == 0 ); }","title":"canControl()"},{"location":"m5stack/api/power/#ischarging","text":"Syntax: 1 bool isCharging () Description: This function checks the state of the charging. Function argument No argument. Function return value true: In charging, false: Not in charging. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 bool isCharging (){ uint8_t data ; Wire . beginTransmission ( IP5306_ADDR ); Wire . write ( IP5306_REG_READ0 ); Wire . endTransmission ( false ); if ( Wire . requestFrom ( IP5306_ADDR , 1 )) { data = Wire . read (); if ( data & ( 1 << CHARGE_FULL_BIT )) return true ; else return false ; } return false ; }","title":"isCharging()"},{"location":"m5stack/api/power/#getbatterylevel","text":"Syntax: 1 bool getBatteryLevel () Description: This function gets the battery level. Function argument No argument. Function return value Battery remaining percentage. (0-100 %) Returns -1 if it can not communicate with the controller. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int8_t getBatteryLevel () { Wire . beginTransmission ( 0x75 ); Wire . write ( 0x78 ); if ( Wire . endTransmission ( false ) == 0 && Wire . requestFrom ( 0x75 , 1 )) { switch ( Wire . read () & 0xF0 ) { case 0xE0 : return 25 ; case 0xC0 : return 50 ; case 0x80 : return 75 ; case 0x00 : return 100 ; default : return 0 ; } } return - 1 ; }","title":"getBatteryLevel()"},{"location":"m5stack/api/power/#setwakeupbutton","text":"Syntax: 1 void setWakeupButton ( uint8_t button ) Description: This function sets the port to exit sleep mode. Definition: 1 2 3 void setWakeupButton ( uint8_t button ) { _wakeupPin = button ; }","title":"setWakeupButton()"},{"location":"m5stack/api/power/#reset","text":"Syntax: 1 void reset () Description: This function resets the CPU. Definition: 1 2 3 void reset () { esp_restart (); }","title":"reset()"},{"location":"m5stack/api/power/#deepsleep","text":"Syntax: 1 void deepSleep () Description: This function shifts to deep sleep mode. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void deepSleep (){ #ifdef M5STACK_FIRE // Keep power keep boost on setPowerBoostKeepOn ( true ); #endif // power off the Lcd M5 . Lcd . setBrightness ( 0 ); M5 . Lcd . sleep (); // ESP32 into deep sleep esp_sleep_enable_ext0_wakeup (( gpio_num_t ) _wakeupPin , LOW ); while ( digitalRead ( _wakeupPin ) == LOW ) { delay ( 10 ); } esp_deep_sleep_start (); }","title":"deepSleep()"},{"location":"m5stack/api/speaker/","text":"Speaker \u00b6 tone \u00b6 Syntax: 1 tone ( uint16_t freq , [ uint32_t duration ]); Description: Set the pitch of speaker. Param Description type freq frequency uint16_t duration duration (unit: millisecond) uint16_t Example 1 2 3 4 5 6 #include <M5Stack.h> void setup () { M5 . begin (); M5 . Speaker . tone ( 900 , 1000 ); }","title":"Speaker"},{"location":"m5stack/api/speaker/#speaker","text":"","title":"Speaker"},{"location":"m5stack/api/speaker/#tone","text":"Syntax: 1 tone ( uint16_t freq , [ uint32_t duration ]); Description: Set the pitch of speaker. Param Description type freq frequency uint16_t duration duration (unit: millisecond) uint16_t Example 1 2 3 4 5 6 #include <M5Stack.h> void setup () { M5 . begin (); M5 . Speaker . tone ( 900 , 1000 ); }","title":"tone"},{"location":"m5stack/api/system/","text":"System \u00b6 begin() \u00b6 Syntax: 1 void begin ( bool LCDEnable = true , bool SDEnable = true , bool SerialEnable = true , bool I2CEnable = false ); Description: This function sets enable/disable LCD, TF Card,Serial port and I2C port. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 void M5Stack :: begin ( bool LCDEnable , bool SDEnable , bool SerialEnable , bool I2CEnable ) { // Correct init once if ( isInited ) return ; else isInited = true ; // UART if ( SerialEnable ) { Serial . begin ( 115200 ); Serial . flush (); delay ( 50 ); Serial . print ( \"M5Stack initializing...\" ); } // LCD INIT if ( LCDEnable ) { Lcd . begin (); } // TF Card if ( SDEnable ) { SD . begin ( TFCARD_CS_PIN , SPI , 40000000 ); } // TONE // Speaker.begin(); // Set wakeup button Power . setWakeupButton ( BUTTON_A_PIN ); // I2C init if ( I2CEnable ) { Wire . begin ( 21 , 22 ); } if ( SerialEnable ) { Serial . println ( \"OK\" ); } } void M5Stack :: update () { //Button update BtnA . read (); BtnB . read (); BtnC . read (); //Speaker update Speaker . update (); } update() \u00b6 Syntax: 1 void update (); Description: This function reads The State of Button A and B and C. Definition: 1 2 3 4 5 6 7 8 9 10 void M5Stack :: update () { //Button update BtnA . read (); BtnB . read (); BtnC . read (); //Speaker update Speaker . update (); } Example: 1 2 3 4 5 6 7 8 9 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . update (); } powerOFF() \u00b6 Syntax: 1 void powerOFF (); Description: This function turns off the power of M5. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void M5Stack :: powerOFF () { #ifdef M5STACK_FIRE // Keep power keep boost on setPowerBoostKeepOn ( true ); #endif // power off the Lcd Lcd . setBrightness ( 0 ); Lcd . sleep (); // ESP32 into deep sleep esp_sleep_enable_ext0_wakeup (( gpio_num_t ) _wakeupPin , LOW ); while ( digitalRead ( _wakeupPin ) == LOW ) { delay ( 10 ); } esp_deep_sleep_start (); } Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <M5Stack.h> void setup () { M5 . begin (); M5 . Lcd . println ( \"This is software power off demo\" ); M5 . Lcd . println ( \"Press the button A to power off.\" ); M5 . setWakeupButton ( BUTTON_A_PIN ); } void loop () { M5 . update (); if ( M5 . BtnA . wasPressed ()) { M5 . powerOFF (); } }","title":"System"},{"location":"m5stack/api/system/#system","text":"","title":"System"},{"location":"m5stack/api/system/#begin","text":"Syntax: 1 void begin ( bool LCDEnable = true , bool SDEnable = true , bool SerialEnable = true , bool I2CEnable = false ); Description: This function sets enable/disable LCD, TF Card,Serial port and I2C port. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 void M5Stack :: begin ( bool LCDEnable , bool SDEnable , bool SerialEnable , bool I2CEnable ) { // Correct init once if ( isInited ) return ; else isInited = true ; // UART if ( SerialEnable ) { Serial . begin ( 115200 ); Serial . flush (); delay ( 50 ); Serial . print ( \"M5Stack initializing...\" ); } // LCD INIT if ( LCDEnable ) { Lcd . begin (); } // TF Card if ( SDEnable ) { SD . begin ( TFCARD_CS_PIN , SPI , 40000000 ); } // TONE // Speaker.begin(); // Set wakeup button Power . setWakeupButton ( BUTTON_A_PIN ); // I2C init if ( I2CEnable ) { Wire . begin ( 21 , 22 ); } if ( SerialEnable ) { Serial . println ( \"OK\" ); } } void M5Stack :: update () { //Button update BtnA . read (); BtnB . read (); BtnC . read (); //Speaker update Speaker . update (); }","title":"begin()"},{"location":"m5stack/api/system/#update","text":"Syntax: 1 void update (); Description: This function reads The State of Button A and B and C. Definition: 1 2 3 4 5 6 7 8 9 10 void M5Stack :: update () { //Button update BtnA . read (); BtnB . read (); BtnC . read (); //Speaker update Speaker . update (); } Example: 1 2 3 4 5 6 7 8 9 #include <M5Stack.h> void setup () { M5 . begin (); } void loop () { M5 . update (); }","title":"update()"},{"location":"m5stack/api/system/#poweroff","text":"Syntax: 1 void powerOFF (); Description: This function turns off the power of M5. Definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void M5Stack :: powerOFF () { #ifdef M5STACK_FIRE // Keep power keep boost on setPowerBoostKeepOn ( true ); #endif // power off the Lcd Lcd . setBrightness ( 0 ); Lcd . sleep (); // ESP32 into deep sleep esp_sleep_enable_ext0_wakeup (( gpio_num_t ) _wakeupPin , LOW ); while ( digitalRead ( _wakeupPin ) == LOW ) { delay ( 10 ); } esp_deep_sleep_start (); } Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <M5Stack.h> void setup () { M5 . begin (); M5 . Lcd . println ( \"This is software power off demo\" ); M5 . Lcd . println ( \"Press the button A to power off.\" ); M5 . setWakeupButton ( BUTTON_A_PIN ); } void loop () { M5 . update (); if ( M5 . BtnA . wasPressed ()) { M5 . powerOFF (); } }","title":"powerOFF()"},{"location":"m5stack/api/tf/","text":"TF card \u00b6 begin() \u00b6 Syntax: 1 boolean begin ( uint8_t cspin ); Description: This function initialize TF card. Argument Description Type cspin chip select line (defaults SS line of SPI bus) uint8_t Example: 1 2 3 4 5 #include <M5Stack.h> void setup () { SD . begin (); } open() \u00b6 Syntax: 1 File open ( const char * filename , uint8_t mode = FILE_READ ); Description: This function open the file. Argument Description Type filepath path to file const char * mode read / write / rw (optional) uint8_t Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* display contents of hello.txt in TF card to M5 screen. */ #include <M5Stack.h> void setup () { M5 . begin (); if ( ! SD . begin ()) { M5 . Lcd . println ( \"Card failed, or not present\" ); while ( 1 ); } Serial . println ( \"TF card initialized.\" ); File f = SD . open ( \"/hello.txt\" , FILE_READ ); if ( f ) { M5 . Lcd . print ( f . read ()); f . close (); } else { M5 . Lcd . println ( \"open error hello.txt\" ); } } void loop () { }","title":"TF"},{"location":"m5stack/api/tf/#tf-card","text":"","title":"TF card"},{"location":"m5stack/api/tf/#begin","text":"Syntax: 1 boolean begin ( uint8_t cspin ); Description: This function initialize TF card. Argument Description Type cspin chip select line (defaults SS line of SPI bus) uint8_t Example: 1 2 3 4 5 #include <M5Stack.h> void setup () { SD . begin (); }","title":"begin()"},{"location":"m5stack/api/tf/#open","text":"Syntax: 1 File open ( const char * filename , uint8_t mode = FILE_READ ); Description: This function open the file. Argument Description Type filepath path to file const char * mode read / write / rw (optional) uint8_t Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* display contents of hello.txt in TF card to M5 screen. */ #include <M5Stack.h> void setup () { M5 . begin (); if ( ! SD . begin ()) { M5 . Lcd . println ( \"Card failed, or not present\" ); while ( 1 ); } Serial . println ( \"TF card initialized.\" ); File f = SD . open ( \"/hello.txt\" , FILE_READ ); if ( f ) { M5 . Lcd . print ( f . read ()); f . close (); } else { M5 . Lcd . println ( \"open error hello.txt\" ); } } void loop () { }","title":"open()"},{"location":"m5stack/base/btc/","text":"Loading Base \u00b6 Description \u00b6 BTC is a base including DHT12 module which can detect temperature and humidity. Your M5Stack Core board can stay as a small displayer(like a small TV or a small IOT central contronller) after adding this BTC Module. Note: Although M5Core BASIC or GRAY can be attached to this base, but BTC can not charge them. Actually, our Cores, as we know, are built in chargin chip (IP5306). After plugged a USB cable in, the Core was charging without any charger. Once M5Core has been attached to BTC, it can not controll ENV Unit at this time. Because BTC has been built in DHT12 sensor which will cause IIC address conflit. Feature \u00b6 DHT12 inside Include \u00b6 Type-C USB Cable M3 x 16 Tools PinMap \u00b6 DHT12 ESP32 Chip GPIO22 GND GPIO21 3V3 DHT12 SCL GND SDA 3V3 Related Link \u00b6 Offical Video Forum Example \u00b6 Arduino IDE \u00b6 If you want the code BTC.ino , please click here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <M5Stack.h> #include \"DHT12.h\" #include <Wire.h> //The DHT12 uses I2C comunication. void setup () { M5 . begin (); Wire . begin (); M5 . Lcd . setBrightness ( 10 ); Serial . println ( F ( \"ENV Unit(DHT12 and BMP280) test...\" )); } void loop () { float tmp = dht12 . readTemperature (); float hum = dht12 . readHumidity (); Serial . printf ( \"Temperatura: %2.2f*C Humedad: %0.2f%% \\r\\n \" , tmp , hum ); M5 . Lcd . setCursor ( 0 , 0 ); M5 . Lcd . setTextColor ( WHITE , BLACK ); M5 . Lcd . setTextSize ( 3 ); M5 . Lcd . printf ( \"Temp: %2.1f \\r\\n Humi: %2.0f%% \\r\\n \" , tmp , hum ); delay ( 100 ); }","title":"Loading Base"},{"location":"m5stack/base/btc/#loading-base","text":"","title":"Loading Base"},{"location":"m5stack/base/btc/#description","text":"BTC is a base including DHT12 module which can detect temperature and humidity. Your M5Stack Core board can stay as a small displayer(like a small TV or a small IOT central contronller) after adding this BTC Module. Note: Although M5Core BASIC or GRAY can be attached to this base, but BTC can not charge them. Actually, our Cores, as we know, are built in chargin chip (IP5306). After plugged a USB cable in, the Core was charging without any charger. Once M5Core has been attached to BTC, it can not controll ENV Unit at this time. Because BTC has been built in DHT12 sensor which will cause IIC address conflit.","title":"Description"},{"location":"m5stack/base/btc/#feature","text":"DHT12 inside","title":"Feature"},{"location":"m5stack/base/btc/#include","text":"Type-C USB Cable M3 x 16 Tools","title":"Include"},{"location":"m5stack/base/btc/#pinmap","text":"DHT12 ESP32 Chip GPIO22 GND GPIO21 3V3 DHT12 SCL GND SDA 3V3","title":"PinMap"},{"location":"m5stack/base/btc/#related-link","text":"Offical Video Forum","title":"Related Link"},{"location":"m5stack/base/btc/#example","text":"","title":"Example"},{"location":"m5stack/base/btc/#arduino-ide","text":"If you want the code BTC.ino , please click here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <M5Stack.h> #include \"DHT12.h\" #include <Wire.h> //The DHT12 uses I2C comunication. void setup () { M5 . begin (); Wire . begin (); M5 . Lcd . setBrightness ( 10 ); Serial . println ( F ( \"ENV Unit(DHT12 and BMP280) test...\" )); } void loop () { float tmp = dht12 . readTemperature (); float hum = dht12 . readHumidity (); Serial . printf ( \"Temperatura: %2.2f*C Humedad: %0.2f%% \\r\\n \" , tmp , hum ); M5 . Lcd . setCursor ( 0 , 0 ); M5 . Lcd . setTextColor ( WHITE , BLACK ); M5 . Lcd . setTextSize ( 3 ); M5 . Lcd . printf ( \"Temp: %2.1f \\r\\n Humi: %2.0f%% \\r\\n \" , tmp , hum ); delay ( 100 ); }","title":"Arduino IDE"},{"location":"m5stack/base/faces/","text":"FACES Base \u00b6 Description \u00b6 FACE Base is a base of FACES Kit . It's composed of M5Core base and battery as shown below. There are some expanding gpio(see the last picture) of M-Bus at the back of FACES Base, in order for you make a complex project conveniently. Obsolutely, a battery(600mAh) is built in base, so that you can use FACES Kit without usb cable. Usage \u00b6 Please stack M5Core and FACES Keyboard( i.e. QWERTY, GameBoy, Calculator ) over Base when use it as shown below** M-Bus \u00b6","title":"FACES Base"},{"location":"m5stack/base/faces/#faces-base","text":"","title":"FACES Base"},{"location":"m5stack/base/faces/#description","text":"FACE Base is a base of FACES Kit . It's composed of M5Core base and battery as shown below. There are some expanding gpio(see the last picture) of M-Bus at the back of FACES Base, in order for you make a complex project conveniently. Obsolutely, a battery(600mAh) is built in base, so that you can use FACES Kit without usb cable.","title":"Description"},{"location":"m5stack/base/faces/#usage","text":"Please stack M5Core and FACES Keyboard( i.e. QWERTY, GameBoy, Calculator ) over Base when use it as shown below**","title":"Usage"},{"location":"m5stack/base/faces/#m-bus","text":"","title":"M-Bus"},{"location":"m5stack/base/frame/","text":"FRAME Base \u00b6","title":"Frame Base"},{"location":"m5stack/base/frame/#frame-base","text":"","title":"FRAME Base"},{"location":"m5stack/base/m5go/","text":"M5GO BOTTOM \u00b6 Description \u00b6 M5GO BOTTOM is a normal base of M5GO IOT Starter Kit or M5Fire . M5GO Base is composed of battery(600mAh), M-Bus interface, charging indicator(red led), two RGB Bar, PORT B and PORT C. PinMap \u00b6 POGO Pin POGO Pin ESP32 Chip SCL GPIO22 SDA GPIO21 LED Bar There are 10 RGB Leds built in M5GO Base LED Pin ESP32 Chip LED Pin GPIO15 MIC MIC Pin ESP32 Chip MIC Pin GPIO34 GROVE PORT B(I/O) ESP32 Chip G36 GPIO36 G26 GPIO26 5V 5V GND GND PORT C(UART2) ESP32 Chip RXD GPIO16 TXD GPIO17 5V 5V GND GND M-Bus Related Link \u00b6 Schematic \u00b6","title":"M5GO Base"},{"location":"m5stack/base/m5go/#m5go-bottom","text":"","title":"M5GO BOTTOM"},{"location":"m5stack/base/m5go/#description","text":"M5GO BOTTOM is a normal base of M5GO IOT Starter Kit or M5Fire . M5GO Base is composed of battery(600mAh), M-Bus interface, charging indicator(red led), two RGB Bar, PORT B and PORT C.","title":"Description"},{"location":"m5stack/base/m5go/#pinmap","text":"POGO Pin POGO Pin ESP32 Chip SCL GPIO22 SDA GPIO21 LED Bar There are 10 RGB Leds built in M5GO Base LED Pin ESP32 Chip LED Pin GPIO15 MIC MIC Pin ESP32 Chip MIC Pin GPIO34 GROVE PORT B(I/O) ESP32 Chip G36 GPIO36 G26 GPIO26 5V 5V GND GND PORT C(UART2) ESP32 Chip RXD GPIO16 TXD GPIO17 5V 5V GND GND M-Bus","title":"PinMap"},{"location":"m5stack/base/m5go/#related-link","text":"","title":"Related Link"},{"location":"m5stack/base/m5go/#schematic","text":"","title":"Schematic"},{"location":"m5stack/base/m5go_charger/","text":"M5GO CHARGER \u00b6 Description \u00b6 M5GO CHARGER is a charging base for M5GO IOT Starter Kit kit. Certainly, it is also the charging base of M5Fire kit. The charging indicator light will blink when base is charging, but the light will keep on when charge completed. Include \u00b6 1x M5GO CHARGER Type-C USB cable","title":"M5GO Charger"},{"location":"m5stack/base/m5go_charger/#m5go-charger","text":"","title":"M5GO CHARGER"},{"location":"m5stack/base/m5go_charger/#description","text":"M5GO CHARGER is a charging base for M5GO IOT Starter Kit kit. Certainly, it is also the charging base of M5Fire kit. The charging indicator light will blink when base is charging, but the light will keep on when charge completed.","title":"Description"},{"location":"m5stack/base/m5go_charger/#include","text":"1x M5GO CHARGER Type-C USB cable","title":"Include"},{"location":"m5stack/core/black/","text":"M5Core BASIC \u00b6 Quick Start \u2014 Example \u2014 Schematic Description \u00b6 The M5Stack BASIC is a black development kit based on ESP32 chip composed of a black M5Core and a Bottom Base board. You can even program The M5Stack BASIC through Blockly, Arduino or MicroPython. The black core is a basic kit and it does not own any MEMS chip(like MPU9250...) . This is a Bottom board on the back of M5Core. It's designed for expanding gpio on M-Bus besides I2S Pins(GPIO0, GPIO12, GPIO13, GPIO15, GPIO34)for DIY. Each gpio on M-Bus is expanded as pin and port for convenience and flexibility. Feature \u00b6 Programming Support: UIFlow , MicroPython and Arduino TF Card Support(Up to 16GB) Source PinMap \u00b6 LCD & TF Card LCD Resolution: 320x240 ESP32 Chip GPIO23 GPIO19 GPIO18 GPIO14 GPIO27 GPIO33 GPIO32 GPIO4 ILI9341 / MISO CLK CS DC RST BL TF Card MOSI MISO CLK CS Button & Speaker ESP32 Chip GPIO39 GPIO38 GPIO37 GPIO25 Button Pin BUTTON A BUTTON B BUTTON C Speaker Speaker Pin GROVE \u63a5\u53e3 A & IP5306 Power Management IC (IP5306) is a custom I2C version, and the IIC address of IP5306 is 0x75. Click here for view register manual. ESP32 Chip GPIO22 GPIO21 GROVE A SCL SDA IP5306 SCL SDA 5V GND Parameter \u00b6 Source Parameter ESP32 240MHz dual core, 600 DMIPS, 520KB SRAM, Wi-Fi, dual mode Bluetooth Flash 16MB (old model: 4MB) Input 5V @ 500mA Interface TypeC x 1, GROVE(I2C+I/0+UART) x 1 LCD 2 inch, 320x240 Colorful TFT LCD, ILI9342 Speaker 1W-0928 Battery 150mAh @ 3.7V Op.Temp. 32\u00b0F to 104\u00b0F ( 0\u00b0C to 40\u00b0C ) Size 54 x 54 x 12.5 mm C.A.S.E Plastic ( PC ) Weight 120g with bottom, 100g only core NOTE: We have several kinds of Cores, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here . Include \u00b6 1x M5Stack BASIC 1x M5Stack BASIC Bottom 10x Proto Wire Type-C USB Cable User Manual Related Link \u00b6 Datasheet - ESP32 Related Video \u00b6 M5Stack Instroduce M5Core Cases","title":"M5Core BASIC"},{"location":"m5stack/core/black/#m5core-basic","text":"Quick Start \u2014 Example \u2014 Schematic","title":"M5Core BASIC"},{"location":"m5stack/core/black/#description","text":"The M5Stack BASIC is a black development kit based on ESP32 chip composed of a black M5Core and a Bottom Base board. You can even program The M5Stack BASIC through Blockly, Arduino or MicroPython. The black core is a basic kit and it does not own any MEMS chip(like MPU9250...) . This is a Bottom board on the back of M5Core. It's designed for expanding gpio on M-Bus besides I2S Pins(GPIO0, GPIO12, GPIO13, GPIO15, GPIO34)for DIY. Each gpio on M-Bus is expanded as pin and port for convenience and flexibility.","title":"Description"},{"location":"m5stack/core/black/#feature","text":"Programming Support: UIFlow , MicroPython and Arduino TF Card Support(Up to 16GB)","title":"Feature"},{"location":"m5stack/core/black/#source-pinmap","text":"LCD & TF Card LCD Resolution: 320x240 ESP32 Chip GPIO23 GPIO19 GPIO18 GPIO14 GPIO27 GPIO33 GPIO32 GPIO4 ILI9341 / MISO CLK CS DC RST BL TF Card MOSI MISO CLK CS Button & Speaker ESP32 Chip GPIO39 GPIO38 GPIO37 GPIO25 Button Pin BUTTON A BUTTON B BUTTON C Speaker Speaker Pin GROVE \u63a5\u53e3 A & IP5306 Power Management IC (IP5306) is a custom I2C version, and the IIC address of IP5306 is 0x75. Click here for view register manual. ESP32 Chip GPIO22 GPIO21 GROVE A SCL SDA IP5306 SCL SDA 5V GND","title":"Source PinMap"},{"location":"m5stack/core/black/#parameter","text":"Source Parameter ESP32 240MHz dual core, 600 DMIPS, 520KB SRAM, Wi-Fi, dual mode Bluetooth Flash 16MB (old model: 4MB) Input 5V @ 500mA Interface TypeC x 1, GROVE(I2C+I/0+UART) x 1 LCD 2 inch, 320x240 Colorful TFT LCD, ILI9342 Speaker 1W-0928 Battery 150mAh @ 3.7V Op.Temp. 32\u00b0F to 104\u00b0F ( 0\u00b0C to 40\u00b0C ) Size 54 x 54 x 12.5 mm C.A.S.E Plastic ( PC ) Weight 120g with bottom, 100g only core NOTE: We have several kinds of Cores, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here .","title":"Parameter"},{"location":"m5stack/core/black/#include","text":"1x M5Stack BASIC 1x M5Stack BASIC Bottom 10x Proto Wire Type-C USB Cable User Manual","title":"Include"},{"location":"m5stack/core/black/#related-link","text":"Datasheet - ESP32","title":"Related Link"},{"location":"m5stack/core/black/#related-video","text":"M5Stack Instroduce M5Core Cases","title":"Related Video"},{"location":"m5stack/core/fire/","text":"M5Stack FIRE \u00b6 Quick Start \u2014 Example \u2014 Schematic Description \u00b6 The M5Stack FIRE is a development kit based on ESP32 chip. FIRE is a kit which composed of red m5core, M5Go Base and M5Go CHG. Base (for charging red m5core). You can even program The M5Stack FIRE through Blockly, Arduino or MicroPython. The M5Stack FIRE equips ESP32 with everything necessary to program. It also features a 9-Axis (Gyro + Accelerometer + Magnetometer) MEMS ( MPU-9250 ) and a TFT LCD, so you can create a 3D remote gesture controller, a simple \"Leap Motion\" via M5Stack FIRE in a day in stead of couple weeks and so on. M5Go CHG. Base is composed of POGO pin. M5Go Base is composed of PORT B, PORT C, 2 RGBLed Bars(SK6812), a microphone and a Battery(600mAh). Charging instructions: The charging indicator light will blink when base is charging, but the light will keep on when charge completed. Feature \u00b6 Programming Support UIFlow MicroPython Arduino Compatible LEGO TF Card Support PinMap \u00b6 MainBoard Pinmap \u00b6 LCD & TF Card LCD Pixel\uff1a320x240 Maximum storage of TF Card: 16GB ESP32 Chip GPIO23 GPIO19 GPIO18 GPIO14 GPIO27 GPIO33 GPIO32 GPIO4 ILI9341(LCD Driver) / MISO CLK CS DC RST BL TF Card MOSI MISO CLK CS Button & Speaker ESP32 Chip GPIO39 GPIO38 GPIO37 GPIO25 Button BUTTON A BUTTON B BUTTON C Speaker Speaker Pin GROVE A & IP5306 Power Management IC (IP5306) is a custom I2C version, and the IIC address of IP5306 is 0x75. Click here for view register manual. ESP32 Chip GPIO22 GPIO21 5V GND GROVE A SCL SDA 5V GND IP5306 SCL SDA 5V GND 9-axis IMU sensor(MPU9250) I2C Address: 0x68 ESP32 Chip GPIO22 GPIO21 5V GND MPU9250 SCL SDA 5V GND M5GO Base Pinmap \u00b6 GROVE B ESP32 Chip GPIO36 GPIO26 5V GND GROVE B GPIO36 GPIO26 5V GND GROVE C ESP32 Chip GPIO16 GPIO17 5V GND GROVE C RXD TXD 5V GND LED Bar & MicroPhone ESP32 Chip GPIO15 GPIO34 LED Bar SIG Pin MicroPhone MIC Pin PARAMETER \u00b6 M5Core Source Parameter ESP32 240MHz dual core, 600 DMIPS, 520KB SRAM, Wi-Fi, dual mode Bluetooth Flash & PSRAM 16MB Flash + 4MB PSRAM Input 5V @ 500mA Interface TypeC x 1, GROVE(I2C+I/0+UART) x 1 LCD 2 inch, 320x240 Colorful TFT LCD, ILI9342 Speaker 1W-0928 Microphone MEMS Analog BSE3729 Microphone LED SK6812 3535 RGB LED x 10 MEMS MPU9250 Battery 550mAh @ 3.7V, inside vb Op.Temp. 32\u00b0F to 104\u00b0F ( 0\u00b0C to 40\u00b0C ) Size 54 x 54 x 21 mm C.A.S.E Plastic ( PC ) NOTE: We have several kinds of Cores, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here . Include \u00b6 1x M5Stack FIRE 1x M5GO Base 1x M5GO CHG BASE Type-C USB Cable User Manual Related Link \u00b6 Datasheet - ESP32 MPU9250 Related Video \u00b6 m5stack instroduce","title":"M5Core FIRE"},{"location":"m5stack/core/fire/#m5stack-fire","text":"Quick Start \u2014 Example \u2014 Schematic","title":"M5Stack FIRE"},{"location":"m5stack/core/fire/#description","text":"The M5Stack FIRE is a development kit based on ESP32 chip. FIRE is a kit which composed of red m5core, M5Go Base and M5Go CHG. Base (for charging red m5core). You can even program The M5Stack FIRE through Blockly, Arduino or MicroPython. The M5Stack FIRE equips ESP32 with everything necessary to program. It also features a 9-Axis (Gyro + Accelerometer + Magnetometer) MEMS ( MPU-9250 ) and a TFT LCD, so you can create a 3D remote gesture controller, a simple \"Leap Motion\" via M5Stack FIRE in a day in stead of couple weeks and so on. M5Go CHG. Base is composed of POGO pin. M5Go Base is composed of PORT B, PORT C, 2 RGBLed Bars(SK6812), a microphone and a Battery(600mAh). Charging instructions: The charging indicator light will blink when base is charging, but the light will keep on when charge completed.","title":"Description"},{"location":"m5stack/core/fire/#feature","text":"Programming Support UIFlow MicroPython Arduino Compatible LEGO TF Card Support","title":"Feature"},{"location":"m5stack/core/fire/#pinmap","text":"","title":"PinMap"},{"location":"m5stack/core/fire/#mainboard-pinmap","text":"LCD & TF Card LCD Pixel\uff1a320x240 Maximum storage of TF Card: 16GB ESP32 Chip GPIO23 GPIO19 GPIO18 GPIO14 GPIO27 GPIO33 GPIO32 GPIO4 ILI9341(LCD Driver) / MISO CLK CS DC RST BL TF Card MOSI MISO CLK CS Button & Speaker ESP32 Chip GPIO39 GPIO38 GPIO37 GPIO25 Button BUTTON A BUTTON B BUTTON C Speaker Speaker Pin GROVE A & IP5306 Power Management IC (IP5306) is a custom I2C version, and the IIC address of IP5306 is 0x75. Click here for view register manual. ESP32 Chip GPIO22 GPIO21 5V GND GROVE A SCL SDA 5V GND IP5306 SCL SDA 5V GND 9-axis IMU sensor(MPU9250) I2C Address: 0x68 ESP32 Chip GPIO22 GPIO21 5V GND MPU9250 SCL SDA 5V GND","title":"MainBoard Pinmap"},{"location":"m5stack/core/fire/#m5go-base-pinmap","text":"GROVE B ESP32 Chip GPIO36 GPIO26 5V GND GROVE B GPIO36 GPIO26 5V GND GROVE C ESP32 Chip GPIO16 GPIO17 5V GND GROVE C RXD TXD 5V GND LED Bar & MicroPhone ESP32 Chip GPIO15 GPIO34 LED Bar SIG Pin MicroPhone MIC Pin","title":"M5GO Base Pinmap"},{"location":"m5stack/core/fire/#parameter","text":"M5Core Source Parameter ESP32 240MHz dual core, 600 DMIPS, 520KB SRAM, Wi-Fi, dual mode Bluetooth Flash & PSRAM 16MB Flash + 4MB PSRAM Input 5V @ 500mA Interface TypeC x 1, GROVE(I2C+I/0+UART) x 1 LCD 2 inch, 320x240 Colorful TFT LCD, ILI9342 Speaker 1W-0928 Microphone MEMS Analog BSE3729 Microphone LED SK6812 3535 RGB LED x 10 MEMS MPU9250 Battery 550mAh @ 3.7V, inside vb Op.Temp. 32\u00b0F to 104\u00b0F ( 0\u00b0C to 40\u00b0C ) Size 54 x 54 x 21 mm C.A.S.E Plastic ( PC ) NOTE: We have several kinds of Cores, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here .","title":"PARAMETER"},{"location":"m5stack/core/fire/#include","text":"1x M5Stack FIRE 1x M5GO Base 1x M5GO CHG BASE Type-C USB Cable User Manual","title":"Include"},{"location":"m5stack/core/fire/#related-link","text":"Datasheet - ESP32 MPU9250","title":"Related Link"},{"location":"m5stack/core/fire/#related-video","text":"m5stack instroduce","title":"Related Video"},{"location":"m5stack/core/gray/","text":"M5Core GRAY \u00b6 Quick Start \u2014 Example Schematic Description \u00b6 M5Core GRAY is a development kit based on ESP32 chip composed of a gray M5Core and a Bottom Base board. You can even program The M5Core GRAY through Blockly, Arduino or MicroPython. The M5Core GRAY equips ESP32 with everything necessary to program. It also features a MEMS Chip( MPU9250 ), and a TFT LCD, so you can create a 3D remote gesture controller, a simple \"Leap Motion\" via M5Core GRAY in a day in stead of couple weeks and so on. This is a Bottom board on the back of M5Core. It's designed for expanding gpio on M-Bus besides I2S Pins(GPIO0, GPIO12, GPIO13, GPIO15, GPIO34)for DIY. Each gpio on M-Bus is expanded as pin and port for convenience and flexibility. Feature \u00b6 Programming Support: UIFlow , MicroPython and Arduino TF Card Support(Up to 16GB) PinMap \u00b6 MainBoard Pinmap \u00b6 LCD & TF Card LCD Pixel\uff1a320x240 Maximum storage of TF Card: 16GB ESP32 Chip GPIO23 GPIO19 GPIO18 GPIO14 GPIO27 GPIO33 GPIO32 GPIO4 ILI9341(LCD Driver) / MISO CLK CS DC RST BL TF Card MOSI MISO CLK CS Button & Speaker ESP32 Chip GPIO39 GPIO38 GPIO37 GPIO25 Button BUTTON A BUTTON B BUTTON C Speaker Speaker Pin GROVE A & IP5306 Power Management IC (IP5306) is a custom I2C version, and the IIC address of IP5306 is 0x75. Click here for view register manual. ESP32 Chip GPIO22 GPIO21 5V GND GROVE A SCL SDA 5V GND IP5306 SCL SDA 5V GND 9-axis IMU sensor(MPU9250) I2C Address: 0x68 ESP32 Chip GPIO22 GPIO21 5V GND MPU9250 SCL SDA 5V GND M5GO Base Pinmap \u00b6 GROVE B ESP32 Chip GPIO36 GPIO26 5V GND GROVE B GPIO36 GPIO26 5V GND GROVE C ESP32 Chip GPIO16 GPIO17 5V GND GROVE C RXD TXD 5V GND LED Bar & MicroPhone ESP32 Chip GPIO15 GPIO34 LED Bar SIG Pin MicroPhone MIC Pin PARAMETER \u00b6 M5Core Source Parameter ESP32 240MHz dual core, 600 DMIPS, 520KB SRAM, Wi-Fi, dual mode Bluetooth Flash 16MB (old model: 4MB) Input 5V @ 500mA Interface TypeC x 1, GROVE(I2C+I/0+UART) x 1 LCD 2 inch, 320x240 Colorful TFT LCD, ILI9342 Speaker 1W-0928 Microphone MEMS Analog BSE3729 Microphone LED SK6812 3535 RGB LED x 10 MEMS MPU9250 Battery 550mAh @ 3.7V, inside vb Op.Temp. 32\u00b0F to 104\u00b0F ( 0\u00b0C to 40\u00b0C ) Size 54 x 54 x 12.5 mm C.A.S.E Plastic ( PC ) Weight 120g with bottom, 100g only core NOTE: We have several kinds of Cores, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here . Include \u00b6 1x M5Core GRAY 1x M5Core Bottom Type-C USB Cable User Manual Related Link \u00b6 Datasheet - ESP32 - MPU9250 Related Video \u00b6 m5stack instroduce M5Core Cases","title":"M5Core GRAY"},{"location":"m5stack/core/gray/#m5core-gray","text":"Quick Start \u2014 Example Schematic","title":"M5Core GRAY"},{"location":"m5stack/core/gray/#description","text":"M5Core GRAY is a development kit based on ESP32 chip composed of a gray M5Core and a Bottom Base board. You can even program The M5Core GRAY through Blockly, Arduino or MicroPython. The M5Core GRAY equips ESP32 with everything necessary to program. It also features a MEMS Chip( MPU9250 ), and a TFT LCD, so you can create a 3D remote gesture controller, a simple \"Leap Motion\" via M5Core GRAY in a day in stead of couple weeks and so on. This is a Bottom board on the back of M5Core. It's designed for expanding gpio on M-Bus besides I2S Pins(GPIO0, GPIO12, GPIO13, GPIO15, GPIO34)for DIY. Each gpio on M-Bus is expanded as pin and port for convenience and flexibility.","title":"Description"},{"location":"m5stack/core/gray/#feature","text":"Programming Support: UIFlow , MicroPython and Arduino TF Card Support(Up to 16GB)","title":"Feature"},{"location":"m5stack/core/gray/#pinmap","text":"","title":"PinMap"},{"location":"m5stack/core/gray/#mainboard-pinmap","text":"LCD & TF Card LCD Pixel\uff1a320x240 Maximum storage of TF Card: 16GB ESP32 Chip GPIO23 GPIO19 GPIO18 GPIO14 GPIO27 GPIO33 GPIO32 GPIO4 ILI9341(LCD Driver) / MISO CLK CS DC RST BL TF Card MOSI MISO CLK CS Button & Speaker ESP32 Chip GPIO39 GPIO38 GPIO37 GPIO25 Button BUTTON A BUTTON B BUTTON C Speaker Speaker Pin GROVE A & IP5306 Power Management IC (IP5306) is a custom I2C version, and the IIC address of IP5306 is 0x75. Click here for view register manual. ESP32 Chip GPIO22 GPIO21 5V GND GROVE A SCL SDA 5V GND IP5306 SCL SDA 5V GND 9-axis IMU sensor(MPU9250) I2C Address: 0x68 ESP32 Chip GPIO22 GPIO21 5V GND MPU9250 SCL SDA 5V GND","title":"MainBoard Pinmap"},{"location":"m5stack/core/gray/#m5go-base-pinmap","text":"GROVE B ESP32 Chip GPIO36 GPIO26 5V GND GROVE B GPIO36 GPIO26 5V GND GROVE C ESP32 Chip GPIO16 GPIO17 5V GND GROVE C RXD TXD 5V GND LED Bar & MicroPhone ESP32 Chip GPIO15 GPIO34 LED Bar SIG Pin MicroPhone MIC Pin","title":"M5GO Base Pinmap"},{"location":"m5stack/core/gray/#parameter","text":"M5Core Source Parameter ESP32 240MHz dual core, 600 DMIPS, 520KB SRAM, Wi-Fi, dual mode Bluetooth Flash 16MB (old model: 4MB) Input 5V @ 500mA Interface TypeC x 1, GROVE(I2C+I/0+UART) x 1 LCD 2 inch, 320x240 Colorful TFT LCD, ILI9342 Speaker 1W-0928 Microphone MEMS Analog BSE3729 Microphone LED SK6812 3535 RGB LED x 10 MEMS MPU9250 Battery 550mAh @ 3.7V, inside vb Op.Temp. 32\u00b0F to 104\u00b0F ( 0\u00b0C to 40\u00b0C ) Size 54 x 54 x 12.5 mm C.A.S.E Plastic ( PC ) Weight 120g with bottom, 100g only core NOTE: We have several kinds of Cores, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here .","title":"PARAMETER"},{"location":"m5stack/core/gray/#include","text":"1x M5Core GRAY 1x M5Core Bottom Type-C USB Cable User Manual","title":"Include"},{"location":"m5stack/core/gray/#related-link","text":"Datasheet - ESP32 - MPU9250","title":"Related Link"},{"location":"m5stack/core/gray/#related-video","text":"m5stack instroduce M5Core Cases","title":"Related Video"},{"location":"m5stack/core/quickstart/m5cloud/","text":"M5Cloud Quick Start (MicroPython) \u00b6 Info If it's first time to use M5Core or you want to change the networkable AP that means the Core can't access http://cloud.m5stack.com , you need visit this article for setting wifi How to connect wifi using Core with M5Cloud . By default, we consider your M5Core has been connected with the networkable AP successfully. And the screen shows like this figure below. 1. Connect to M5Cloud \u00b6 Now If you want to program the M5 from your computer, enter the url shown at the top of the screen cloud.m5stack.com It will show as following figure. Now, register a account. 2. Binding device \u00b6 Press Device -> Add buttom on M5Cloud IDE for binding M5Stack board to your account.(Now, my check code is 052879 ) At the moment, you can program it through Python as shown below. 3. Program with Core \u00b6 a. New a Project \u00b6 a. Code it \u00b6 Now, let's get started with FACES Kit. After creating a new project, add a file named faces.py as a python module. Then copy following code into faces.py and main.py, and save they. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \"\"\" File name: faces.py M5Stack MicroPython FACES keyboard I2C driver \"\"\" class Faces : def __init__ ( self , i2c = None ): if i2c == None : from machine import I2C , Pin self . i2c = I2C ( sda = 21 , scl = 22 ) else : self . i2c = i2c self . addr = 0x08 self . cb = None def read ( self ): return self . i2c . readfrom ( self . addr , 1 ) def _callback ( self , pin ): from machine import Pin if pin == Pin ( 5 ): self . cb ( self . read ()) def callback ( self , cb ): from machine import Pin self . pin = Pin ( 5 ) self . pin . init ( Pin . IN ) self . pin . irq ( trigger = Pin . IRQ_FALLING , handler = self . _callback ) self . cb = cb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \"\"\" File name: main.py \"\"\" from m5stack import * from faces import Faces keyboard = Faces () # read once print ( \"Key value:\" , end = '' ) print ( keyboard . read ()) # callback def keyboard_cb ( value ): print ( \"Key value:\" , end = '' ) print ( value ) lcd . print ( value ) keyboard . callback ( keyboard_cb ) Now, upload and run it! Complete \u00b6 The function of This demostration is that screen and serial terminal will display the value of the key you pressed. Now, I press the first line of QWERTY Keyboard. (\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\")","title":"M5Cloud"},{"location":"m5stack/core/quickstart/m5cloud/#m5cloud-quick-start-micropython","text":"Info If it's first time to use M5Core or you want to change the networkable AP that means the Core can't access http://cloud.m5stack.com , you need visit this article for setting wifi How to connect wifi using Core with M5Cloud . By default, we consider your M5Core has been connected with the networkable AP successfully. And the screen shows like this figure below.","title":"M5Cloud Quick Start (MicroPython)"},{"location":"m5stack/core/quickstart/m5cloud/#1-connect-to-m5cloud","text":"Now If you want to program the M5 from your computer, enter the url shown at the top of the screen cloud.m5stack.com It will show as following figure. Now, register a account.","title":"1. Connect to M5Cloud"},{"location":"m5stack/core/quickstart/m5cloud/#2-binding-device","text":"Press Device -> Add buttom on M5Cloud IDE for binding M5Stack board to your account.(Now, my check code is 052879 ) At the moment, you can program it through Python as shown below.","title":"2. Binding device"},{"location":"m5stack/core/quickstart/m5cloud/#3-program-with-core","text":"","title":"3. Program with Core"},{"location":"m5stack/core/quickstart/m5cloud/#a-new-a-project","text":"","title":"a. New a Project"},{"location":"m5stack/core/quickstart/m5cloud/#a-code-it","text":"Now, let's get started with FACES Kit. After creating a new project, add a file named faces.py as a python module. Then copy following code into faces.py and main.py, and save they. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \"\"\" File name: faces.py M5Stack MicroPython FACES keyboard I2C driver \"\"\" class Faces : def __init__ ( self , i2c = None ): if i2c == None : from machine import I2C , Pin self . i2c = I2C ( sda = 21 , scl = 22 ) else : self . i2c = i2c self . addr = 0x08 self . cb = None def read ( self ): return self . i2c . readfrom ( self . addr , 1 ) def _callback ( self , pin ): from machine import Pin if pin == Pin ( 5 ): self . cb ( self . read ()) def callback ( self , cb ): from machine import Pin self . pin = Pin ( 5 ) self . pin . init ( Pin . IN ) self . pin . irq ( trigger = Pin . IRQ_FALLING , handler = self . _callback ) self . cb = cb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \"\"\" File name: main.py \"\"\" from m5stack import * from faces import Faces keyboard = Faces () # read once print ( \"Key value:\" , end = '' ) print ( keyboard . read ()) # callback def keyboard_cb ( value ): print ( \"Key value:\" , end = '' ) print ( value ) lcd . print ( value ) keyboard . callback ( keyboard_cb ) Now, upload and run it!","title":"a. Code it"},{"location":"m5stack/core/quickstart/m5cloud/#complete","text":"The function of This demostration is that screen and serial terminal will display the value of the key you pressed. Now, I press the first line of QWERTY Keyboard. (\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\")","title":"Complete"},{"location":"m5stack/core/quickstart/macos/","text":"M5Core Quick Start \u00b6 1. Install Arduino IDE \u00b6 Open your browser, enter the official website of Arduino https://www.arduino.cc/en/Main/Software (1) click Mac OS X for downloading Arduino IDE (2) click JUST DOWNLOAD (3) Once the Arduino IDE is downloaded, you can double-click it to open it 2. Install USB to Serial Driver \u00b6 Open your browser, enter the official website of M5Stack https://m5stack.com/download (1) click Mac for downloading this installation package and then unzip this package (2) After unzipped this package, double click the disk image SiLabsUSBDriverDisk.dmg for installing (3) Check the serial port number /dev/tty.SLAB_USBtoUART Comfirm if the USB to Serial Driver was successfully installed already: Open Terminal , connect M5Core with PC through USB Type-C cable, and execute the following command for viewing serial port list. Disconnect M5Core device, and execute the just executed command to verify which port disappears from the list. The disappearing COM port is the serial port name corresponding to M5Core. Now, the serial port name is tty.SLAB_USBtoUART 3. Install ESP32 Boards Manager \u00b6 (1) Open IDE, click File -> Peferences -> Settings (2) Copy the following ESP32 Boards Manager url to Additional Boards Manager URLs: ESP32 Boards Manager url: https://dl.espressif.com/dl/package_esp32_index.json (3) Click Tools -> Board: -> Boards Manager... (4) Search ESP32 in the new pop-up dialog, then click Install 4. Install M5Stack Library \u00b6 (1) Open Arduino IDE, then Select Sketch -> Include Library -> Manage Libraries... (2) \u641c\u7d22 M5Stack \u5e76\u5b89\u88c5\uff0c\u5982\u4e0b\u56fe\u6240\u793a 5. Example \u00b6 This section for verifying whether you can program with Arduino or not. Now, The USB cable connects to M5Core, then select your serial port which is connected M5Core. Select a demo example, compile and upload (1) Select the correct board name and serial port name Open Arduino IDE, select Tools -> Board -> M5Stack-Core-ESP32 for your M5Core, Tools -> Ports for serial port (2) Then select an example likes HelloWorld.ino Select File -> Examples -> M5Stack -> Basics Select a example named HelloWorld . Upload it, and after this program was uploaded successfully, the screen on M5Core will display \"Hello World!\" Note \u00b6 Although most versions of MacOS have no problem with detecting the COM port, on some newer versions of High Sierra sometimes Slab_USBtoUART does not appear. If this is the case, after you connect the M5 open security and privacy in the system preferences and set it to permit . Info If you want to read more the permission about the CP2104 USB driver, visit the following link please. https://developer.apple.com/library/archive/technotes/tn2459/ _index.html Video Tutorial \u00b6","title":"macOS"},{"location":"m5stack/core/quickstart/macos/#m5core-quick-start","text":"","title":"M5Core Quick Start"},{"location":"m5stack/core/quickstart/macos/#1-install-arduino-ide","text":"Open your browser, enter the official website of Arduino https://www.arduino.cc/en/Main/Software (1) click Mac OS X for downloading Arduino IDE (2) click JUST DOWNLOAD (3) Once the Arduino IDE is downloaded, you can double-click it to open it","title":"1. Install Arduino IDE"},{"location":"m5stack/core/quickstart/macos/#2-install-usb-to-serial-driver","text":"Open your browser, enter the official website of M5Stack https://m5stack.com/download (1) click Mac for downloading this installation package and then unzip this package (2) After unzipped this package, double click the disk image SiLabsUSBDriverDisk.dmg for installing (3) Check the serial port number /dev/tty.SLAB_USBtoUART Comfirm if the USB to Serial Driver was successfully installed already: Open Terminal , connect M5Core with PC through USB Type-C cable, and execute the following command for viewing serial port list. Disconnect M5Core device, and execute the just executed command to verify which port disappears from the list. The disappearing COM port is the serial port name corresponding to M5Core. Now, the serial port name is tty.SLAB_USBtoUART","title":"2. Install USB to Serial Driver"},{"location":"m5stack/core/quickstart/macos/#3-install-esp32-boards-manager","text":"(1) Open IDE, click File -> Peferences -> Settings (2) Copy the following ESP32 Boards Manager url to Additional Boards Manager URLs: ESP32 Boards Manager url: https://dl.espressif.com/dl/package_esp32_index.json (3) Click Tools -> Board: -> Boards Manager... (4) Search ESP32 in the new pop-up dialog, then click Install","title":"3. Install ESP32 Boards Manager"},{"location":"m5stack/core/quickstart/macos/#4-install-m5stack-library","text":"(1) Open Arduino IDE, then Select Sketch -> Include Library -> Manage Libraries... (2) \u641c\u7d22 M5Stack \u5e76\u5b89\u88c5\uff0c\u5982\u4e0b\u56fe\u6240\u793a","title":"4. Install M5Stack Library"},{"location":"m5stack/core/quickstart/macos/#5-example","text":"This section for verifying whether you can program with Arduino or not. Now, The USB cable connects to M5Core, then select your serial port which is connected M5Core. Select a demo example, compile and upload (1) Select the correct board name and serial port name Open Arduino IDE, select Tools -> Board -> M5Stack-Core-ESP32 for your M5Core, Tools -> Ports for serial port (2) Then select an example likes HelloWorld.ino Select File -> Examples -> M5Stack -> Basics Select a example named HelloWorld . Upload it, and after this program was uploaded successfully, the screen on M5Core will display \"Hello World!\"","title":"5. Example"},{"location":"m5stack/core/quickstart/macos/#note","text":"Although most versions of MacOS have no problem with detecting the COM port, on some newer versions of High Sierra sometimes Slab_USBtoUART does not appear. If this is the case, after you connect the M5 open security and privacy in the system preferences and set it to permit . Info If you want to read more the permission about the CP2104 USB driver, visit the following link please. https://developer.apple.com/library/archive/technotes/tn2459/ _index.html","title":"Note"},{"location":"m5stack/core/quickstart/macos/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"m5stack/core/quickstart/overview/","text":"M5Core Get Started \u00b6 Pick up your programming mode below for getting started Arduino-MacOS Arduino-Windows UIFlow","title":"Overview"},{"location":"m5stack/core/quickstart/overview/#m5core-get-started","text":"Pick up your programming mode below for getting started Arduino-MacOS Arduino-Windows UIFlow","title":"M5Core Get Started"},{"location":"m5stack/core/quickstart/uiflow/","text":"UIFlow Quick Start (Blockly/MicroPython) \u00b6 1. Install USB to Serial Driver \u00b6 Open your browser, enter the official website of M5Stack https://m5stack.com/download (1) click Windows for downloading this installation package and then unzip this package. (2) According to your Windows operating system type, select the corresponding driver installation package 32-bit Windows operating system, choose CP210xVCPInstaller_x86_vx.x.x.x.exe 64-bit Windows operating system, choose CP210xVCPInstaller_x64_vx.x.x.x.exe (3) double click the executable file for installing. (4) Check the serial port number COMx To comfirm if the USB to Serial Driver was successfully installed already, Check the list of identified COM ports in the Windows Device Manager : Connect the Core to the computer via a USB Type-C cable, open Windows Device Manager , click Ports(COM & LPT) for checking the list of identified COM ports. Disconnect M5Core device and connect it back, to verify which port disappears from the list and then shows back again. 2. Burn UIFlow Firmware \u00b6 (1) Download M5Burner Access M5Stack Official Website , and download M5Burner (2) Burn the firmware Connect M5Core to the computer via the USB Type-C cable, unzip the M5Burner archive you just downloaded, and double-click the executable M5Burner.exe Select the serial number and 921600 baud rate that the board is connected to the computer, and select the latest version of UIFlow firmware. Click Burn for downloading UIFlow firmware The following interface appears, indicating that the firmware is successfully burned. 3. Wi-Fi Setting \u00b6 (1) Select SETUP After successfully burning the UIFlow firmware, click the red button in the upper left corner of the Core to restart the device. Once the Core is powered on, immediately click the C button that indicates you select the SETUP option on the screen for the network configuration. Then click on the middle button and select Link Server: Flow.m5stack.com . (2) Connect to AP Turn on Wi-Fi on your phone or computer, then connect to the M5Core hotspot AP displayed on the screen ( For example, the M5Stack-0d60 is now displayed ). After the connection is successful, open a browser and enter the URL 192.168.4.1 , then select Wi-Fi that can be connected to the network, enter the Wi-Fi password. ( Now, the networkable Wi-Fi is M5 ) (3) Connect to Wi-Fi After M5Core successfully connects to a networkable Wi-Fi (here M5), the screen will display APIKEY and the QR code that can access the UIFlow webpage. Description of APIKEY: APIKEY is the device unique identifier. As long as the current UIFlow is connected to which device's APIKEY, The programming code will be downloaded to that device. The status of the small dot on the screen: Green means M5Core successfully connected to M5Stack Server, that is online status Red means be offline status 4. Program \u00b6 (1) Connect to UIFlow Now scan the QR code on the M5Core with your phone or tablet, or if you are programming with a computer, enter the URL flow.m5stack.com on your computer's browser Every time before you upload the code to M5Core through UIFlow, make sure that UIFlow is connected to the M5Core you want to program. So you need to click on the gear in the upper right corner of the UIFlow IDE page and enter APIKEY on your M5Core screen in the pop-up dialog box. Click Save , then UIFlow will connect to M5Core. Now you can start programming with UIFlow! (2) Programming example a. draw a UI Drag and drop the 4 controls in the upper left corner of the UIFlow IDE to the UI interface of M5Stack Core and click the Run button in the upper right corner of the page to execute the effect. b. writing a Blockly program Drag the Set emoji map in0 block from the Emoji category on the left to the code area of Blockly and click the Run button. The link of source coce: https://github.com/m5stack/M5-ProductExampleCodes/blob/master/Core/M5_draw_heart.m5f c. writing a MicroPython program Copy the following code into the Python editing area, then click Run in the top right corner to execute the code. 1 2 3 4 5 6 7 8 9 10 11 from m5stack import * from m5ui import * clear_bg ( 0x111111 ) btnA = M5Button ( name = 'ButtonA' , text = 'ButtonA' , visibility = False ) btnB = M5Button ( name = 'ButtonB' , text = 'ButtonB' , visibility = False ) btnC = M5Button ( name = 'ButtonC' , text = 'ButtonC' , visibility = False ) lcd . print ( \"Hello M5Stack\" ) At this time, the word 'Hello M5Stack` will be printed on the M5Core screen. Video Tutorial \u00b6 UIFlow Overview UIFlow Tutorial","title":"UIFlow"},{"location":"m5stack/core/quickstart/uiflow/#uiflow-quick-start-blocklymicropython","text":"","title":"UIFlow Quick Start (Blockly/MicroPython)"},{"location":"m5stack/core/quickstart/uiflow/#1-install-usb-to-serial-driver","text":"Open your browser, enter the official website of M5Stack https://m5stack.com/download (1) click Windows for downloading this installation package and then unzip this package. (2) According to your Windows operating system type, select the corresponding driver installation package 32-bit Windows operating system, choose CP210xVCPInstaller_x86_vx.x.x.x.exe 64-bit Windows operating system, choose CP210xVCPInstaller_x64_vx.x.x.x.exe (3) double click the executable file for installing. (4) Check the serial port number COMx To comfirm if the USB to Serial Driver was successfully installed already, Check the list of identified COM ports in the Windows Device Manager : Connect the Core to the computer via a USB Type-C cable, open Windows Device Manager , click Ports(COM & LPT) for checking the list of identified COM ports. Disconnect M5Core device and connect it back, to verify which port disappears from the list and then shows back again.","title":"1. Install USB to Serial Driver"},{"location":"m5stack/core/quickstart/uiflow/#2-burn-uiflow-firmware","text":"(1) Download M5Burner Access M5Stack Official Website , and download M5Burner (2) Burn the firmware Connect M5Core to the computer via the USB Type-C cable, unzip the M5Burner archive you just downloaded, and double-click the executable M5Burner.exe Select the serial number and 921600 baud rate that the board is connected to the computer, and select the latest version of UIFlow firmware. Click Burn for downloading UIFlow firmware The following interface appears, indicating that the firmware is successfully burned.","title":"2. Burn UIFlow Firmware"},{"location":"m5stack/core/quickstart/uiflow/#3-wi-fi-setting","text":"(1) Select SETUP After successfully burning the UIFlow firmware, click the red button in the upper left corner of the Core to restart the device. Once the Core is powered on, immediately click the C button that indicates you select the SETUP option on the screen for the network configuration. Then click on the middle button and select Link Server: Flow.m5stack.com . (2) Connect to AP Turn on Wi-Fi on your phone or computer, then connect to the M5Core hotspot AP displayed on the screen ( For example, the M5Stack-0d60 is now displayed ). After the connection is successful, open a browser and enter the URL 192.168.4.1 , then select Wi-Fi that can be connected to the network, enter the Wi-Fi password. ( Now, the networkable Wi-Fi is M5 ) (3) Connect to Wi-Fi After M5Core successfully connects to a networkable Wi-Fi (here M5), the screen will display APIKEY and the QR code that can access the UIFlow webpage. Description of APIKEY: APIKEY is the device unique identifier. As long as the current UIFlow is connected to which device's APIKEY, The programming code will be downloaded to that device. The status of the small dot on the screen: Green means M5Core successfully connected to M5Stack Server, that is online status Red means be offline status","title":"3. Wi-Fi Setting"},{"location":"m5stack/core/quickstart/uiflow/#4-program","text":"(1) Connect to UIFlow Now scan the QR code on the M5Core with your phone or tablet, or if you are programming with a computer, enter the URL flow.m5stack.com on your computer's browser Every time before you upload the code to M5Core through UIFlow, make sure that UIFlow is connected to the M5Core you want to program. So you need to click on the gear in the upper right corner of the UIFlow IDE page and enter APIKEY on your M5Core screen in the pop-up dialog box. Click Save , then UIFlow will connect to M5Core. Now you can start programming with UIFlow! (2) Programming example a. draw a UI Drag and drop the 4 controls in the upper left corner of the UIFlow IDE to the UI interface of M5Stack Core and click the Run button in the upper right corner of the page to execute the effect. b. writing a Blockly program Drag the Set emoji map in0 block from the Emoji category on the left to the code area of Blockly and click the Run button. The link of source coce: https://github.com/m5stack/M5-ProductExampleCodes/blob/master/Core/M5_draw_heart.m5f c. writing a MicroPython program Copy the following code into the Python editing area, then click Run in the top right corner to execute the code. 1 2 3 4 5 6 7 8 9 10 11 from m5stack import * from m5ui import * clear_bg ( 0x111111 ) btnA = M5Button ( name = 'ButtonA' , text = 'ButtonA' , visibility = False ) btnB = M5Button ( name = 'ButtonB' , text = 'ButtonB' , visibility = False ) btnC = M5Button ( name = 'ButtonC' , text = 'ButtonC' , visibility = False ) lcd . print ( \"Hello M5Stack\" ) At this time, the word 'Hello M5Stack` will be printed on the M5Core screen.","title":"4. Program"},{"location":"m5stack/core/quickstart/uiflow/#video-tutorial","text":"UIFlow Overview UIFlow Tutorial","title":"Video Tutorial"},{"location":"m5stack/core/quickstart/windows/","text":"M5Core Quick Start \u00b6 1. Install Arduino IDE \u00b6 Open your browser, enter the official website of Arduino https://www.arduino.cc/en/Main/Software (1) click Windows ZIP file for non admin install for downloading Arduino IDE (2) click JUST DOWNLOAD (3) To install IDE, double click Arduino executable file. Keep the default selection throughout this process, including the installation path is also the default. 2. Install USB to Serial Driver \u00b6 Open your browser, enter the official website of M5Stack https://m5stack.com/download (1) click Windows for downloading this installation package and then unzip this package. (2) According to your Windows operating system type, select the corresponding driver installation package 32-bit Windows operating system, choose CP210xVCPInstaller_x86_vx.x.x.x.exe 64-bit Windows operating system, choose CP210xVCPInstaller_x64_vx.x.x.x.exe (3) double click the executable file for installing. (4) Check the serial port number COMx To comfirm if the USB to Serial Driver was successfully installed already, Check the list of identified COM ports in the Windows Device Manager : Connect the Core to the computer via a USB Type-C cable, open Windows Device Manager , click Ports(COM & LPT) for checking the list of identified COM ports. Disconnect M5Core device and connect it back, to verify which port disappears from the list and then shows back again. 3. Install ESP32 Boards Manager \u00b6 (1) Open IDE, click File -> Peferences -> Settings (2) Copy the following ESP32 Boards Manager url to Additional Boards Manager URLs: ESP32 Boards Manager url: https://dl.espressif.com/dl/package_esp32_index.json (3) Click Tools -> Board: -> Boards Manager... (4) Search ESP32 in the new pop-up dialog, then click Install 4. Install M5Stack Library \u00b6 (1) Open Arduino IDE, then Select Sketch -> Include Library -> Manage Libraries... (2) Search M5Stack and install it 5. Example \u00b6 This section for verifying whether you can program with Arduino or not. Now, The USB cable connects to M5Core, then select your serial port which is connected M5Core. Select a demo example, compile and upload (1) Execute a example likes FactoryTest.ino Select your board name, baudrate, the specified serial port: M5Stack-Core-ESP32, 921600, COM26(Now, my serial port which is connected with PC is COM26 ) (2) Then select an example likes FactoryTest.ino (3) Upload it (4) New a M5Stack program Open Arduino IDE, then new a .ino file, rename it as my_test.ino Copy the below code to my_test.ino 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <M5Stack.h> // the setup routine runs once when M5Stack starts up void setup (){ // Initialize the M5Stack object M5 . begin (); // LCD display M5 . Lcd . print ( \"Hello World!\" ); M5 . Lcd . print ( \"M5Stack is running successfully!\" ); } // the loop routine runs over and over again forever void loop () { } compile it and upload, the M5Stack screen will show \"Hello World!\" \"M5Stack is running successfully!\"","title":"Windows"},{"location":"m5stack/core/quickstart/windows/#m5core-quick-start","text":"","title":"M5Core Quick Start"},{"location":"m5stack/core/quickstart/windows/#1-install-arduino-ide","text":"Open your browser, enter the official website of Arduino https://www.arduino.cc/en/Main/Software (1) click Windows ZIP file for non admin install for downloading Arduino IDE (2) click JUST DOWNLOAD (3) To install IDE, double click Arduino executable file. Keep the default selection throughout this process, including the installation path is also the default.","title":"1. Install Arduino IDE"},{"location":"m5stack/core/quickstart/windows/#2-install-usb-to-serial-driver","text":"Open your browser, enter the official website of M5Stack https://m5stack.com/download (1) click Windows for downloading this installation package and then unzip this package. (2) According to your Windows operating system type, select the corresponding driver installation package 32-bit Windows operating system, choose CP210xVCPInstaller_x86_vx.x.x.x.exe 64-bit Windows operating system, choose CP210xVCPInstaller_x64_vx.x.x.x.exe (3) double click the executable file for installing. (4) Check the serial port number COMx To comfirm if the USB to Serial Driver was successfully installed already, Check the list of identified COM ports in the Windows Device Manager : Connect the Core to the computer via a USB Type-C cable, open Windows Device Manager , click Ports(COM & LPT) for checking the list of identified COM ports. Disconnect M5Core device and connect it back, to verify which port disappears from the list and then shows back again.","title":"2. Install USB to Serial Driver"},{"location":"m5stack/core/quickstart/windows/#3-install-esp32-boards-manager","text":"(1) Open IDE, click File -> Peferences -> Settings (2) Copy the following ESP32 Boards Manager url to Additional Boards Manager URLs: ESP32 Boards Manager url: https://dl.espressif.com/dl/package_esp32_index.json (3) Click Tools -> Board: -> Boards Manager... (4) Search ESP32 in the new pop-up dialog, then click Install","title":"3. Install ESP32 Boards Manager"},{"location":"m5stack/core/quickstart/windows/#4-install-m5stack-library","text":"(1) Open Arduino IDE, then Select Sketch -> Include Library -> Manage Libraries... (2) Search M5Stack and install it","title":"4. Install M5Stack Library"},{"location":"m5stack/core/quickstart/windows/#5-example","text":"This section for verifying whether you can program with Arduino or not. Now, The USB cable connects to M5Core, then select your serial port which is connected M5Core. Select a demo example, compile and upload (1) Execute a example likes FactoryTest.ino Select your board name, baudrate, the specified serial port: M5Stack-Core-ESP32, 921600, COM26(Now, my serial port which is connected with PC is COM26 ) (2) Then select an example likes FactoryTest.ino (3) Upload it (4) New a M5Stack program Open Arduino IDE, then new a .ino file, rename it as my_test.ino Copy the below code to my_test.ino 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <M5Stack.h> // the setup routine runs once when M5Stack starts up void setup (){ // Initialize the M5Stack object M5 . begin (); // LCD display M5 . Lcd . print ( \"Hello World!\" ); M5 . Lcd . print ( \"M5Stack is running successfully!\" ); } // the loop routine runs over and over again forever void loop () { } compile it and upload, the M5Stack screen will show \"Hello World!\" \"M5Stack is running successfully!\"","title":"5. Example"},{"location":"m5stack/kit/faces/","text":"FACES Kit \u00b6 FACES Kit is a kit composed of M5Core GRAY, functional keyboards, FACES Base, FACES Charger and some accessories(including DuPont lines, lanyard, M3 fixing screws and so on). Currently, the functional keyboards are composed of GameBoy, Calculator and QWERTY ( For each functional keyboard, it's integrated MEGA328 chip, so that when you press a button, a corresponding value( hexadecimal format ) will be sent from keyboard to M5Core. They(keyboard and m5core) are communicating using I2C. And the I2C address of each keyboard is 0x08. ). We'll add other keyboards to FACES Kit. You can program it through Arduino IDE or MicroPython. For different applications, you can stack corresponding keyboard on FACES Base and burn corresponding firmware into M5Core. And here, you can learn more about FACES Base . NOTE: If you want to burn the factory firmware yourself, you need to download the M5Burner on our official website . Then connect FACES to PC through Type-C USB cable, burn FACES Kit firmware. Now, here's the picture of the whole kit. 1. GameBoy Keyboard \u00b6 When create a handheld game, you can stack a GameBoy keyboard over FACES Base straight. And burn a Nintendo Entertainment System emulator. Here is the method of burning emulator and a game: download game 2. Calculator Keyboard \u00b6 When create a calculator, you need the Calculator Keyboard. Burn your firmware into M5Core. The button which was pressed will execute the callback specifical function, so the calculator is created. 3. QWERTY Keyboard \u00b6 When your project needs full keyboard input, just to stack QWERTY over Base. Burn the following example(example function: M5Core and serial terminal will print button you pressed) source file of example - a. Arduino - b. MicroPython (for M5Cloud) M5Cloud usage - MicroPython(M5Cloud) 4. FACES Charger \u00b6 FACES Charger built in some magnets. When charging, the FACES can be attached with charger. They are connected by PIGO Pin. Related Link \u00b6 Example MEGA328P Firmware NOTE \u00b6 The Gray version core is configured in the FACES Kit, and our Core has several versions. Similarly, other versions of Core can be stacked on the base of the FACES. The following picture is a comparison of their main differences, which is convenient for you to use. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here .","title":"FACES Kit"},{"location":"m5stack/kit/faces/#faces-kit","text":"FACES Kit is a kit composed of M5Core GRAY, functional keyboards, FACES Base, FACES Charger and some accessories(including DuPont lines, lanyard, M3 fixing screws and so on). Currently, the functional keyboards are composed of GameBoy, Calculator and QWERTY ( For each functional keyboard, it's integrated MEGA328 chip, so that when you press a button, a corresponding value( hexadecimal format ) will be sent from keyboard to M5Core. They(keyboard and m5core) are communicating using I2C. And the I2C address of each keyboard is 0x08. ). We'll add other keyboards to FACES Kit. You can program it through Arduino IDE or MicroPython. For different applications, you can stack corresponding keyboard on FACES Base and burn corresponding firmware into M5Core. And here, you can learn more about FACES Base . NOTE: If you want to burn the factory firmware yourself, you need to download the M5Burner on our official website . Then connect FACES to PC through Type-C USB cable, burn FACES Kit firmware. Now, here's the picture of the whole kit.","title":"FACES Kit"},{"location":"m5stack/kit/faces/#1-gameboy-keyboard","text":"When create a handheld game, you can stack a GameBoy keyboard over FACES Base straight. And burn a Nintendo Entertainment System emulator. Here is the method of burning emulator and a game: download game","title":"1. GameBoy Keyboard"},{"location":"m5stack/kit/faces/#2-calculator-keyboard","text":"When create a calculator, you need the Calculator Keyboard. Burn your firmware into M5Core. The button which was pressed will execute the callback specifical function, so the calculator is created.","title":"2. Calculator Keyboard"},{"location":"m5stack/kit/faces/#3-qwerty-keyboard","text":"When your project needs full keyboard input, just to stack QWERTY over Base. Burn the following example(example function: M5Core and serial terminal will print button you pressed) source file of example - a. Arduino - b. MicroPython (for M5Cloud) M5Cloud usage - MicroPython(M5Cloud)","title":"3. QWERTY Keyboard"},{"location":"m5stack/kit/faces/#4-faces-charger","text":"FACES Charger built in some magnets. When charging, the FACES can be attached with charger. They are connected by PIGO Pin.","title":"4. FACES Charger"},{"location":"m5stack/kit/faces/#related-link","text":"Example MEGA328P Firmware","title":"Related Link"},{"location":"m5stack/kit/faces/#note","text":"The Gray version core is configured in the FACES Kit, and our Core has several versions. Similarly, other versions of Core can be stacked on the base of the FACES. The following picture is a comparison of their main differences, which is convenient for you to use. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here .","title":"NOTE"},{"location":"m5stack/kit/m5go/","text":"M5GO IOT Starter Kit \u00b6 Quick Start \u2014 Example \u2014 Schematic Description \u00b6 M5GO IOT Starter Kit is a kit designed for learning IOT programming which consists of 6 units(ENV, IR, RGB, PIR, ANGLE, HUB), one white M5Core(based on ESP32 chip) and a M5GO bottom . Programming M5GO with UIFlow or Arduino IDE. We also supply some courses for teaching IOT programming. If you are interesting in it, contact us through Email tech@m5stack.com please. Feature \u00b6 Programming Support Arduino ESP-IDF MicroPython TF Card Support (Up to 16G) PinMap \u00b6 MainBoard Pinmap \u00b6 LCD & TF Card LCD Pixel\uff1a320x240 Maximum storage of TF Card: 16GB ESP32 Chip GPIO23 GPIO19 GPIO18 GPIO14 GPIO27 GPIO33 GPIO32 GPIO4 ILI9341(LCD Driver) / MISO CLK CS DC RST BL TF Card MOSI MISO CLK CS Button & Speaker ESP32 Chip GPIO39 GPIO38 GPIO37 GPIO25 Button BUTTON A BUTTON B BUTTON C Speaker Speaker Pin GROVE A & IP5306 Power Management IC (IP5306) is a custom I2C version, and the IIC address of IP5306 is 0x75. Click here for view register manual. ESP32 Chip GPIO22 GPIO21 5V GND GROVE A SCL SDA 5V GND IP5306 SCL SDA 5V GND 9-axis IMU sensor(MPU9250) I2C Address: 0x68 ESP32 Chip GPIO22 GPIO21 5V GND MPU9250 SCL SDA 5V GND M5GO Base Pinmap \u00b6 GROVE B ESP32 Chip GPIO36 GPIO26 5V GND GROVE B GPIO36 GPIO26 5V GND GROVE C ESP32 Chip GPIO16 GPIO17 5V GND GROVE C RXD TXD 5V GND LED Bar & MicroPhone ESP32 Chip GPIO15 GPIO34 LED Bar SIG Pin MicroPhone MIC Pin PARAMETER \u00b6 M5Core Source Parameter ESP32 240MHz dual core, 600 DMIPS, 520KB SRAM, Wi-Fi, dual mode Bluetooth Flash & PSRAM 16MB Flash Input 5V @ 500mA Interface TypeC x 1, GROVE(I2C+I/0+UART) x 1 LCD 2 inch, 320x240 Colorful TFT LCD, ILI9342 Speaker 1W-0928 Microphone MEMS Analog BSE3729 Microphone LED SK6812 3535 RGB LED x 10 MEMS MPU9250 Battery 550mAh @ 3.7V, inside vb Op.Temp. 32\u00b0F to 104\u00b0F ( 0\u00b0C to 40\u00b0C ) Size 54 x 54 x 21 mm C.A.S.E Plastic ( PC ) NOTE: We have several kinds of Cores, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here . Include \u00b6 1x white M5Core 1x M5GO Base 6x Units 4x LEGO Accessories 3x GROVE Cables Type-C USB Cable User Manual Related Links \u00b6 Datasheet ESP32 MPU9250 Related Video \u00b6 m5stack instroduce","title":"M5GO Kit"},{"location":"m5stack/kit/m5go/#m5go-iot-starter-kit","text":"Quick Start \u2014 Example \u2014 Schematic","title":"M5GO IOT Starter Kit"},{"location":"m5stack/kit/m5go/#description","text":"M5GO IOT Starter Kit is a kit designed for learning IOT programming which consists of 6 units(ENV, IR, RGB, PIR, ANGLE, HUB), one white M5Core(based on ESP32 chip) and a M5GO bottom . Programming M5GO with UIFlow or Arduino IDE. We also supply some courses for teaching IOT programming. If you are interesting in it, contact us through Email tech@m5stack.com please.","title":"Description"},{"location":"m5stack/kit/m5go/#feature","text":"Programming Support Arduino ESP-IDF MicroPython TF Card Support (Up to 16G)","title":"Feature"},{"location":"m5stack/kit/m5go/#pinmap","text":"","title":"PinMap"},{"location":"m5stack/kit/m5go/#mainboard-pinmap","text":"LCD & TF Card LCD Pixel\uff1a320x240 Maximum storage of TF Card: 16GB ESP32 Chip GPIO23 GPIO19 GPIO18 GPIO14 GPIO27 GPIO33 GPIO32 GPIO4 ILI9341(LCD Driver) / MISO CLK CS DC RST BL TF Card MOSI MISO CLK CS Button & Speaker ESP32 Chip GPIO39 GPIO38 GPIO37 GPIO25 Button BUTTON A BUTTON B BUTTON C Speaker Speaker Pin GROVE A & IP5306 Power Management IC (IP5306) is a custom I2C version, and the IIC address of IP5306 is 0x75. Click here for view register manual. ESP32 Chip GPIO22 GPIO21 5V GND GROVE A SCL SDA 5V GND IP5306 SCL SDA 5V GND 9-axis IMU sensor(MPU9250) I2C Address: 0x68 ESP32 Chip GPIO22 GPIO21 5V GND MPU9250 SCL SDA 5V GND","title":"MainBoard Pinmap"},{"location":"m5stack/kit/m5go/#m5go-base-pinmap","text":"GROVE B ESP32 Chip GPIO36 GPIO26 5V GND GROVE B GPIO36 GPIO26 5V GND GROVE C ESP32 Chip GPIO16 GPIO17 5V GND GROVE C RXD TXD 5V GND LED Bar & MicroPhone ESP32 Chip GPIO15 GPIO34 LED Bar SIG Pin MicroPhone MIC Pin","title":"M5GO Base Pinmap"},{"location":"m5stack/kit/m5go/#parameter","text":"M5Core Source Parameter ESP32 240MHz dual core, 600 DMIPS, 520KB SRAM, Wi-Fi, dual mode Bluetooth Flash & PSRAM 16MB Flash Input 5V @ 500mA Interface TypeC x 1, GROVE(I2C+I/0+UART) x 1 LCD 2 inch, 320x240 Colorful TFT LCD, ILI9342 Speaker 1W-0928 Microphone MEMS Analog BSE3729 Microphone LED SK6812 3535 RGB LED x 10 MEMS MPU9250 Battery 550mAh @ 3.7V, inside vb Op.Temp. 32\u00b0F to 104\u00b0F ( 0\u00b0C to 40\u00b0C ) Size 54 x 54 x 21 mm C.A.S.E Plastic ( PC ) NOTE: We have several kinds of Cores, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here .","title":"PARAMETER"},{"location":"m5stack/kit/m5go/#include","text":"1x white M5Core 1x M5GO Base 6x Units 4x LEGO Accessories 3x GROVE Cables Type-C USB Cable User Manual","title":"Include"},{"location":"m5stack/kit/m5go/#related-links","text":"Datasheet ESP32 MPU9250","title":"Related Links"},{"location":"m5stack/kit/m5go/#related-video","text":"m5stack instroduce","title":"Related Video"},{"location":"m5stack/kit/proto/","text":"PROTO Experiment Kit \u00b6 see PROTO Module","title":"PROTO Kit"},{"location":"m5stack/kit/proto/#proto-experiment-kit","text":"see PROTO Module","title":"PROTO Experiment Kit"},{"location":"m5stack/kit/wristband/","text":"WRISTBAND Kit \u00b6","title":"WRISTBAND Kit"},{"location":"m5stack/kit/wristband/#wristband-kit","text":"","title":"WRISTBAND Kit"},{"location":"m5stack/kit/quickstart/faces-nes/","text":"Burn A NES Game \u00b6 This document will help you for burning a gameboy game(NES file) so that you can play a game with GameBoy Keyboard. Download firmware \u00b6 Download the gameboy simulator firmware named firmware.zip from Github . And unzip firmware.zip . Windows OS \u00b6 Mac OS \u00b6 Burn Game file \u00b6 Windows OS \u00b6 Open Flash Download Tools \u70b9\u51fb\u4e0b\u8f7d apply by Espressif, choose ESP32 DownloadTool option, choose 4 files, and execute those operations as the following pictures shown. ( choose firmware file, your serial port, erase and program flash ) Mac OS \u00b6 (1) install esptool \u00b6 Open terminal , execute this command pip install esptool (2) burn the game firmware \u00b6 Open terminal , go to the path where firmware.zip is located Execute the following commands in the terminal 1 2 3 4 unzip firmware.zip cd firmware esptool.py erase_flash sh flash.sh Reset you device \u00b6 After reset FACES, enjoy your game now. Info If you want another game, please change the Game file (.nes)","title":"FACES NES Game"},{"location":"m5stack/kit/quickstart/faces-nes/#burn-a-nes-game","text":"This document will help you for burning a gameboy game(NES file) so that you can play a game with GameBoy Keyboard.","title":"Burn A NES Game"},{"location":"m5stack/kit/quickstart/faces-nes/#download-firmware","text":"Download the gameboy simulator firmware named firmware.zip from Github . And unzip firmware.zip .","title":"Download firmware"},{"location":"m5stack/kit/quickstart/faces-nes/#windows-os","text":"","title":"Windows OS"},{"location":"m5stack/kit/quickstart/faces-nes/#mac-os","text":"","title":"Mac OS"},{"location":"m5stack/kit/quickstart/faces-nes/#burn-game-file","text":"","title":"Burn Game file"},{"location":"m5stack/kit/quickstart/faces-nes/#windows-os_1","text":"Open Flash Download Tools \u70b9\u51fb\u4e0b\u8f7d apply by Espressif, choose ESP32 DownloadTool option, choose 4 files, and execute those operations as the following pictures shown. ( choose firmware file, your serial port, erase and program flash )","title":"Windows OS"},{"location":"m5stack/kit/quickstart/faces-nes/#mac-os_1","text":"","title":"Mac OS"},{"location":"m5stack/kit/quickstart/faces-nes/#1-install-esptool","text":"Open terminal , execute this command pip install esptool","title":"(1) install esptool"},{"location":"m5stack/kit/quickstart/faces-nes/#2-burn-the-game-firmware","text":"Open terminal , go to the path where firmware.zip is located Execute the following commands in the terminal 1 2 3 4 unzip firmware.zip cd firmware esptool.py erase_flash sh flash.sh","title":"(2) burn the game firmware"},{"location":"m5stack/kit/quickstart/faces-nes/#reset-you-device","text":"After reset FACES, enjoy your game now. Info If you want another game, please change the Game file (.nes)","title":"Reset you device"},{"location":"m5stack/module/battery/","text":"M5Stack BATTERY Module \u00b6 Description \u00b6 BATTERY is a module with 700mAh High-Capacity Battery. User can create a portble device with any series of M5Stack Core and M5Stack BATTERY Module easily. Caution Do not use this battery module at the same time as other batteries (such as the M5 Core bottom battery). At the same time, in the worst case, there is a danger of catching fire. Feature \u00b6 700mAh High-Capacity Battery Include \u00b6 1x M5Stack BATTERY Module Related Link \u00b6 Offical Video Forum","title":"BATTERY"},{"location":"m5stack/module/battery/#m5stack-battery-module","text":"","title":"M5Stack BATTERY Module"},{"location":"m5stack/module/battery/#description","text":"BATTERY is a module with 700mAh High-Capacity Battery. User can create a portble device with any series of M5Stack Core and M5Stack BATTERY Module easily. Caution Do not use this battery module at the same time as other batteries (such as the M5 Core bottom battery). At the same time, in the worst case, there is a danger of catching fire.","title":"Description"},{"location":"m5stack/module/battery/#feature","text":"700mAh High-Capacity Battery","title":"Feature"},{"location":"m5stack/module/battery/#include","text":"1x M5Stack BATTERY Module","title":"Include"},{"location":"m5stack/module/battery/#related-link","text":"Offical Video Forum","title":"Related Link"},{"location":"m5stack/module/gps/","text":"GPS \u00b6 Description \u00b6 GPS is a module built in small GPS module. The small GPS module named UBLOX NEO-M8N. You can program it through Blockly, Arduino or MicroPython after connected to any series of M5Stack Core. GPS module is built on the high performing u-blox M8 GNSS engine and exhibit high performance and high sensitivity.And it can supply your global positioning information even you in the wild and get lost. The M5Stack Fire uses GPIO16 / 17 to connect to PSRAM by default, it overlaps with TXD / RXD (GPIO16, GPIO17) of GPS module. Therefore, when using the GPS module from the M5Stack Fire, it is necessary to cut the TXD and RXD default patterns on the GPS module with a cutter and connect them to another port using solder or 0\u03a9 resistance. Feature \u00b6 GPS NEO-M8N Module high-performance high-sensitivity Concurrent reception of up to 3 GNSS Industry leading \u2013167 dBm navigation sensitivity Include \u00b6 1x M5Stack GPS Module 1x M5Stack Antenna Application \u00b6 Child positioning bracelet Logistics Tracking Management based on GPS Related Link \u00b6 Offical Video Forum GPS Info (GPS) TinyGPS++ library Example \u00b6 Arduino IDE \u00b6 If you want the complete code GPSRaw.ino , please click here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <M5Stack.h> /* By default, GPS is connected with M5Core through UART2 */ HardwareSerial GPSRaw ( 2 ); void setup () { M5 . begin (); GPSRaw . begin ( 9600 ); // GPS init Serial . println ( \"hello\" ); termInit (); } void loop () { // put your main code here, to run repeatedly: if ( Serial . available ()) { int ch = Serial . read (); GPSRaw . write ( ch ); } if ( GPSRaw . available ()) { int ch = GPSRaw . read (); // read GPS information Serial . write ( ch ); termPutchar ( ch ); } } After burnt the example code GPSRaw.ino , m5core and PC serial terminal will display following information 1 2 3 4 5 6 7 8 $GPGSA,A,1,,,,,,,,,,,,,25.5,25.5,25.5*02 $BDGSA,A,1,,,,,,,,,,,,,25.5,25.5,25.5*13 $GPGSV,1,1,00*79 $BDGSV,1,1,00*68 $GNRMC,,V,,,,,,,,,,M*4E $GNVTG,,,,,,,,,M*2D $GNZDA,,,,,,*56 $GPTXT,01,01,01,ANTENNA OPEN*25 Schematic \u00b6","title":"GPS"},{"location":"m5stack/module/gps/#gps","text":"","title":"GPS"},{"location":"m5stack/module/gps/#description","text":"GPS is a module built in small GPS module. The small GPS module named UBLOX NEO-M8N. You can program it through Blockly, Arduino or MicroPython after connected to any series of M5Stack Core. GPS module is built on the high performing u-blox M8 GNSS engine and exhibit high performance and high sensitivity.And it can supply your global positioning information even you in the wild and get lost. The M5Stack Fire uses GPIO16 / 17 to connect to PSRAM by default, it overlaps with TXD / RXD (GPIO16, GPIO17) of GPS module. Therefore, when using the GPS module from the M5Stack Fire, it is necessary to cut the TXD and RXD default patterns on the GPS module with a cutter and connect them to another port using solder or 0\u03a9 resistance.","title":"Description"},{"location":"m5stack/module/gps/#feature","text":"GPS NEO-M8N Module high-performance high-sensitivity Concurrent reception of up to 3 GNSS Industry leading \u2013167 dBm navigation sensitivity","title":"Feature"},{"location":"m5stack/module/gps/#include","text":"1x M5Stack GPS Module 1x M5Stack Antenna","title":"Include"},{"location":"m5stack/module/gps/#application","text":"Child positioning bracelet Logistics Tracking Management based on GPS","title":"Application"},{"location":"m5stack/module/gps/#related-link","text":"Offical Video Forum GPS Info (GPS) TinyGPS++ library","title":"Related Link"},{"location":"m5stack/module/gps/#example","text":"","title":"Example"},{"location":"m5stack/module/gps/#arduino-ide","text":"If you want the complete code GPSRaw.ino , please click here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <M5Stack.h> /* By default, GPS is connected with M5Core through UART2 */ HardwareSerial GPSRaw ( 2 ); void setup () { M5 . begin (); GPSRaw . begin ( 9600 ); // GPS init Serial . println ( \"hello\" ); termInit (); } void loop () { // put your main code here, to run repeatedly: if ( Serial . available ()) { int ch = Serial . read (); GPSRaw . write ( ch ); } if ( GPSRaw . available ()) { int ch = GPSRaw . read (); // read GPS information Serial . write ( ch ); termPutchar ( ch ); } } After burnt the example code GPSRaw.ino , m5core and PC serial terminal will display following information 1 2 3 4 5 6 7 8 $GPGSA,A,1,,,,,,,,,,,,,25.5,25.5,25.5*02 $BDGSA,A,1,,,,,,,,,,,,,25.5,25.5,25.5*13 $GPGSV,1,1,00*79 $BDGSV,1,1,00*68 $GNRMC,,V,,,,,,,,,,M*4E $GNVTG,,,,,,,,,M*2D $GNZDA,,,,,,*56 $GPTXT,01,01,01,ANTENNA OPEN*25","title":"Arduino IDE"},{"location":"m5stack/module/gps/#schematic","text":"","title":"Schematic"},{"location":"m5stack/module/proto/","text":"M5Stack PROTO Module \u00b6 Description \u00b6 The M5Stack PROTO Module is a flexible blank circle with 30 pins which could connect with all series of M5Stack Core. You can create any circle that could controlled by any M5Stack Core on M5Stack PROTO Module as you like. Feature \u00b6 Flexible extended blank circle Compatible with all series of M5Stack Core Interface \u00b6 LINE0 LINE1 GND IO35(ADC1) GND IO36(ADC2) GND EN IO23(MOSI) IO25(DAC0) IO19(MISO) IO26(DAC1) IO18(EXT_SCK) 3V3 IO3(U1_RX) IO1(U1_TX) IO16(U1_RX) IO17(U2_TX) IO21(I2C_SDA) IO22(I2C_SCL) IO2 IO5 IO12(I2S_SCLK) IO13 IO15(I2S_OUT) IO0 HPOWR IO34 HPOWR 5V HPOWR BAT Include \u00b6 1x M5Stack PROTO Module Related Link \u00b6 Offical Video Forum","title":"PROTO"},{"location":"m5stack/module/proto/#m5stack-proto-module","text":"","title":"M5Stack PROTO Module"},{"location":"m5stack/module/proto/#description","text":"The M5Stack PROTO Module is a flexible blank circle with 30 pins which could connect with all series of M5Stack Core. You can create any circle that could controlled by any M5Stack Core on M5Stack PROTO Module as you like.","title":"Description"},{"location":"m5stack/module/proto/#feature","text":"Flexible extended blank circle Compatible with all series of M5Stack Core","title":"Feature"},{"location":"m5stack/module/proto/#interface","text":"LINE0 LINE1 GND IO35(ADC1) GND IO36(ADC2) GND EN IO23(MOSI) IO25(DAC0) IO19(MISO) IO26(DAC1) IO18(EXT_SCK) 3V3 IO3(U1_RX) IO1(U1_TX) IO16(U1_RX) IO17(U2_TX) IO21(I2C_SDA) IO22(I2C_SCL) IO2 IO5 IO12(I2S_SCLK) IO13 IO15(I2S_OUT) IO0 HPOWR IO34 HPOWR 5V HPOWR BAT","title":"Interface"},{"location":"m5stack/module/proto/#include","text":"1x M5Stack PROTO Module","title":"Include"},{"location":"m5stack/module/proto/#related-link","text":"Offical Video Forum","title":"Related Link"},{"location":"m5stack/related-documents/burn-firmware/","text":"How to Burn Firmware \u00b6 This article will guide you how to burn a right firmware to your board via M5Burner. Windows \u00b6 1. Install USB driver \u00b6 If you have not installed the CP2104 USB driver yet, read here . Otherwise, Start directly from step 2. 2. Download M5Burner \u00b6 For downloading M5Burner, visit the M5Stack Website please. 3. Burn the firmware \u00b6 Unzip the M5Burner tool which you donwloaded for official website just now, then double click M5Burner.exe . Then choice the serial port which is connected with your board and the Baud which is 921600 following below steps. Choice a right firmware, click Erase and then click Burn . If you want to program with UIFlow (/ M5Cloud ), select M5Flow-vx.x (/ M5Cloud-vx.x.x ) option(the lastest version). If you own a ESP32CAM (/ M5CAMERA), select M5Cam-vx.x (/M5Cam-psram) option !> Notice If it does not display any COMx port or only COM1 exists at the option, you need to visit this article establish serial connection and reinstall the USB driver. a. Choice a right firmware a. select M5Flow-vx.x option(the lastest version), if you want to program with UIFlow b. select M5Cam-vx.x (/M5Cam-psram) option, if you own a ESP32CAM (/ M5CAMERA) b. Click Erase If M5Burner shows the information Hard resetting via RTS pin... below, it means chip has been erased successfully. If M5Burner shows the information Leaving... Staying in bootloader. below, it means chip has been burnt successfully. 3. Then reset your board \u00b6 Info If M5Burner means be busy after clicking Burn , please wait for a few minutes. It'll be normal after the firmware has been burnt successfully. Info If the burning procedure has been interrupted(like M5Burner has been closed suddenly... ), it's better to burn your board again. MacOS \u00b6 1. Install USB Driver (If you have not install USB driver, follow this step. Otherwise, jump to step 2 directly.) \u00b6 The first thing to do is to visit the official website https://m5stack.com , then select Explore -> Download from the top menu, download the M5Burner and the CP21X Driver . Once the driver download is complete. Open the driver file as shown below. Now, the USB driver has been installed successfully. You must now allow the operating system to run third-party applications. Open the search , then find the Terminal application.app and start it by pressing Enter . Now write the line below and press Enter . Now, click on the Apple in the upper left corner, then open System Preferences... , then open Security & Privacy . Make sure you have the radio check box set to Anywhere (if not, check it). 2. Open M5Burner \u00b6 Now go back to the browser to Downloads button and open the file with the Ctrl key pressed. 3. Burn the firmware \u00b6 So, now connect your device to your Mac with a USB cable. Select the corresponding SOFTWARE version (Normally, select the lastest version) and click on the Flash button. At the end of the process, the indicator will be completely painted. Once the device is flashed - disconnect the cable from the Mac and press the red button (the same power button) on the M5. Linux \u00b6 1. Install pip and esptool \u00b6 Open the terminal, enter the following command according to your system version for installing Python package management tool pip . Centos7: 1 sudo yum install python-pip Ubuntu and Debian: 1 sudo apt-get install python-pip Arch: 1 sudo pacman -S --needed python-pip After installing pip successfully, enter sudo pip install esptool for installing esptool . 2. Download the last version of M5Burner \u00b6 Access UIFlow , download the MacOS version installer M5Burner-Flow-For-MacOS , and unzip it. 3. Execute \u00b6 Creat a new folder M5burner , and copy M5Burner_MacOS/M5Burner_MacOS.app/Contents/Resources/firmware/M5Flow/ to ~/M5burner If you want to bun v1.1.1 version firmware, switch the current directory to the corresponding directory e.g. cd ~/M5burner/M5Flow/v1.1.1-en Plug the M5Core in, and enter sudo chmod +x *.sh for granting root authority, and run sudo ./flash.sh Video Tutorial \u00b6 Windows","title":"How to Burn Firmware"},{"location":"m5stack/related-documents/burn-firmware/#how-to-burn-firmware","text":"This article will guide you how to burn a right firmware to your board via M5Burner.","title":"How to Burn Firmware"},{"location":"m5stack/related-documents/burn-firmware/#windows","text":"","title":"Windows"},{"location":"m5stack/related-documents/burn-firmware/#1-install-usb-driver","text":"If you have not installed the CP2104 USB driver yet, read here . Otherwise, Start directly from step 2.","title":"1. Install USB driver"},{"location":"m5stack/related-documents/burn-firmware/#2-download-m5burner","text":"For downloading M5Burner, visit the M5Stack Website please.","title":"2. Download M5Burner"},{"location":"m5stack/related-documents/burn-firmware/#3-burn-the-firmware","text":"Unzip the M5Burner tool which you donwloaded for official website just now, then double click M5Burner.exe . Then choice the serial port which is connected with your board and the Baud which is 921600 following below steps. Choice a right firmware, click Erase and then click Burn . If you want to program with UIFlow (/ M5Cloud ), select M5Flow-vx.x (/ M5Cloud-vx.x.x ) option(the lastest version). If you own a ESP32CAM (/ M5CAMERA), select M5Cam-vx.x (/M5Cam-psram) option !> Notice If it does not display any COMx port or only COM1 exists at the option, you need to visit this article establish serial connection and reinstall the USB driver. a. Choice a right firmware a. select M5Flow-vx.x option(the lastest version), if you want to program with UIFlow b. select M5Cam-vx.x (/M5Cam-psram) option, if you own a ESP32CAM (/ M5CAMERA) b. Click Erase If M5Burner shows the information Hard resetting via RTS pin... below, it means chip has been erased successfully. If M5Burner shows the information Leaving... Staying in bootloader. below, it means chip has been burnt successfully.","title":"3. Burn the firmware"},{"location":"m5stack/related-documents/burn-firmware/#3-then-reset-your-board","text":"Info If M5Burner means be busy after clicking Burn , please wait for a few minutes. It'll be normal after the firmware has been burnt successfully. Info If the burning procedure has been interrupted(like M5Burner has been closed suddenly... ), it's better to burn your board again.","title":"3. Then reset your board"},{"location":"m5stack/related-documents/burn-firmware/#macos","text":"","title":"MacOS"},{"location":"m5stack/related-documents/burn-firmware/#1-install-usb-driver-if-you-have-not-install-usb-driver-follow-this-step-otherwise-jump-to-step-2-directly","text":"The first thing to do is to visit the official website https://m5stack.com , then select Explore -> Download from the top menu, download the M5Burner and the CP21X Driver . Once the driver download is complete. Open the driver file as shown below. Now, the USB driver has been installed successfully. You must now allow the operating system to run third-party applications. Open the search , then find the Terminal application.app and start it by pressing Enter . Now write the line below and press Enter . Now, click on the Apple in the upper left corner, then open System Preferences... , then open Security & Privacy . Make sure you have the radio check box set to Anywhere (if not, check it).","title":"1. Install USB Driver (If you have not install USB driver, follow this step. Otherwise, jump to step 2 directly.)"},{"location":"m5stack/related-documents/burn-firmware/#2-open-m5burner","text":"Now go back to the browser to Downloads button and open the file with the Ctrl key pressed.","title":"2. Open M5Burner"},{"location":"m5stack/related-documents/burn-firmware/#3-burn-the-firmware_1","text":"So, now connect your device to your Mac with a USB cable. Select the corresponding SOFTWARE version (Normally, select the lastest version) and click on the Flash button. At the end of the process, the indicator will be completely painted. Once the device is flashed - disconnect the cable from the Mac and press the red button (the same power button) on the M5.","title":"3. Burn the firmware"},{"location":"m5stack/related-documents/burn-firmware/#linux","text":"","title":"Linux"},{"location":"m5stack/related-documents/burn-firmware/#1-install-pip-and-esptool","text":"Open the terminal, enter the following command according to your system version for installing Python package management tool pip . Centos7: 1 sudo yum install python-pip Ubuntu and Debian: 1 sudo apt-get install python-pip Arch: 1 sudo pacman -S --needed python-pip After installing pip successfully, enter sudo pip install esptool for installing esptool .","title":"1. Install pip and esptool"},{"location":"m5stack/related-documents/burn-firmware/#2-download-the-last-version-of-m5burner","text":"Access UIFlow , download the MacOS version installer M5Burner-Flow-For-MacOS , and unzip it.","title":"2. Download the last version of M5Burner"},{"location":"m5stack/related-documents/burn-firmware/#3-execute","text":"Creat a new folder M5burner , and copy M5Burner_MacOS/M5Burner_MacOS.app/Contents/Resources/firmware/M5Flow/ to ~/M5burner If you want to bun v1.1.1 version firmware, switch the current directory to the corresponding directory e.g. cd ~/M5burner/M5Flow/v1.1.1-en Plug the M5Core in, and enter sudo chmod +x *.sh for granting root authority, and run sudo ./flash.sh","title":"3. Execute"},{"location":"m5stack/related-documents/burn-firmware/#video-tutorial","text":"Windows","title":"Video Tutorial"},{"location":"m5stack/related-documents/git-arduino/","text":"How to install Git and Arduino IDE (Windows) \u00b6 1. Install Git \u00b6 If you has installed Git , please following next setp 2 straight.Otherwise, download the client of Git and install it. 2. Install Arduino IDE \u00b6 download address https://www.arduino.cc/en/Main/Software Double click to install Arduino IDE","title":"How to Install Git and Arduino"},{"location":"m5stack/related-documents/git-arduino/#how-to-install-git-and-arduino-ide-windows","text":"","title":"How to install Git and Arduino IDE (Windows)"},{"location":"m5stack/related-documents/git-arduino/#1-install-git","text":"If you has installed Git , please following next setp 2 straight.Otherwise, download the client of Git and install it.","title":"1. Install Git"},{"location":"m5stack/related-documents/git-arduino/#2-install-arduino-ide","text":"download address https://www.arduino.cc/en/Main/Software Double click to install Arduino IDE","title":"2. Install Arduino IDE"},{"location":"m5stack/related-documents/overview/","text":"Related Documents \u00b6 Establish Serial Connection How to Install Git and Arduino Upgrade M5Stack Lib How to Burn Firmware How to Connect WiFi Using Core","title":"Overview"},{"location":"m5stack/related-documents/overview/#related-documents","text":"Establish Serial Connection How to Install Git and Arduino Upgrade M5Stack Lib How to Burn Firmware How to Connect WiFi Using Core","title":"Related Documents"},{"location":"m5stack/related-documents/serial-connection/","text":"Establish Serial Connection \u00b6 This section provides guidance how to establish serial connection between your board and PC. For macOS \u00b6 1. Install the USB driver \u00b6 Download the SiLabs CP2104 Driver After the disk image SiLabsUSBDriverDisk.dmg was downloaded, mount it. And install this USB driver following those screenshots. 2. Check port on MacOS \u00b6 To check the device name for the serial port of your your board board (or external converter dongle), open terminal and run this command two times, first with the board / dongle unplugged, then with plugged in. The port which appears the second time is the one you need: MacOS 1 ls /dev/cu.* For Windows \u00b6 1.Install the USB driver \u00b6 Download the SiLabs CP2104 Driver Choice the version of USB driver according to your windows version(Windows\u215e/10). Choice the right version installer(x64/x86), and install it. 2. Check port on Windows \u00b6 Check the list of identified COM ports in the Windows Device Manager. Disconnect your board and connect it back, to verify which port disappears from the list and then shows back again. Figures below show serial port for M5Stack Core board","title":"Establish Serial Connection"},{"location":"m5stack/related-documents/serial-connection/#establish-serial-connection","text":"This section provides guidance how to establish serial connection between your board and PC.","title":"Establish Serial Connection"},{"location":"m5stack/related-documents/serial-connection/#for-macos","text":"","title":"For macOS"},{"location":"m5stack/related-documents/serial-connection/#1-install-the-usb-driver","text":"Download the SiLabs CP2104 Driver After the disk image SiLabsUSBDriverDisk.dmg was downloaded, mount it. And install this USB driver following those screenshots.","title":"1. Install the USB driver"},{"location":"m5stack/related-documents/serial-connection/#2-check-port-on-macos","text":"To check the device name for the serial port of your your board board (or external converter dongle), open terminal and run this command two times, first with the board / dongle unplugged, then with plugged in. The port which appears the second time is the one you need: MacOS 1 ls /dev/cu.*","title":"2. Check port on MacOS"},{"location":"m5stack/related-documents/serial-connection/#for-windows","text":"","title":"For Windows"},{"location":"m5stack/related-documents/serial-connection/#1install-the-usb-driver","text":"Download the SiLabs CP2104 Driver Choice the version of USB driver according to your windows version(Windows\u215e/10). Choice the right version installer(x64/x86), and install it.","title":"1.Install the USB driver"},{"location":"m5stack/related-documents/serial-connection/#2-check-port-on-windows","text":"Check the list of identified COM ports in the Windows Device Manager. Disconnect your board and connect it back, to verify which port disappears from the list and then shows back again. Figures below show serial port for M5Stack Core board","title":"2. Check port on Windows"},{"location":"m5stack/related-documents/upgrade-lib/","text":"Upgrade M5Stack Lib \u00b6 1. Start up Arduino IDE, then Select Sketch -> Include Library -> Manage Libraries... \u00b6 2. Type M5Stack into the search box, search it. \u00b6 3. If it shows as below figure, click Update . \u00b6 But if it shows Install , it means you has not installed M5Stack Lib. So, you need click Install for installing lib.","title":"Upgrade M5Stack Lib"},{"location":"m5stack/related-documents/upgrade-lib/#upgrade-m5stack-lib","text":"","title":"Upgrade M5Stack Lib"},{"location":"m5stack/related-documents/upgrade-lib/#1-start-up-arduino-ide-then-select-sketch-include-library-manage-libraries","text":"","title":"1. Start up Arduino IDE, then Select Sketch-&gt;Include Library-&gt;Manage Libraries..."},{"location":"m5stack/related-documents/upgrade-lib/#2-type-m5stack-into-the-search-box-search-it","text":"","title":"2. Type M5Stack into the search box, search it."},{"location":"m5stack/related-documents/upgrade-lib/#3-if-it-shows-as-below-figure-click-update","text":"But if it shows Install , it means you has not installed M5Stack Lib. So, you need click Install for installing lib.","title":"3. If it shows as below figure, click Update."},{"location":"m5stack/related-documents/wifi-core/","text":"How to Connect WIFI Using Core \u00b6 Info If your M5Stack Core was not burnt with a specific firmware named UIFlow in advance, please visit this article How to burn firmware for burnning) After powering on Core and pressing the red button on the left hand side of the M5\uff0cyou will be greeted by this screen. Let's connect to networkable AP. 1. Press UPLOAD Button \u00b6 Now, press the upload buttom. The screen will show this message. 2. Select Networkable AP \u00b6 Use Mobile Phone or PC for connectting to M5Core AP(like M5Stack-a67c ), and then open brower to login 192.168.4.1 for setting your networkable WIFI name and password. (Now, my networkable wifi is named MasterHax_5G ) 3. Reset Your Device \u00b6 After connected wifi successfully, reset your core according to the prompt on 192.168.4.1 Complete \u00b6 Once you've reset M5Stack Core, pressed the upload buttom, you will arrive at a screen with a QR code. Now, you can try to program with your core following this article Quick Start with UIFlow Info Similarly, if you want another networkable WIFI AP to connect with Core, press the SETUP buttom while core was power-up. Video Tutorial \u00b6 WIFI Configuration","title":"How to Connect WiFi Using Core"},{"location":"m5stack/related-documents/wifi-core/#how-to-connect-wifi-using-core","text":"Info If your M5Stack Core was not burnt with a specific firmware named UIFlow in advance, please visit this article How to burn firmware for burnning) After powering on Core and pressing the red button on the left hand side of the M5\uff0cyou will be greeted by this screen. Let's connect to networkable AP.","title":"How to Connect WIFI Using Core"},{"location":"m5stack/related-documents/wifi-core/#1-press-upload-button","text":"Now, press the upload buttom. The screen will show this message.","title":"1. Press UPLOAD Button"},{"location":"m5stack/related-documents/wifi-core/#2-select-networkable-ap","text":"Use Mobile Phone or PC for connectting to M5Core AP(like M5Stack-a67c ), and then open brower to login 192.168.4.1 for setting your networkable WIFI name and password. (Now, my networkable wifi is named MasterHax_5G )","title":"2. Select Networkable AP"},{"location":"m5stack/related-documents/wifi-core/#3-reset-your-device","text":"After connected wifi successfully, reset your core according to the prompt on 192.168.4.1","title":"3. Reset Your Device"},{"location":"m5stack/related-documents/wifi-core/#complete","text":"Once you've reset M5Stack Core, pressed the upload buttom, you will arrive at a screen with a QR code. Now, you can try to program with your core following this article Quick Start with UIFlow Info Similarly, if you want another networkable WIFI AP to connect with Core, press the SETUP buttom while core was power-up.","title":"Complete"},{"location":"m5stack/related-documents/wifi-core/#video-tutorial","text":"WIFI Configuration","title":"Video Tutorial"},{"location":"m5stack/related-documents/wifi-m5cloud/","text":"How to Connect WIFI (For M5Cloud) \u00b6 Info If your M5Stack Core was not burnt with a specific firmware named M5Cloud in advance, please visit this article How to burn firmware for burnning) After powering on Core\uff0cyou will be greeted by this screen. Let's connect to networkable AP. 1. Connect to M5Core AP \u00b6 Use Mobile Phone or PC for connectting to M5Core AP(like M5Stack-a67c ) 2. Select Networkable AP \u00b6 Then open brower to login 192.168.4.1 for setting your networkable WIFI name and password. (Now, my networkable wifi is named MasterHax_2.4G ) ?> Note If you connect wifi unsuccessfully, repeat it again please. 3. Reset Your Device \u00b6 After connected wifi successfully, reset your core according to the prompt on 192.168.4.1 ?> Note If your device has been bound to M5Cloud's account before(means you have entered the check code on M5Cloud ), the screen will display as below Complete \u00b6 Now, you can try to program with your core following this article Quick Start with M5Cloud","title":"How to Connect WiFi Using M5Cloud"},{"location":"m5stack/related-documents/wifi-m5cloud/#how-to-connect-wifi-for-m5cloud","text":"Info If your M5Stack Core was not burnt with a specific firmware named M5Cloud in advance, please visit this article How to burn firmware for burnning) After powering on Core\uff0cyou will be greeted by this screen. Let's connect to networkable AP.","title":"How to Connect WIFI (For M5Cloud)"},{"location":"m5stack/related-documents/wifi-m5cloud/#1-connect-to-m5core-ap","text":"Use Mobile Phone or PC for connectting to M5Core AP(like M5Stack-a67c )","title":"1. Connect to M5Core AP"},{"location":"m5stack/related-documents/wifi-m5cloud/#2-select-networkable-ap","text":"Then open brower to login 192.168.4.1 for setting your networkable WIFI name and password. (Now, my networkable wifi is named MasterHax_2.4G ) ?> Note If you connect wifi unsuccessfully, repeat it again please.","title":"2. Select Networkable AP"},{"location":"m5stack/related-documents/wifi-m5cloud/#3-reset-your-device","text":"After connected wifi successfully, reset your core according to the prompt on 192.168.4.1 ?> Note If your device has been bound to M5Cloud's account before(means you have entered the check code on M5Cloud ), the screen will display as below","title":"3. Reset Your Device"},{"location":"m5stack/related-documents/wifi-m5cloud/#complete","text":"Now, you can try to program with your core following this article Quick Start with M5Cloud","title":"Complete"},{"location":"m5stack/unit/m5camera/","text":"M5CAMERA \u00b6 Quick Start Description \u00b6 The M5Camera is a camera unit based on ESP32 chip and OV2640 including PSRAM . You can even program it through ESP-IDF or Arduino IDE. There are two versions of M5Camera Unit: A Model and B Model. This Unit reserves the weld of the 9-axis gyroscope (MPU6050), Temperature and humidity pressure sensor (BME280) and Digital silicon microphone (SPM1423) . If you need those devices, you can Self-weld them or purchase those version thraightly. Additionally, M5Camera also reserves the weld of battery. Note: M5Camera is named differently when different hardware is selected. They follow the rules below. M5Camera_#_#... means optional hardware name follows \"M5Camera\". If configured with MPU6050, will be named M5Camera_6050 If also configured with microphone, will be named M5Camera_6050_MIC If also configured with BME280, will be named M5Camera_6050_MIC_BME280 Feature \u00b6 ESP32 specifications Dual-core Tensilica LX6 microprocessor Up to 240MHz clock frequency 4MB PSRAM 4MB Flash memory Integrated 802.11 BGN WiFi transceiver Integrated dual-mode Bluetooth (classic and BLE) Hardware accelerated encryption (AES, SHA2, ECC, RSA-4096) CP2104 USB-to-TTL converter OV2640 sensor Output Formats(8-bit): YUV(422/420)/YCbCr422 RGB565/555 8-bit compressed data 8-/10-bit Raw RGB data Maximum Image Transfer Rate according to specific format UXGA/SXGA: 15fps SVGA: 30fps CIF: 60fps Scan Mode: Progressive Camera specifications CCD size : \u00bcinch Field of View : 78 degree Maxmium Pixel: 200W Sensor best resolution: 1600 * 1200 Dimension: 40 \u00d7 49 \u00d7 13mm Include \u00b6 1x M5 Camera 1x Type-C USB Cable PinMap \u00b6 There are two versions of M5Camera Unit: A Model and B Model. Camera Interface PinMap Interface Camera Pin M5Camera(A model) M5Camera(B model) SCCB Clock SIOC IO23 IO23 SCCB Data SIOD IO25 IO22 System Clock XCLK IO27 IO27 Vertical Sync VSYNC IO22 IO25 Horizontal Reference HREF IO26 IO26 Pixel Clock PCLK IO21 IO21 Pixel Data Bit 0 D2 IO32 IO32 Pixel Data Bit 1 D3 IO35 IO35 Pixel Data Bit 2 D4 IO34 IO34 Pixel Data Bit 3 D5 IO5 IO5 Pixel Data Bit 4 D6 IO39 IO39 Pixel Data Bit 5 D7 IO18 IO18 Pixel Data Bit 6 D8 IO36 IO36 Pixel Data Bit 7 D9 IO19 IO19 Camera Reset RESET IO15 IO15 Camera Power Down PWDN see Note 1 see Note 1 Power Supply 3.3V 3V3 3V3 3V3 Ground GND GND GND GROVE Interface Grove M5Camera(A model) M5Camera(B model) SCL IO13 IO13 SDA IO12 IO4 5V 5V 5V GND GND GND LED Interface LED M5Camera(A model) M5Camera(B model) LED_Pin IO14 IO14 The following tables are Reserved Chip Interfaces BME280 Interface It's IIC address is 0x76. BME280 M5Camera(A model) M5Camera(B model) SCL IO23 IO23 SDA IO22 IO22 MPU6050 Interface It's IIC address is 0x68. MPU6050 M5Camera(A model) M5Camera(B model) SCL IO23 IO23 SDA IO22 IO22 MIC(SPM1423) Interface MIC(SPM1423) M5Camera(A model) M5Camera(B model) SCL IO2 IO2 SDA IO4 IO4 NOTE: Camera Power Down pin does not need to be connected to ESP32 GPIO. Instead it may be pulled down to ground with 10 kOhm resistor. We have several kinds of camera boards, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here . Related Link \u00b6 Offical Video Forum Datasheet - ESP32 - OV2640 Code \u00b6 Firmware \u00b6 A Model B Model Example \u00b6 Color recognition Face recognition Schematic \u00b6 Power circuit \u00b6 Chip peripheral circuit \u00b6 USB to serial port part of the circuit \u00b6 Related Video \u00b6 M5Camera Application - Image transmission between M5Camera and M5Core","title":"M5Camera"},{"location":"m5stack/unit/m5camera/#m5camera","text":"Quick Start","title":"M5CAMERA"},{"location":"m5stack/unit/m5camera/#description","text":"The M5Camera is a camera unit based on ESP32 chip and OV2640 including PSRAM . You can even program it through ESP-IDF or Arduino IDE. There are two versions of M5Camera Unit: A Model and B Model. This Unit reserves the weld of the 9-axis gyroscope (MPU6050), Temperature and humidity pressure sensor (BME280) and Digital silicon microphone (SPM1423) . If you need those devices, you can Self-weld them or purchase those version thraightly. Additionally, M5Camera also reserves the weld of battery. Note: M5Camera is named differently when different hardware is selected. They follow the rules below. M5Camera_#_#... means optional hardware name follows \"M5Camera\". If configured with MPU6050, will be named M5Camera_6050 If also configured with microphone, will be named M5Camera_6050_MIC If also configured with BME280, will be named M5Camera_6050_MIC_BME280","title":"Description"},{"location":"m5stack/unit/m5camera/#feature","text":"ESP32 specifications Dual-core Tensilica LX6 microprocessor Up to 240MHz clock frequency 4MB PSRAM 4MB Flash memory Integrated 802.11 BGN WiFi transceiver Integrated dual-mode Bluetooth (classic and BLE) Hardware accelerated encryption (AES, SHA2, ECC, RSA-4096) CP2104 USB-to-TTL converter OV2640 sensor Output Formats(8-bit): YUV(422/420)/YCbCr422 RGB565/555 8-bit compressed data 8-/10-bit Raw RGB data Maximum Image Transfer Rate according to specific format UXGA/SXGA: 15fps SVGA: 30fps CIF: 60fps Scan Mode: Progressive Camera specifications CCD size : \u00bcinch Field of View : 78 degree Maxmium Pixel: 200W Sensor best resolution: 1600 * 1200 Dimension: 40 \u00d7 49 \u00d7 13mm","title":"Feature"},{"location":"m5stack/unit/m5camera/#include","text":"1x M5 Camera 1x Type-C USB Cable","title":"Include"},{"location":"m5stack/unit/m5camera/#pinmap","text":"There are two versions of M5Camera Unit: A Model and B Model. Camera Interface PinMap Interface Camera Pin M5Camera(A model) M5Camera(B model) SCCB Clock SIOC IO23 IO23 SCCB Data SIOD IO25 IO22 System Clock XCLK IO27 IO27 Vertical Sync VSYNC IO22 IO25 Horizontal Reference HREF IO26 IO26 Pixel Clock PCLK IO21 IO21 Pixel Data Bit 0 D2 IO32 IO32 Pixel Data Bit 1 D3 IO35 IO35 Pixel Data Bit 2 D4 IO34 IO34 Pixel Data Bit 3 D5 IO5 IO5 Pixel Data Bit 4 D6 IO39 IO39 Pixel Data Bit 5 D7 IO18 IO18 Pixel Data Bit 6 D8 IO36 IO36 Pixel Data Bit 7 D9 IO19 IO19 Camera Reset RESET IO15 IO15 Camera Power Down PWDN see Note 1 see Note 1 Power Supply 3.3V 3V3 3V3 3V3 Ground GND GND GND GROVE Interface Grove M5Camera(A model) M5Camera(B model) SCL IO13 IO13 SDA IO12 IO4 5V 5V 5V GND GND GND LED Interface LED M5Camera(A model) M5Camera(B model) LED_Pin IO14 IO14 The following tables are Reserved Chip Interfaces BME280 Interface It's IIC address is 0x76. BME280 M5Camera(A model) M5Camera(B model) SCL IO23 IO23 SDA IO22 IO22 MPU6050 Interface It's IIC address is 0x68. MPU6050 M5Camera(A model) M5Camera(B model) SCL IO23 IO23 SDA IO22 IO22 MIC(SPM1423) Interface MIC(SPM1423) M5Camera(A model) M5Camera(B model) SCL IO2 IO2 SDA IO4 IO4 NOTE: Camera Power Down pin does not need to be connected to ESP32 GPIO. Instead it may be pulled down to ground with 10 kOhm resistor. We have several kinds of camera boards, the following figures show the main differece with them. If you want to view the detailed defference with them, please click here . If you want to download the detailed defference with them, please click here .","title":"PinMap"},{"location":"m5stack/unit/m5camera/#related-link","text":"Offical Video Forum Datasheet - ESP32 - OV2640","title":"Related Link"},{"location":"m5stack/unit/m5camera/#code","text":"","title":"Code"},{"location":"m5stack/unit/m5camera/#firmware","text":"A Model B Model","title":"Firmware"},{"location":"m5stack/unit/m5camera/#example","text":"Color recognition Face recognition","title":"Example"},{"location":"m5stack/unit/m5camera/#schematic","text":"","title":"Schematic"},{"location":"m5stack/unit/m5camera/#power-circuit","text":"","title":"Power circuit"},{"location":"m5stack/unit/m5camera/#chip-peripheral-circuit","text":"","title":"Chip peripheral circuit"},{"location":"m5stack/unit/m5camera/#usb-to-serial-port-part-of-the-circuit","text":"","title":"USB to serial port part of the circuit"},{"location":"m5stack/unit/m5camera/#related-video","text":"M5Camera Application - Image transmission between M5Camera and M5Core","title":"Related Video"},{"location":"m5stack/unit/quickstart/","text":"ESP32Cam/M5Camera Quick Start \u00b6 Text Tutorial \u00b6 It is really really out of the box. Your ESP32Cam/M5Camera will immediately run without any code after you power it. plug usb cable into ESP32Cam/M5Camera and open the serial terminal on your computer. Then waitting a few seconds, you connect to a AP named \" M5CAM \" with your computer(or mobile phone). And you open the browser on the computer(or mobile phone), enter a URL http://192.168.4.1 . At the moment, your can see the real-time transmission of video by ESP32Cam/M5Camera on the browser. Now, A WebCam you achieved successfully ! Note: ESP32Cam/M5Camera AP only can connect with one device at a time. Video Tutorial \u00b6 Firmware \u00b6 ESP32Cam Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/NoPsram M5Camera(A model) Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/master M5Camera(B model) Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/master M5CameraX Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/master M5CameraF Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/FishEye","title":"Quickstart"},{"location":"m5stack/unit/quickstart/#esp32camm5camera-quick-start","text":"","title":"ESP32Cam/M5Camera Quick Start"},{"location":"m5stack/unit/quickstart/#text-tutorial","text":"It is really really out of the box. Your ESP32Cam/M5Camera will immediately run without any code after you power it. plug usb cable into ESP32Cam/M5Camera and open the serial terminal on your computer. Then waitting a few seconds, you connect to a AP named \" M5CAM \" with your computer(or mobile phone). And you open the browser on the computer(or mobile phone), enter a URL http://192.168.4.1 . At the moment, your can see the real-time transmission of video by ESP32Cam/M5Camera on the browser. Now, A WebCam you achieved successfully ! Note: ESP32Cam/M5Camera AP only can connect with one device at a time.","title":"Text Tutorial"},{"location":"m5stack/unit/quickstart/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"m5stack/unit/quickstart/#firmware","text":"ESP32Cam Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/NoPsram M5Camera(A model) Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/master M5Camera(B model) Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/master M5CameraX Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/master M5CameraF Firmware: https://github.com/m5stack/m5stack-cam-psram/tree/FishEye","title":"Firmware"},{"location":"tec-egg/examples/","text":"Here are the examples for the eggs \u00b6 blink \u00b6 A sample project is provided in 01blink.sb . Have fun. ampel 1 \u00b6 A sample project is provided in 02ampel01.sb . Have fun. ampel 2 \u00b6 A sample project is provided in 03ampel02.sb . Have fun. leds \u00b6 A sample project is provided in 04leds.sb . Have fun. lauflicht \u00b6 A sample project is provided in 05lauflicht.sb . Have fun. leds 7 \u00b6 A sample project is provided in 06leds7.sb . Have fun. wuerfel \u00b6 A sample project is provided in 07wuerfel.sb . Have fun.","title":"Raspberry Pi"},{"location":"tec-egg/examples/#here-are-the-examples-for-the-eggs","text":"","title":"Here are the examples for the eggs"},{"location":"tec-egg/examples/#blink","text":"A sample project is provided in 01blink.sb . Have fun.","title":"blink"},{"location":"tec-egg/examples/#ampel-1","text":"A sample project is provided in 02ampel01.sb . Have fun.","title":"ampel 1"},{"location":"tec-egg/examples/#ampel-2","text":"A sample project is provided in 03ampel02.sb . Have fun.","title":"ampel 2"},{"location":"tec-egg/examples/#leds","text":"A sample project is provided in 04leds.sb . Have fun.","title":"leds"},{"location":"tec-egg/examples/#lauflicht","text":"A sample project is provided in 05lauflicht.sb . Have fun.","title":"lauflicht"},{"location":"tec-egg/examples/#leds-7","text":"A sample project is provided in 06leds7.sb . Have fun.","title":"leds 7"},{"location":"tec-egg/examples/#wuerfel","text":"A sample project is provided in 07wuerfel.sb . Have fun.","title":"wuerfel"},{"location":"tec-egg/overview/","text":"TEC- EGG Products \u00b6 This documentation describes all three Tec-Egg products \u00b6 Tec-Egg Raspberry Pi Tec-Egg Solar Tec-Egg Ultrasonic Examples","title":"Overview"},{"location":"tec-egg/overview/#tec-egg-products","text":"","title":"TEC- EGG Products"},{"location":"tec-egg/overview/#this-documentation-describes-all-three-tec-egg-products","text":"Tec-Egg Raspberry Pi Tec-Egg Solar Tec-Egg Ultrasonic Examples","title":"This documentation describes all three Tec-Egg products"},{"location":"tec-egg/raspberry_pi/","text":"\"Egg\" for Raspberry Pi \u00b6 Learn how to playfully program with the Raspberry Pi using breadboard, LEDs, resistor, play dough and more. With the help of the manual, all experiments can be simply built up and programmed on the enclosed breadboard. The easy entry into the world of Raspberry Pi! MANUAL \u00b6 Here the MANUAL is provided for download.","title":"Raspberry Pi"},{"location":"tec-egg/raspberry_pi/#egg-for-raspberry-pi","text":"Learn how to playfully program with the Raspberry Pi using breadboard, LEDs, resistor, play dough and more. With the help of the manual, all experiments can be simply built up and programmed on the enclosed breadboard. The easy entry into the world of Raspberry Pi!","title":"\"Egg\" for Raspberry Pi"},{"location":"tec-egg/raspberry_pi/#manual","text":"Here the MANUAL is provided for download.","title":"MANUAL"},{"location":"tec-egg/solar/","text":"Solar \"Egg\" \u00b6 No prior knowledge needed. Unpack and start immediately. With the help of the manual, all experiments can be easily set up and understood. All required components are included. The ideal start into the world of photovoltaics! MANUAL \u00b6 Here the MANUAL is provided for download.","title":"Solar"},{"location":"tec-egg/solar/#solar-egg","text":"No prior knowledge needed. Unpack and start immediately. With the help of the manual, all experiments can be easily set up and understood. All required components are included. The ideal start into the world of photovoltaics!","title":"Solar \"Egg\""},{"location":"tec-egg/solar/#manual","text":"Here the MANUAL is provided for download.","title":"MANUAL"},{"location":"tec-egg/ultrasonic/","text":"Ultrasonic \"Egg\" \u00b6 No prior knowledge needed. Unpack and start immediately. With the help of the manual, the experiments can be easily set up and understood. All required components are included. The perfect entry into the world of ultrasonic! MANUAL \u00b6 Here the MANUAL is provided for download.","title":"Ultrasonic"},{"location":"tec-egg/ultrasonic/#ultrasonic-egg","text":"No prior knowledge needed. Unpack and start immediately. With the help of the manual, the experiments can be easily set up and understood. All required components are included. The perfect entry into the world of ultrasonic!","title":"Ultrasonic \"Egg\""},{"location":"tec-egg/ultrasonic/#manual","text":"Here the MANUAL is provided for download.","title":"MANUAL"}]}